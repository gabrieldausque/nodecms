
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':10530/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
var app = (function () {
    'use strict';

    function noop$2() { }
    const identity$1 = x => x;
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop$2;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function get_store_value(store) {
        let value;
        subscribe(store, _ => value = _)();
        return value;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function null_to_empty(value) {
        return value == null ? '' : value;
    }
    function set_store_value(store, ret, value = ret) {
        store.set(value);
        return ret;
    }

    const is_client = typeof window !== 'undefined';
    let now$1 = is_client
        ? () => window.performance.now()
        : () => Date.now();
    let raf = is_client ? cb => requestAnimationFrame(cb) : noop$2;

    const tasks = new Set();
    function run_tasks(now) {
        tasks.forEach(task => {
            if (!task.c(now)) {
                tasks.delete(task);
                task.f();
            }
        });
        if (tasks.size !== 0)
            raf(run_tasks);
    }
    /**
     * Creates a new task that runs on each raf frame
     * until it returns a falsy value or is aborted
     */
    function loop(callback) {
        let task;
        if (tasks.size === 0)
            raf(run_tasks);
        return {
            promise: new Promise(fulfill => {
                tasks.add(task = { c: callback, f: fulfill });
            }),
            abort() {
                tasks.delete(task);
            }
        };
    }

    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty$2() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function prevent_default(fn) {
        return function (event) {
            event.preventDefault();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function to_number(value) {
        return value === '' ? null : +value;
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    function select_option(select, value) {
        for (let i = 0; i < select.options.length; i += 1) {
            const option = select.options[i];
            if (option.__value === value) {
                option.selected = true;
                return;
            }
        }
    }
    function select_value(select) {
        const selected_option = select.querySelector(':checked') || select.options[0];
        return selected_option && selected_option.__value;
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, false, false, detail);
        return e;
    }
    class HtmlTag {
        constructor(anchor = null) {
            this.a = anchor;
            this.e = this.n = null;
        }
        m(html, target, anchor = null) {
            if (!this.e) {
                this.e = element(target.nodeName);
                this.t = target;
                this.h(html);
            }
            this.i(anchor);
        }
        h(html) {
            this.e.innerHTML = html;
            this.n = Array.from(this.e.childNodes);
        }
        i(anchor) {
            for (let i = 0; i < this.n.length; i += 1) {
                insert(this.t, this.n[i], anchor);
            }
        }
        p(html) {
            this.d();
            this.h(html);
            this.i(this.a);
        }
        d() {
            this.n.forEach(detach);
        }
    }

    const active_docs = new Set();
    let active = 0;
    // https://github.com/darkskyapp/string-hash/blob/master/index.js
    function hash(str) {
        let hash = 5381;
        let i = str.length;
        while (i--)
            hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
        return hash >>> 0;
    }
    function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
        const step = 16.666 / duration;
        let keyframes = '{\n';
        for (let p = 0; p <= 1; p += step) {
            const t = a + (b - a) * ease(p);
            keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
        }
        const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
        const name = `__svelte_${hash(rule)}_${uid}`;
        const doc = node.ownerDocument;
        active_docs.add(doc);
        const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);
        const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});
        if (!current_rules[name]) {
            current_rules[name] = true;
            stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
        }
        const animation = node.style.animation || '';
        node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
        active += 1;
        return name;
    }
    function delete_rule(node, name) {
        const previous = (node.style.animation || '').split(', ');
        const next = previous.filter(name
            ? anim => anim.indexOf(name) < 0 // remove specific animation
            : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
        );
        const deleted = previous.length - next.length;
        if (deleted) {
            node.style.animation = next.join(', ');
            active -= deleted;
            if (!active)
                clear_rules();
        }
    }
    function clear_rules() {
        raf(() => {
            if (active)
                return;
            active_docs.forEach(doc => {
                const stylesheet = doc.__svelte_stylesheet;
                let i = stylesheet.cssRules.length;
                while (i--)
                    stylesheet.deleteRule(i);
                doc.__svelte_rules = {};
            });
            active_docs.clear();
        });
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function beforeUpdate(fn) {
        get_current_component().$$.before_update.push(fn);
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }
    function setContext(key, context) {
        get_current_component().$$.context.set(key, context);
    }
    function getContext(key) {
        return get_current_component().$$.context.get(key);
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    let flushing = false;
    const seen_callbacks = new Set();
    function flush() {
        if (flushing)
            return;
        flushing = true;
        do {
            // first, call beforeUpdate functions
            // and update components
            for (let i = 0; i < dirty_components.length; i += 1) {
                const component = dirty_components[i];
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        flushing = false;
        seen_callbacks.clear();
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }

    let promise;
    function wait() {
        if (!promise) {
            promise = Promise.resolve();
            promise.then(() => {
                promise = null;
            });
        }
        return promise;
    }
    function dispatch(node, direction, kind) {
        node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }
    const null_transition = { duration: 0 };
    function create_in_transition(node, fn, params) {
        let config = fn(node, params);
        let running = false;
        let animation_name;
        let task;
        let uid = 0;
        function cleanup() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function go() {
            const { delay = 0, duration = 300, easing = identity$1, tick = noop$2, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
            tick(0, 1);
            const start_time = now$1() + delay;
            const end_time = start_time + duration;
            if (task)
                task.abort();
            running = true;
            add_render_callback(() => dispatch(node, true, 'start'));
            task = loop(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(1, 0);
                        dispatch(node, true, 'end');
                        cleanup();
                        return running = false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(t, 1 - t);
                    }
                }
                return running;
            });
        }
        let started = false;
        return {
            start() {
                if (started)
                    return;
                delete_rule(node);
                if (is_function(config)) {
                    config = config();
                    wait().then(go);
                }
                else {
                    go();
                }
            },
            invalidate() {
                started = false;
            },
            end() {
                if (running) {
                    cleanup();
                    running = false;
                }
            }
        };
    }
    function create_bidirectional_transition(node, fn, params, intro) {
        let config = fn(node, params);
        let t = intro ? 0 : 1;
        let running_program = null;
        let pending_program = null;
        let animation_name = null;
        function clear_animation() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function init(program, duration) {
            const d = program.b - t;
            duration *= Math.abs(d);
            return {
                a: t,
                b: program.b,
                d,
                duration,
                start: program.start,
                end: program.start + duration,
                group: program.group
            };
        }
        function go(b) {
            const { delay = 0, duration = 300, easing = identity$1, tick = noop$2, css } = config || null_transition;
            const program = {
                start: now$1() + delay,
                b
            };
            if (!b) {
                // @ts-ignore todo: improve typings
                program.group = outros;
                outros.r += 1;
            }
            if (running_program || pending_program) {
                pending_program = program;
            }
            else {
                // if this is an intro, and there's a delay, we need to do
                // an initial tick and/or apply CSS animation immediately
                if (css) {
                    clear_animation();
                    animation_name = create_rule(node, t, b, duration, delay, easing, css);
                }
                if (b)
                    tick(0, 1);
                running_program = init(program, duration);
                add_render_callback(() => dispatch(node, b, 'start'));
                loop(now => {
                    if (pending_program && now > pending_program.start) {
                        running_program = init(pending_program, duration);
                        pending_program = null;
                        dispatch(node, running_program.b, 'start');
                        if (css) {
                            clear_animation();
                            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                        }
                    }
                    if (running_program) {
                        if (now >= running_program.end) {
                            tick(t = running_program.b, 1 - t);
                            dispatch(node, running_program.b, 'end');
                            if (!pending_program) {
                                // we're done
                                if (running_program.b) {
                                    // intro — we can tidy up immediately
                                    clear_animation();
                                }
                                else {
                                    // outro — needs to be coordinated
                                    if (!--running_program.group.r)
                                        run_all(running_program.group.c);
                                }
                            }
                            running_program = null;
                        }
                        else if (now >= running_program.start) {
                            const p = now - running_program.start;
                            t = running_program.a + running_program.d * easing(p / running_program.duration);
                            tick(t, 1 - t);
                        }
                    }
                    return !!(running_program || pending_program);
                });
            }
        }
        return {
            run(b) {
                if (is_function(config)) {
                    wait().then(() => {
                        // @ts-ignore
                        config = config();
                        go(b);
                    });
                }
                else {
                    go(b);
                }
            },
            end() {
                clear_animation();
                running_program = pending_program = null;
            }
        };
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);

    function bind$2(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop$2,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : options.context || []),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false
        };
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop$2;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.38.2' }, detail)));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev('SvelteDOMSetProperty', { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    const subscriber_queue = [];
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop$2) {
        let stop;
        const subscribers = [];
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (let i = 0; i < subscribers.length; i += 1) {
                        const s = subscribers[i];
                        s[1]();
                        subscriber_queue.push(s, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop$2) {
            const subscriber = [run, invalidate];
            subscribers.push(subscriber);
            if (subscribers.length === 1) {
                stop = start(set) || noop$2;
            }
            run(value);
            return () => {
                const index = subscribers.indexOf(subscriber);
                if (index !== -1) {
                    subscribers.splice(index, 1);
                }
                if (subscribers.length === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }

    class Document$1 {
    }
    const DocumentStore = writable(new Document$1());

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function getAugmentedNamespace(n) {
    	if (n.__esModule) return n;
    	var a = Object.defineProperty({}, '__esModule', {value: true});
    	Object.keys(n).forEach(function (k) {
    		var d = Object.getOwnPropertyDescriptor(n, k);
    		Object.defineProperty(a, k, d.get ? d : {
    			enumerable: true,
    			get: function () {
    				return n[k];
    			}
    		});
    	});
    	return a;
    }

    var dist$1 = {};

    var servicesFactory = {};

    var __awaiter$8 = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    Object.defineProperty(servicesFactory, "__esModule", { value: true });
    servicesFactory.setBackendClient = servicesFactory.getBackendClient = servicesFactory.getClientConfig = void 0;
    let configuration = null;
    const getClientConfig = () => {
        if (!configuration) {
            const request = new XMLHttpRequest();
            request.open('GET', `${window.location.origin}/clientConfiguration.json`, false);
            request.send();
            if (request.status === 200)
                configuration = JSON.parse(request.responseText);
            else
                throw new Error(`Couldn\'t get config from server : ${request.responseText}`);
        }
        return configuration;
    };
    servicesFactory.getClientConfig = getClientConfig;
    let backendClient;
    const getBackendClient$1 = () => __awaiter$8(void 0, void 0, void 0, function* () {
        if (backendClient)
            return backendClient;
        throw new Error('BackendClient not initialized, please check your initialization sequence');
    });
    servicesFactory.getBackendClient = getBackendClient$1;
    const setBackendClient = (newBackendClient) => {
        backendClient = newBackendClient;
        return backendClient;
    };
    servicesFactory.setBackendClient = setBackendClient;

    var NodeCMSClient$1 = {};

    var MediaService$1 = {};

    var BaseServiceClient$1 = {};

    var SocketIOTopicServiceClientProxy$1 = {};

    var __awaiter$7 = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    Object.defineProperty(SocketIOTopicServiceClientProxy$1, "__esModule", { value: true });
    SocketIOTopicServiceClientProxy$1.SocketIOTopicServiceClientProxy = void 0;
    /**
     * The proxy client to be used on client side of a topic service that is listening to Socket.Io
     */
    class SocketIOTopicServiceClientProxy {
        /**
         * @param socket The socket used to connect to the topicservice server
         * @param readyHandler The handler to be executed just after the client has been registered
         */
        constructor(socket, readyHandler) {
            /**
             * True if the client has been correctly registered to the server (aka the topicClientId has been set)
             */
            this.isReady = false;
            /**
             * id of the client that has been received from the server after registering
             */
            this.topicClientId = "";
            /**
             * id of reconnected client
             */
            this.reconnectedTopicClientId = "";
            /**
             * handler to be execute just after the client has been registered on server side
             */
            this.readyHandler = null;
            this.isReady = false;
            this.socket = socket;
            this.subscriptions = [];
            this.ready(readyHandler);
            const current = this;
            this.socket.on('clientId', (clientId) => {
                console.log('clientId ' + clientId);
                if (!current.topicClientId) {
                    current.topicClientId = clientId;
                    if (typeof current.readyHandler === 'function') {
                        current.readyHandler.call(current);
                    }
                }
                else {
                    current.reconnectedTopicClientId = clientId;
                    current.socket.emit(current.reconnectedTopicClientId + ".changeId", current.topicClientId);
                }
            });
            this.socket.on('reconnect', () => {
                console.log('reconnecting with id :' + current.topicClientId);
                current.socket.once(current.topicClientId + ".reconnected", () => {
                    current.subscriptions.forEach((subscription) => {
                        console.log("resubscribing to " + subscription);
                        current.socket.emit(this.topicClientId + '.subscribe', subscription);
                    });
                });
            });
        }
        /**
         * Set an error handler to be executed when an error is sent to the client
         */
        onError(errorHandler) {
            const topic = this.topicClientId + ".errors";
            this.socket.on(topic, (topicMessage) => {
                if (typeof errorHandler === 'function') {
                    errorHandler(topic, topicMessage);
                }
            });
        }
        /**
         * Set the Handler to be executed just after the client has been registered on server side
         * @param readyHandler
         */
        ready(readyHandler) {
            if (typeof readyHandler === 'function') {
                this.readyHandler = readyHandler;
            }
        }
        /**
         * Subscribe to a topic and execute the handler when the corresponding topic is raised by the server
         * @param topic The topic to listen
         * @param handler The handler to be executed when a message is received for the listened topic
         */
        subscribe(topic, handler) {
            return __awaiter$7(this, void 0, void 0, function* () {
                this.socket.emit(this.topicClientId + '.subscribe', topic);
                if (this.subscriptions.indexOf(topic) < 0) {
                    this.subscriptions.push(topic);
                }
                this.socket.on(topic, (topicMessage) => {
                    handler(topicMessage.fromTopic, topicMessage);
                });
            });
        }
        /**
         * Publish a message on a specific topic
         * @param topic The topic to publish on
         * @param topicContent The content of the message to be published
         */
        publish(topic, topicContent) {
            return __awaiter$7(this, void 0, void 0, function* () {
                this.socket.emit(this.topicClientId + '.publish', {
                    topic: topic,
                    content: topicContent
                });
            });
        }
        /**
         * List all subscriptions registered on server side
         * @param callback the callback to be executed when the list of subscriptions are received
         */
        getSubscriptions(callback) {
            return __awaiter$7(this, void 0, void 0, function* () {
                const currentClient = this;
                const subscriptionsListTopic = this.topicClientId + '.subscriptions.list';
                this.subscribe(subscriptionsListTopic, (topic, topicMessage) => {
                    currentClient.unSubscribe(subscriptionsListTopic).then(() => { });
                    callback(topic, topicMessage);
                });
                this.publish(this.topicClientId + '.subscriptions.get', null);
            });
        }
        /**
         * Unsubscribe all handlers for the specified topic
         * @param topic the topic to unsubscribe
         */
        unSubscribe(topic) {
            return __awaiter$7(this, void 0, void 0, function* () {
                this.socket.removeAllListeners(topic);
                if (this.subscriptions.indexOf(topic) >= 0) {
                    this.subscriptions.slice(this.subscriptions.indexOf(topic), 1);
                }
                this.publish(this.topicClientId + '.unsubscribe', topic).then(() => { });
            });
        }
    }
    SocketIOTopicServiceClientProxy$1.SocketIOTopicServiceClientProxy = SocketIOTopicServiceClientProxy;

    var lib$1 = {exports: {}};

    /**
     * Parses an URI
     *
     * @author Steven Levithan <stevenlevithan.com> (MIT license)
     * @api private
     */

    var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

    var parts = [
        'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
    ];

    var parseuri$2 = function parseuri(str) {
        var src = str,
            b = str.indexOf('['),
            e = str.indexOf(']');

        if (b != -1 && e != -1) {
            str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
        }

        var m = re.exec(str || ''),
            uri = {},
            i = 14;

        while (i--) {
            uri[parts[i]] = m[i] || '';
        }

        if (b != -1 && e != -1) {
            uri.source = src;
            uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
            uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
            uri.ipv6uri = true;
        }

        uri.pathNames = pathNames(uri, uri['path']);
        uri.queryKey = queryKey(uri, uri['query']);

        return uri;
    };

    function pathNames(obj, path) {
        var regx = /\/{2,9}/g,
            names = path.replace(regx, "/").split("/");

        if (path.substr(0, 1) == '/' || path.length === 0) {
            names.splice(0, 1);
        }
        if (path.substr(path.length - 1, 1) == '/') {
            names.splice(names.length - 1, 1);
        }

        return names;
    }

    function queryKey(uri, query) {
        var data = {};

        query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {
            if ($1) {
                data[$1] = $2;
            }
        });

        return data;
    }

    var browser$1 = {exports: {}};

    var debug$6 = {exports: {}};

    /**
     * Helpers.
     */

    var s = 1000;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;

    /**
     * Parse or format the given `val`.
     *
     * Options:
     *
     *  - `long` verbose formatting [false]
     *
     * @param {String|Number} val
     * @param {Object} [options]
     * @throws {Error} throw an error if val is not a non-empty string or a number
     * @return {String|Number}
     * @api public
     */

    var ms = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === 'string' && val.length > 0) {
        return parse$1(val);
      } else if (type === 'number' && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        'val is not a non-empty string or a valid number. val=' +
          JSON.stringify(val)
      );
    };

    /**
     * Parse the given `str` and return milliseconds.
     *
     * @param {String} str
     * @return {Number}
     * @api private
     */

    function parse$1(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || 'ms').toLowerCase();
      switch (type) {
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
          return n * y;
        case 'days':
        case 'day':
        case 'd':
          return n * d;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
          return n * h;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
          return n * m;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
          return n * s;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
          return n;
        default:
          return undefined;
      }
    }

    /**
     * Short format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */

    function fmtShort(ms) {
      if (ms >= d) {
        return Math.round(ms / d) + 'd';
      }
      if (ms >= h) {
        return Math.round(ms / h) + 'h';
      }
      if (ms >= m) {
        return Math.round(ms / m) + 'm';
      }
      if (ms >= s) {
        return Math.round(ms / s) + 's';
      }
      return ms + 'ms';
    }

    /**
     * Long format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */

    function fmtLong(ms) {
      return plural(ms, d, 'day') ||
        plural(ms, h, 'hour') ||
        plural(ms, m, 'minute') ||
        plural(ms, s, 'second') ||
        ms + ' ms';
    }

    /**
     * Pluralization helper.
     */

    function plural(ms, n, name) {
      if (ms < n) {
        return;
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + ' ' + name;
      }
      return Math.ceil(ms / n) + ' ' + name + 's';
    }

    (function (module, exports) {
    /**
     * This is the common logic for both the Node.js and web browser
     * implementations of `debug()`.
     *
     * Expose `debug()` as the module.
     */

    exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = ms;

    /**
     * Active `debug` instances.
     */
    exports.instances = [];

    /**
     * The currently active debug mode names, and names to skip.
     */

    exports.names = [];
    exports.skips = [];

    /**
     * Map of special "%n" handling functions, for the debug "format" argument.
     *
     * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
     */

    exports.formatters = {};

    /**
     * Select a color.
     * @param {String} namespace
     * @return {Number}
     * @api private
     */

    function selectColor(namespace) {
      var hash = 0, i;

      for (i in namespace) {
        hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
        hash |= 0; // Convert to 32bit integer
      }

      return exports.colors[Math.abs(hash) % exports.colors.length];
    }

    /**
     * Create a debugger with the given `namespace`.
     *
     * @param {String} namespace
     * @return {Function}
     * @api public
     */

    function createDebug(namespace) {

      var prevTime;

      function debug() {
        // disabled?
        if (!debug.enabled) return;

        var self = debug;

        // set `diff` timestamp
        var curr = +new Date();
        var ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;

        // turn the `arguments` into a proper Array
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }

        args[0] = exports.coerce(args[0]);

        if ('string' !== typeof args[0]) {
          // anything else let's inspect with %O
          args.unshift('%O');
        }

        // apply any `formatters` transformations
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
          // if we encounter an escaped % then don't increase the array index
          if (match === '%%') return match;
          index++;
          var formatter = exports.formatters[format];
          if ('function' === typeof formatter) {
            var val = args[index];
            match = formatter.call(self, val);

            // now we need to remove `args[index]` since it's inlined in the `format`
            args.splice(index, 1);
            index--;
          }
          return match;
        });

        // apply env-specific formatting (colors, etc.)
        exports.formatArgs.call(self, args);

        var logFn = debug.log || exports.log || console.log.bind(console);
        logFn.apply(self, args);
      }

      debug.namespace = namespace;
      debug.enabled = exports.enabled(namespace);
      debug.useColors = exports.useColors();
      debug.color = selectColor(namespace);
      debug.destroy = destroy;

      // env-specific initialization logic for debug instances
      if ('function' === typeof exports.init) {
        exports.init(debug);
      }

      exports.instances.push(debug);

      return debug;
    }

    function destroy () {
      var index = exports.instances.indexOf(this);
      if (index !== -1) {
        exports.instances.splice(index, 1);
        return true;
      } else {
        return false;
      }
    }

    /**
     * Enables a debug mode by namespaces. This can include modes
     * separated by a colon and wildcards.
     *
     * @param {String} namespaces
     * @api public
     */

    function enable(namespaces) {
      exports.save(namespaces);

      exports.names = [];
      exports.skips = [];

      var i;
      var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
      var len = split.length;

      for (i = 0; i < len; i++) {
        if (!split[i]) continue; // ignore empty strings
        namespaces = split[i].replace(/\*/g, '.*?');
        if (namespaces[0] === '-') {
          exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
        } else {
          exports.names.push(new RegExp('^' + namespaces + '$'));
        }
      }

      for (i = 0; i < exports.instances.length; i++) {
        var instance = exports.instances[i];
        instance.enabled = exports.enabled(instance.namespace);
      }
    }

    /**
     * Disable debug output.
     *
     * @api public
     */

    function disable() {
      exports.enable('');
    }

    /**
     * Returns true if the given mode name is enabled, false otherwise.
     *
     * @param {String} name
     * @return {Boolean}
     * @api public
     */

    function enabled(name) {
      if (name[name.length - 1] === '*') {
        return true;
      }
      var i, len;
      for (i = 0, len = exports.skips.length; i < len; i++) {
        if (exports.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports.names.length; i < len; i++) {
        if (exports.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }

    /**
     * Coerce `val`.
     *
     * @param {Mixed} val
     * @return {Mixed}
     * @api private
     */

    function coerce(val) {
      if (val instanceof Error) return val.stack || val.message;
      return val;
    }
    }(debug$6, debug$6.exports));

    /**
     * This is the web browser implementation of `debug()`.
     *
     * Expose `debug()` as the module.
     */

    (function (module, exports) {
    exports = module.exports = debug$6.exports;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = 'undefined' != typeof chrome
                   && 'undefined' != typeof chrome.storage
                      ? chrome.storage.local
                      : localstorage();

    /**
     * Colors.
     */

    exports.colors = [
      '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',
      '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',
      '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',
      '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',
      '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',
      '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',
      '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',
      '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',
      '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',
      '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',
      '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'
    ];

    /**
     * Currently only WebKit-based Web Inspectors, Firefox >= v31,
     * and the Firebug extension (any Firefox version) are known
     * to support "%c" CSS customizations.
     *
     * TODO: add a `localStorage` variable to explicitly enable/disable colors
     */

    function useColors() {
      // NB: In an Electron preload script, document will be defined but not fully
      // initialized. Since we know we're in Chrome, we'll just detect this case
      // explicitly
      if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
        return true;
      }

      // Internet Explorer and Edge do not support colors.
      if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }

      // is webkit? http://stackoverflow.com/a/16459606/376773
      // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
      return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
        // is firebug? http://stackoverflow.com/a/398120/376773
        (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
        // is firefox >= v31?
        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
        (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
        // double check webkit in userAgent just in case we are in a worker
        (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
    }

    /**
     * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
     */

    exports.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return '[UnexpectedJSONParseError]: ' + err.message;
      }
    };


    /**
     * Colorize log arguments if enabled.
     *
     * @api public
     */

    function formatArgs(args) {
      var useColors = this.useColors;

      args[0] = (useColors ? '%c' : '')
        + this.namespace
        + (useColors ? ' %c' : ' ')
        + args[0]
        + (useColors ? '%c ' : ' ')
        + '+' + exports.humanize(this.diff);

      if (!useColors) return;

      var c = 'color: ' + this.color;
      args.splice(1, 0, c, 'color: inherit');

      // the final "%c" is somewhat tricky, because there could be other
      // arguments passed either before or after the %c, so we need to
      // figure out the correct index to insert the CSS into
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if ('%%' === match) return;
        index++;
        if ('%c' === match) {
          // we only are interested in the *last* %c
          // (the user may have provided their own)
          lastC = index;
        }
      });

      args.splice(lastC, 0, c);
    }

    /**
     * Invokes `console.log()` when available.
     * No-op when `console.log` is not a "function".
     *
     * @api public
     */

    function log() {
      // this hackery is required for IE8/9, where
      // the `console.log` function doesn't have 'apply'
      return 'object' === typeof console
        && console.log
        && Function.prototype.apply.call(console.log, console, arguments);
    }

    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */

    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports.storage.removeItem('debug');
        } else {
          exports.storage.debug = namespaces;
        }
      } catch(e) {}
    }

    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */

    function load() {
      var r;
      try {
        r = exports.storage.debug;
      } catch(e) {}

      // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
      if (!r && typeof process !== 'undefined' && 'env' in process) {
        r = process.env.DEBUG;
      }

      return r;
    }

    /**
     * Enable namespaces listed in `localStorage.debug` initially.
     */

    exports.enable(load());

    /**
     * Localstorage attempts to return the localstorage.
     *
     * This is necessary because safari throws
     * when a user disables cookies/localstorage
     * and you attempt to access it.
     *
     * @return {LocalStorage}
     * @api private
     */

    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {}
    }
    }(browser$1, browser$1.exports));

    /**
     * Module dependencies.
     */

    var parseuri$1 = parseuri$2;
    var debug$5 = browser$1.exports('socket.io-client:url');

    /**
     * Module exports.
     */

    var url_1 = url;

    /**
     * URL parser.
     *
     * @param {String} url
     * @param {Object} An object meant to mimic window.location.
     *                 Defaults to window.location.
     * @api public
     */

    function url (uri, loc) {
      var obj = uri;

      // default to window.location
      loc = loc || (typeof location !== 'undefined' && location);
      if (null == uri) uri = loc.protocol + '//' + loc.host;

      // relative path support
      if ('string' === typeof uri) {
        if ('/' === uri.charAt(0)) {
          if ('/' === uri.charAt(1)) {
            uri = loc.protocol + uri;
          } else {
            uri = loc.host + uri;
          }
        }

        if (!/^(https?|wss?):\/\//.test(uri)) {
          debug$5('protocol-less url %s', uri);
          if ('undefined' !== typeof loc) {
            uri = loc.protocol + '//' + uri;
          } else {
            uri = 'https://' + uri;
          }
        }

        // parse
        debug$5('parse %s', uri);
        obj = parseuri$1(uri);
      }

      // make sure we treat `localhost:80` and `localhost` equally
      if (!obj.port) {
        if (/^(http|ws)$/.test(obj.protocol)) {
          obj.port = '80';
        } else if (/^(http|ws)s$/.test(obj.protocol)) {
          obj.port = '443';
        }
      }

      obj.path = obj.path || '/';

      var ipv6 = obj.host.indexOf(':') !== -1;
      var host = ipv6 ? '[' + obj.host + ']' : obj.host;

      // define unique id
      obj.id = obj.protocol + '://' + host + ':' + obj.port;
      // define href
      obj.href = obj.protocol + '://' + host + (loc && loc.port === obj.port ? '' : (':' + obj.port));

      return obj;
    }

    var socket_ioParser = {};

    var componentEmitter = {exports: {}};

    (function (module) {
    /**
     * Expose `Emitter`.
     */

    {
      module.exports = Emitter;
    }

    /**
     * Initialize a new `Emitter`.
     *
     * @api public
     */

    function Emitter(obj) {
      if (obj) return mixin(obj);
    }
    /**
     * Mixin the emitter properties.
     *
     * @param {Object} obj
     * @return {Object}
     * @api private
     */

    function mixin(obj) {
      for (var key in Emitter.prototype) {
        obj[key] = Emitter.prototype[key];
      }
      return obj;
    }

    /**
     * Listen on the given `event` with `fn`.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */

    Emitter.prototype.on =
    Emitter.prototype.addEventListener = function(event, fn){
      this._callbacks = this._callbacks || {};
      (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
        .push(fn);
      return this;
    };

    /**
     * Adds an `event` listener that will be invoked a single
     * time then automatically removed.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */

    Emitter.prototype.once = function(event, fn){
      function on() {
        this.off(event, on);
        fn.apply(this, arguments);
      }

      on.fn = fn;
      this.on(event, on);
      return this;
    };

    /**
     * Remove the given callback for `event` or all
     * registered callbacks.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */

    Emitter.prototype.off =
    Emitter.prototype.removeListener =
    Emitter.prototype.removeAllListeners =
    Emitter.prototype.removeEventListener = function(event, fn){
      this._callbacks = this._callbacks || {};

      // all
      if (0 == arguments.length) {
        this._callbacks = {};
        return this;
      }

      // specific event
      var callbacks = this._callbacks['$' + event];
      if (!callbacks) return this;

      // remove all handlers
      if (1 == arguments.length) {
        delete this._callbacks['$' + event];
        return this;
      }

      // remove specific handler
      var cb;
      for (var i = 0; i < callbacks.length; i++) {
        cb = callbacks[i];
        if (cb === fn || cb.fn === fn) {
          callbacks.splice(i, 1);
          break;
        }
      }

      // Remove event specific arrays for event types that no
      // one is subscribed for to avoid memory leak.
      if (callbacks.length === 0) {
        delete this._callbacks['$' + event];
      }

      return this;
    };

    /**
     * Emit `event` with the given args.
     *
     * @param {String} event
     * @param {Mixed} ...
     * @return {Emitter}
     */

    Emitter.prototype.emit = function(event){
      this._callbacks = this._callbacks || {};

      var args = new Array(arguments.length - 1)
        , callbacks = this._callbacks['$' + event];

      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }

      if (callbacks) {
        callbacks = callbacks.slice(0);
        for (var i = 0, len = callbacks.length; i < len; ++i) {
          callbacks[i].apply(this, args);
        }
      }

      return this;
    };

    /**
     * Return array of callbacks for `event`.
     *
     * @param {String} event
     * @return {Array}
     * @api public
     */

    Emitter.prototype.listeners = function(event){
      this._callbacks = this._callbacks || {};
      return this._callbacks['$' + event] || [];
    };

    /**
     * Check if this emitter has `event` handlers.
     *
     * @param {String} event
     * @return {Boolean}
     * @api public
     */

    Emitter.prototype.hasListeners = function(event){
      return !! this.listeners(event).length;
    };
    }(componentEmitter));

    var binary = {};

    var toString$4 = {}.toString;

    var isarray$1 = Array.isArray || function (arr) {
      return toString$4.call(arr) == '[object Array]';
    };

    var isBuffer = isBuf$1;

    var withNativeBuffer = typeof Buffer === 'function' && typeof Buffer.isBuffer === 'function';
    var withNativeArrayBuffer = typeof ArrayBuffer === 'function';

    var isView = function (obj) {
      return typeof ArrayBuffer.isView === 'function' ? ArrayBuffer.isView(obj) : (obj.buffer instanceof ArrayBuffer);
    };

    /**
     * Returns true if obj is a buffer or an arraybuffer.
     *
     * @api private
     */

    function isBuf$1(obj) {
      return (withNativeBuffer && Buffer.isBuffer(obj)) ||
              (withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)));
    }

    /*global Blob,File*/

    /**
     * Module requirements
     */

    var isArray$2 = isarray$1;
    var isBuf = isBuffer;
    var toString$3 = Object.prototype.toString;
    var withNativeBlob$1 = typeof Blob === 'function' || (typeof Blob !== 'undefined' && toString$3.call(Blob) === '[object BlobConstructor]');
    var withNativeFile$1 = typeof File === 'function' || (typeof File !== 'undefined' && toString$3.call(File) === '[object FileConstructor]');

    /**
     * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
     * Anything with blobs or files should be fed through removeBlobs before coming
     * here.
     *
     * @param {Object} packet - socket.io event packet
     * @return {Object} with deconstructed packet and list of buffers
     * @api public
     */

    binary.deconstructPacket = function(packet) {
      var buffers = [];
      var packetData = packet.data;
      var pack = packet;
      pack.data = _deconstructPacket(packetData, buffers);
      pack.attachments = buffers.length; // number of binary 'attachments'
      return {packet: pack, buffers: buffers};
    };

    function _deconstructPacket(data, buffers) {
      if (!data) return data;

      if (isBuf(data)) {
        var placeholder = { _placeholder: true, num: buffers.length };
        buffers.push(data);
        return placeholder;
      } else if (isArray$2(data)) {
        var newData = new Array(data.length);
        for (var i = 0; i < data.length; i++) {
          newData[i] = _deconstructPacket(data[i], buffers);
        }
        return newData;
      } else if (typeof data === 'object' && !(data instanceof Date)) {
        var newData = {};
        for (var key in data) {
          newData[key] = _deconstructPacket(data[key], buffers);
        }
        return newData;
      }
      return data;
    }

    /**
     * Reconstructs a binary packet from its placeholder packet and buffers
     *
     * @param {Object} packet - event packet with placeholders
     * @param {Array} buffers - binary buffers to put in placeholder positions
     * @return {Object} reconstructed packet
     * @api public
     */

    binary.reconstructPacket = function(packet, buffers) {
      packet.data = _reconstructPacket(packet.data, buffers);
      packet.attachments = undefined; // no longer useful
      return packet;
    };

    function _reconstructPacket(data, buffers) {
      if (!data) return data;

      if (data && data._placeholder) {
        return buffers[data.num]; // appropriate buffer (should be natural order anyway)
      } else if (isArray$2(data)) {
        for (var i = 0; i < data.length; i++) {
          data[i] = _reconstructPacket(data[i], buffers);
        }
      } else if (typeof data === 'object') {
        for (var key in data) {
          data[key] = _reconstructPacket(data[key], buffers);
        }
      }

      return data;
    }

    /**
     * Asynchronously removes Blobs or Files from data via
     * FileReader's readAsArrayBuffer method. Used before encoding
     * data as msgpack. Calls callback with the blobless data.
     *
     * @param {Object} data
     * @param {Function} callback
     * @api private
     */

    binary.removeBlobs = function(data, callback) {
      function _removeBlobs(obj, curKey, containingObject) {
        if (!obj) return obj;

        // convert any blob
        if ((withNativeBlob$1 && obj instanceof Blob) ||
            (withNativeFile$1 && obj instanceof File)) {
          pendingBlobs++;

          // async filereader
          var fileReader = new FileReader();
          fileReader.onload = function() { // this.result == arraybuffer
            if (containingObject) {
              containingObject[curKey] = this.result;
            }
            else {
              bloblessData = this.result;
            }

            // if nothing pending its callback time
            if(! --pendingBlobs) {
              callback(bloblessData);
            }
          };

          fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
        } else if (isArray$2(obj)) { // handle array
          for (var i = 0; i < obj.length; i++) {
            _removeBlobs(obj[i], i, obj);
          }
        } else if (typeof obj === 'object' && !isBuf(obj)) { // and object
          for (var key in obj) {
            _removeBlobs(obj[key], key, obj);
          }
        }
      }

      var pendingBlobs = 0;
      var bloblessData = data;
      _removeBlobs(bloblessData);
      if (!pendingBlobs) {
        callback(bloblessData);
      }
    };

    (function (exports) {
    /**
     * Module dependencies.
     */

    var debug = browser$1.exports('socket.io-parser');
    var Emitter = componentEmitter.exports;
    var binary$1 = binary;
    var isArray = isarray$1;
    var isBuf = isBuffer;

    /**
     * Protocol version.
     *
     * @api public
     */

    exports.protocol = 4;

    /**
     * Packet types.
     *
     * @api public
     */

    exports.types = [
      'CONNECT',
      'DISCONNECT',
      'EVENT',
      'ACK',
      'ERROR',
      'BINARY_EVENT',
      'BINARY_ACK'
    ];

    /**
     * Packet type `connect`.
     *
     * @api public
     */

    exports.CONNECT = 0;

    /**
     * Packet type `disconnect`.
     *
     * @api public
     */

    exports.DISCONNECT = 1;

    /**
     * Packet type `event`.
     *
     * @api public
     */

    exports.EVENT = 2;

    /**
     * Packet type `ack`.
     *
     * @api public
     */

    exports.ACK = 3;

    /**
     * Packet type `error`.
     *
     * @api public
     */

    exports.ERROR = 4;

    /**
     * Packet type 'binary event'
     *
     * @api public
     */

    exports.BINARY_EVENT = 5;

    /**
     * Packet type `binary ack`. For acks with binary arguments.
     *
     * @api public
     */

    exports.BINARY_ACK = 6;

    /**
     * Encoder constructor.
     *
     * @api public
     */

    exports.Encoder = Encoder;

    /**
     * Decoder constructor.
     *
     * @api public
     */

    exports.Decoder = Decoder;

    /**
     * A socket.io Encoder instance
     *
     * @api public
     */

    function Encoder() {}

    var ERROR_PACKET = exports.ERROR + '"encode error"';

    /**
     * Encode a packet as a single string if non-binary, or as a
     * buffer sequence, depending on packet type.
     *
     * @param {Object} obj - packet object
     * @param {Function} callback - function to handle encodings (likely engine.write)
     * @return Calls callback with Array of encodings
     * @api public
     */

    Encoder.prototype.encode = function(obj, callback){
      debug('encoding packet %j', obj);

      if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
        encodeAsBinary(obj, callback);
      } else {
        var encoding = encodeAsString(obj);
        callback([encoding]);
      }
    };

    /**
     * Encode packet as string.
     *
     * @param {Object} packet
     * @return {String} encoded
     * @api private
     */

    function encodeAsString(obj) {

      // first is type
      var str = '' + obj.type;

      // attachments if we have them
      if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
        str += obj.attachments + '-';
      }

      // if we have a namespace other than `/`
      // we append it followed by a comma `,`
      if (obj.nsp && '/' !== obj.nsp) {
        str += obj.nsp + ',';
      }

      // immediately followed by the id
      if (null != obj.id) {
        str += obj.id;
      }

      // json data
      if (null != obj.data) {
        var payload = tryStringify(obj.data);
        if (payload !== false) {
          str += payload;
        } else {
          return ERROR_PACKET;
        }
      }

      debug('encoded %j as %s', obj, str);
      return str;
    }

    function tryStringify(str) {
      try {
        return JSON.stringify(str);
      } catch(e){
        return false;
      }
    }

    /**
     * Encode packet as 'buffer sequence' by removing blobs, and
     * deconstructing packet into object with placeholders and
     * a list of buffers.
     *
     * @param {Object} packet
     * @return {Buffer} encoded
     * @api private
     */

    function encodeAsBinary(obj, callback) {

      function writeEncoding(bloblessData) {
        var deconstruction = binary$1.deconstructPacket(bloblessData);
        var pack = encodeAsString(deconstruction.packet);
        var buffers = deconstruction.buffers;

        buffers.unshift(pack); // add packet info to beginning of data list
        callback(buffers); // write all the buffers
      }

      binary$1.removeBlobs(obj, writeEncoding);
    }

    /**
     * A socket.io Decoder instance
     *
     * @return {Object} decoder
     * @api public
     */

    function Decoder() {
      this.reconstructor = null;
    }

    /**
     * Mix in `Emitter` with Decoder.
     */

    Emitter(Decoder.prototype);

    /**
     * Decodes an encoded packet string into packet JSON.
     *
     * @param {String} obj - encoded packet
     * @return {Object} packet
     * @api public
     */

    Decoder.prototype.add = function(obj) {
      var packet;
      if (typeof obj === 'string') {
        packet = decodeString(obj);
        if (exports.BINARY_EVENT === packet.type || exports.BINARY_ACK === packet.type) { // binary packet's json
          this.reconstructor = new BinaryReconstructor(packet);

          // no attachments, labeled binary but no binary data to follow
          if (this.reconstructor.reconPack.attachments === 0) {
            this.emit('decoded', packet);
          }
        } else { // non-binary full packet
          this.emit('decoded', packet);
        }
      } else if (isBuf(obj) || obj.base64) { // raw binary data
        if (!this.reconstructor) {
          throw new Error('got binary data when not reconstructing a packet');
        } else {
          packet = this.reconstructor.takeBinaryData(obj);
          if (packet) { // received final buffer
            this.reconstructor = null;
            this.emit('decoded', packet);
          }
        }
      } else {
        throw new Error('Unknown type: ' + obj);
      }
    };

    /**
     * Decode a packet String (JSON data)
     *
     * @param {String} str
     * @return {Object} packet
     * @api private
     */

    function decodeString(str) {
      var i = 0;
      // look up type
      var p = {
        type: Number(str.charAt(0))
      };

      if (null == exports.types[p.type]) {
        return error('unknown packet type ' + p.type);
      }

      // look up attachments if type binary
      if (exports.BINARY_EVENT === p.type || exports.BINARY_ACK === p.type) {
        var start = i + 1;
        while (str.charAt(++i) !== '-' && i != str.length) {}
        var buf = str.substring(start, i);
        if (buf != Number(buf) || str.charAt(i) !== '-') {
          throw new Error('Illegal attachments');
        }
        p.attachments = Number(buf);
      }

      // look up namespace (if any)
      if ('/' === str.charAt(i + 1)) {
        var start = i + 1;
        while (++i) {
          var c = str.charAt(i);
          if (',' === c) break;
          if (i === str.length) break;
        }
        p.nsp = str.substring(start, i);
      } else {
        p.nsp = '/';
      }

      // look up id
      var next = str.charAt(i + 1);
      if ('' !== next && Number(next) == next) {
        var start = i + 1;
        while (++i) {
          var c = str.charAt(i);
          if (null == c || Number(c) != c) {
            --i;
            break;
          }
          if (i === str.length) break;
        }
        p.id = Number(str.substring(start, i + 1));
      }

      // look up json data
      if (str.charAt(++i)) {
        var payload = tryParse(str.substr(i));
        var isPayloadValid = payload !== false && (p.type === exports.ERROR || isArray(payload));
        if (isPayloadValid) {
          p.data = payload;
        } else {
          return error('invalid payload');
        }
      }

      debug('decoded %s as %j', str, p);
      return p;
    }

    function tryParse(str) {
      try {
        return JSON.parse(str);
      } catch(e){
        return false;
      }
    }

    /**
     * Deallocates a parser's resources
     *
     * @api public
     */

    Decoder.prototype.destroy = function() {
      if (this.reconstructor) {
        this.reconstructor.finishedReconstruction();
      }
    };

    /**
     * A manager of a binary event's 'buffer sequence'. Should
     * be constructed whenever a packet of type BINARY_EVENT is
     * decoded.
     *
     * @param {Object} packet
     * @return {BinaryReconstructor} initialized reconstructor
     * @api private
     */

    function BinaryReconstructor(packet) {
      this.reconPack = packet;
      this.buffers = [];
    }

    /**
     * Method to be called when binary data received from connection
     * after a BINARY_EVENT packet.
     *
     * @param {Buffer | ArrayBuffer} binData - the raw binary data received
     * @return {null | Object} returns null if more binary data is expected or
     *   a reconstructed packet object if all buffers have been received.
     * @api private
     */

    BinaryReconstructor.prototype.takeBinaryData = function(binData) {
      this.buffers.push(binData);
      if (this.buffers.length === this.reconPack.attachments) { // done with buffer list
        var packet = binary$1.reconstructPacket(this.reconPack, this.buffers);
        this.finishedReconstruction();
        return packet;
      }
      return null;
    };

    /**
     * Cleans up binary packet reconstruction variables.
     *
     * @api private
     */

    BinaryReconstructor.prototype.finishedReconstruction = function() {
      this.reconPack = null;
      this.buffers = [];
    };

    function error(msg) {
      return {
        type: exports.ERROR,
        data: 'parser error: ' + msg
      };
    }
    }(socket_ioParser));

    var lib = {exports: {}};

    var transports$1 = {};

    var hasCors = {exports: {}};

    /**
     * Module exports.
     *
     * Logic borrowed from Modernizr:
     *
     *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
     */

    try {
      hasCors.exports = typeof XMLHttpRequest !== 'undefined' &&
        'withCredentials' in new XMLHttpRequest();
    } catch (err) {
      // if XMLHttp support is disabled in IE then it will throw
      // when trying to create
      hasCors.exports = false;
    }

    var globalThis_browser = (function () {
      if (typeof self !== 'undefined') {
        return self;
      } else if (typeof window !== 'undefined') {
        return window;
      } else {
        return Function('return this')(); // eslint-disable-line no-new-func
      }
    })();

    // browser shim for xmlhttprequest module

    var hasCORS = hasCors.exports;
    var globalThis$3 = globalThis_browser;

    var xmlhttprequest = function (opts) {
      var xdomain = opts.xdomain;

      // scheme must be same when usign XDomainRequest
      // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
      var xscheme = opts.xscheme;

      // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
      // https://github.com/Automattic/engine.io-client/pull/217
      var enablesXDR = opts.enablesXDR;

      // XMLHttpRequest can be disabled on IE
      try {
        if ('undefined' !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
          return new XMLHttpRequest();
        }
      } catch (e) { }

      // Use XDomainRequest for IE8 if enablesXDR is true
      // because loading bar keeps flashing when using jsonp-polling
      // https://github.com/yujiosaka/socke.io-ie8-loading-example
      try {
        if ('undefined' !== typeof XDomainRequest && !xscheme && enablesXDR) {
          return new XDomainRequest();
        }
      } catch (e) { }

      if (!xdomain) {
        try {
          return new globalThis$3[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP');
        } catch (e) { }
      }
    };

    var pollingXhr = {exports: {}};

    var browser = {};

    /**
     * Gets the keys for an object.
     *
     * @return {Array} keys
     * @api private
     */

    var keys$1 = Object.keys || function keys (obj){
      var arr = [];
      var has = Object.prototype.hasOwnProperty;

      for (var i in obj) {
        if (has.call(obj, i)) {
          arr.push(i);
        }
      }
      return arr;
    };

    var toString$2 = {}.toString;

    var isarray = Array.isArray || function (arr) {
      return toString$2.call(arr) == '[object Array]';
    };

    /* global Blob File */

    /*
     * Module requirements.
     */

    var isArray$1 = isarray;

    var toString$1 = Object.prototype.toString;
    var withNativeBlob = typeof Blob === 'function' ||
                            typeof Blob !== 'undefined' && toString$1.call(Blob) === '[object BlobConstructor]';
    var withNativeFile = typeof File === 'function' ||
                            typeof File !== 'undefined' && toString$1.call(File) === '[object FileConstructor]';

    /**
     * Module exports.
     */

    var hasBinary2 = hasBinary;

    /**
     * Checks for binary data.
     *
     * Supports Buffer, ArrayBuffer, Blob and File.
     *
     * @param {Object} anything
     * @api public
     */

    function hasBinary (obj) {
      if (!obj || typeof obj !== 'object') {
        return false;
      }

      if (isArray$1(obj)) {
        for (var i = 0, l = obj.length; i < l; i++) {
          if (hasBinary(obj[i])) {
            return true;
          }
        }
        return false;
      }

      if ((typeof Buffer === 'function' && Buffer.isBuffer && Buffer.isBuffer(obj)) ||
        (typeof ArrayBuffer === 'function' && obj instanceof ArrayBuffer) ||
        (withNativeBlob && obj instanceof Blob) ||
        (withNativeFile && obj instanceof File)
      ) {
        return true;
      }

      // see: https://github.com/Automattic/has-binary/pull/4
      if (obj.toJSON && typeof obj.toJSON === 'function' && arguments.length === 1) {
        return hasBinary(obj.toJSON(), true);
      }

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
          return true;
        }
      }

      return false;
    }

    /**
     * An abstraction for slicing an arraybuffer even when
     * ArrayBuffer.prototype.slice is not supported
     *
     * @api public
     */

    var arraybuffer_slice = function(arraybuffer, start, end) {
      var bytes = arraybuffer.byteLength;
      start = start || 0;
      end = end || bytes;

      if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

      if (start < 0) { start += bytes; }
      if (end < 0) { end += bytes; }
      if (end > bytes) { end = bytes; }

      if (start >= bytes || start >= end || bytes === 0) {
        return new ArrayBuffer(0);
      }

      var abv = new Uint8Array(arraybuffer);
      var result = new Uint8Array(end - start);
      for (var i = start, ii = 0; i < end; i++, ii++) {
        result[ii] = abv[i];
      }
      return result.buffer;
    };

    var after_1 = after$1;

    function after$1(count, callback, err_cb) {
        var bail = false;
        err_cb = err_cb || noop$1;
        proxy.count = count;

        return (count === 0) ? callback() : proxy

        function proxy(err, result) {
            if (proxy.count <= 0) {
                throw new Error('after called too many times')
            }
            --proxy.count;

            // after first error, rest are passed to err_cb
            if (err) {
                bail = true;
                callback(err);
                // future error callbacks will go to error handler
                callback = err_cb;
            } else if (proxy.count === 0 && !bail) {
                callback(null, result);
            }
        }
    }

    function noop$1() {}

    /*! https://mths.be/utf8js v2.1.2 by @mathias */

    var stringFromCharCode = String.fromCharCode;

    // Taken from https://mths.be/punycode
    function ucs2decode(string) {
    	var output = [];
    	var counter = 0;
    	var length = string.length;
    	var value;
    	var extra;
    	while (counter < length) {
    		value = string.charCodeAt(counter++);
    		if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
    			// high surrogate, and there is a next character
    			extra = string.charCodeAt(counter++);
    			if ((extra & 0xFC00) == 0xDC00) { // low surrogate
    				output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
    			} else {
    				// unmatched surrogate; only append this code unit, in case the next
    				// code unit is the high surrogate of a surrogate pair
    				output.push(value);
    				counter--;
    			}
    		} else {
    			output.push(value);
    		}
    	}
    	return output;
    }

    // Taken from https://mths.be/punycode
    function ucs2encode(array) {
    	var length = array.length;
    	var index = -1;
    	var value;
    	var output = '';
    	while (++index < length) {
    		value = array[index];
    		if (value > 0xFFFF) {
    			value -= 0x10000;
    			output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
    			value = 0xDC00 | value & 0x3FF;
    		}
    		output += stringFromCharCode(value);
    	}
    	return output;
    }

    function checkScalarValue(codePoint, strict) {
    	if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
    		if (strict) {
    			throw Error(
    				'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
    				' is not a scalar value'
    			);
    		}
    		return false;
    	}
    	return true;
    }
    /*--------------------------------------------------------------------------*/

    function createByte(codePoint, shift) {
    	return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
    }

    function encodeCodePoint(codePoint, strict) {
    	if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
    		return stringFromCharCode(codePoint);
    	}
    	var symbol = '';
    	if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
    		symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
    	}
    	else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
    		if (!checkScalarValue(codePoint, strict)) {
    			codePoint = 0xFFFD;
    		}
    		symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
    		symbol += createByte(codePoint, 6);
    	}
    	else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
    		symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
    		symbol += createByte(codePoint, 12);
    		symbol += createByte(codePoint, 6);
    	}
    	symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
    	return symbol;
    }

    function utf8encode(string, opts) {
    	opts = opts || {};
    	var strict = false !== opts.strict;

    	var codePoints = ucs2decode(string);
    	var length = codePoints.length;
    	var index = -1;
    	var codePoint;
    	var byteString = '';
    	while (++index < length) {
    		codePoint = codePoints[index];
    		byteString += encodeCodePoint(codePoint, strict);
    	}
    	return byteString;
    }

    /*--------------------------------------------------------------------------*/

    function readContinuationByte() {
    	if (byteIndex >= byteCount) {
    		throw Error('Invalid byte index');
    	}

    	var continuationByte = byteArray[byteIndex] & 0xFF;
    	byteIndex++;

    	if ((continuationByte & 0xC0) == 0x80) {
    		return continuationByte & 0x3F;
    	}

    	// If we end up here, it’s not a continuation byte
    	throw Error('Invalid continuation byte');
    }

    function decodeSymbol(strict) {
    	var byte1;
    	var byte2;
    	var byte3;
    	var byte4;
    	var codePoint;

    	if (byteIndex > byteCount) {
    		throw Error('Invalid byte index');
    	}

    	if (byteIndex == byteCount) {
    		return false;
    	}

    	// Read first byte
    	byte1 = byteArray[byteIndex] & 0xFF;
    	byteIndex++;

    	// 1-byte sequence (no continuation bytes)
    	if ((byte1 & 0x80) == 0) {
    		return byte1;
    	}

    	// 2-byte sequence
    	if ((byte1 & 0xE0) == 0xC0) {
    		byte2 = readContinuationByte();
    		codePoint = ((byte1 & 0x1F) << 6) | byte2;
    		if (codePoint >= 0x80) {
    			return codePoint;
    		} else {
    			throw Error('Invalid continuation byte');
    		}
    	}

    	// 3-byte sequence (may include unpaired surrogates)
    	if ((byte1 & 0xF0) == 0xE0) {
    		byte2 = readContinuationByte();
    		byte3 = readContinuationByte();
    		codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
    		if (codePoint >= 0x0800) {
    			return checkScalarValue(codePoint, strict) ? codePoint : 0xFFFD;
    		} else {
    			throw Error('Invalid continuation byte');
    		}
    	}

    	// 4-byte sequence
    	if ((byte1 & 0xF8) == 0xF0) {
    		byte2 = readContinuationByte();
    		byte3 = readContinuationByte();
    		byte4 = readContinuationByte();
    		codePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |
    			(byte3 << 0x06) | byte4;
    		if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
    			return codePoint;
    		}
    	}

    	throw Error('Invalid UTF-8 detected');
    }

    var byteArray;
    var byteCount;
    var byteIndex;
    function utf8decode(byteString, opts) {
    	opts = opts || {};
    	var strict = false !== opts.strict;

    	byteArray = ucs2decode(byteString);
    	byteCount = byteArray.length;
    	byteIndex = 0;
    	var codePoints = [];
    	var tmp;
    	while ((tmp = decodeSymbol(strict)) !== false) {
    		codePoints.push(tmp);
    	}
    	return ucs2encode(codePoints);
    }

    var utf8 = {
    	version: '2.1.2',
    	encode: utf8encode,
    	decode: utf8decode
    };

    var base64Arraybuffer = {};

    /*
     * base64-arraybuffer
     * https://github.com/niklasvh/base64-arraybuffer
     *
     * Copyright (c) 2012 Niklas von Hertzen
     * Licensed under the MIT license.
     */
    (function(chars){

      base64Arraybuffer.encode = function(arraybuffer) {
        var bytes = new Uint8Array(arraybuffer),
        i, len = bytes.length, base64 = "";

        for (i = 0; i < len; i+=3) {
          base64 += chars[bytes[i] >> 2];
          base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
          base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
          base64 += chars[bytes[i + 2] & 63];
        }

        if ((len % 3) === 2) {
          base64 = base64.substring(0, base64.length - 1) + "=";
        } else if (len % 3 === 1) {
          base64 = base64.substring(0, base64.length - 2) + "==";
        }

        return base64;
      };

      base64Arraybuffer.decode =  function(base64) {
        var bufferLength = base64.length * 0.75,
        len = base64.length, i, p = 0,
        encoded1, encoded2, encoded3, encoded4;

        if (base64[base64.length - 1] === "=") {
          bufferLength--;
          if (base64[base64.length - 2] === "=") {
            bufferLength--;
          }
        }

        var arraybuffer = new ArrayBuffer(bufferLength),
        bytes = new Uint8Array(arraybuffer);

        for (i = 0; i < len; i+=4) {
          encoded1 = chars.indexOf(base64[i]);
          encoded2 = chars.indexOf(base64[i+1]);
          encoded3 = chars.indexOf(base64[i+2]);
          encoded4 = chars.indexOf(base64[i+3]);

          bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
          bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
          bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
        }

        return arraybuffer;
      };
    })("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");

    /**
     * Create a blob builder even when vendor prefixes exist
     */

    var BlobBuilder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :
      typeof WebKitBlobBuilder !== 'undefined' ? WebKitBlobBuilder :
      typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :
      typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : 
      false;

    /**
     * Check if Blob constructor is supported
     */

    var blobSupported = (function() {
      try {
        var a = new Blob(['hi']);
        return a.size === 2;
      } catch(e) {
        return false;
      }
    })();

    /**
     * Check if Blob constructor supports ArrayBufferViews
     * Fails in Safari 6, so we need to map to ArrayBuffers there.
     */

    var blobSupportsArrayBufferView = blobSupported && (function() {
      try {
        var b = new Blob([new Uint8Array([1,2])]);
        return b.size === 2;
      } catch(e) {
        return false;
      }
    })();

    /**
     * Check if BlobBuilder is supported
     */

    var blobBuilderSupported = BlobBuilder
      && BlobBuilder.prototype.append
      && BlobBuilder.prototype.getBlob;

    /**
     * Helper function that maps ArrayBufferViews to ArrayBuffers
     * Used by BlobBuilder constructor and old browsers that didn't
     * support it in the Blob constructor.
     */

    function mapArrayBufferViews(ary) {
      return ary.map(function(chunk) {
        if (chunk.buffer instanceof ArrayBuffer) {
          var buf = chunk.buffer;

          // if this is a subarray, make a copy so we only
          // include the subarray region from the underlying buffer
          if (chunk.byteLength !== buf.byteLength) {
            var copy = new Uint8Array(chunk.byteLength);
            copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
            buf = copy.buffer;
          }

          return buf;
        }

        return chunk;
      });
    }

    function BlobBuilderConstructor(ary, options) {
      options = options || {};

      var bb = new BlobBuilder();
      mapArrayBufferViews(ary).forEach(function(part) {
        bb.append(part);
      });

      return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
    }
    function BlobConstructor(ary, options) {
      return new Blob(mapArrayBufferViews(ary), options || {});
    }
    if (typeof Blob !== 'undefined') {
      BlobBuilderConstructor.prototype = Blob.prototype;
      BlobConstructor.prototype = Blob.prototype;
    }

    var blob = (function() {
      if (blobSupported) {
        return blobSupportsArrayBufferView ? Blob : BlobConstructor;
      } else if (blobBuilderSupported) {
        return BlobBuilderConstructor;
      } else {
        return undefined;
      }
    })();

    /**
     * Module dependencies.
     */

    (function (exports) {
    var keys = keys$1;
    var hasBinary = hasBinary2;
    var sliceBuffer = arraybuffer_slice;
    var after = after_1;
    var utf8$1 = utf8;

    var base64encoder;
    if (typeof ArrayBuffer !== 'undefined') {
      base64encoder = base64Arraybuffer;
    }

    /**
     * Check if we are running an android browser. That requires us to use
     * ArrayBuffer with polling transports...
     *
     * http://ghinda.net/jpeg-blob-ajax-android/
     */

    var isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);

    /**
     * Check if we are running in PhantomJS.
     * Uploading a Blob with PhantomJS does not work correctly, as reported here:
     * https://github.com/ariya/phantomjs/issues/11395
     * @type boolean
     */
    var isPhantomJS = typeof navigator !== 'undefined' && /PhantomJS/i.test(navigator.userAgent);

    /**
     * When true, avoids using Blobs to encode payloads.
     * @type boolean
     */
    var dontSendBlobs = isAndroid || isPhantomJS;

    /**
     * Current protocol version.
     */

    exports.protocol = 3;

    /**
     * Packet types.
     */

    var packets = exports.packets = {
        open:     0    // non-ws
      , close:    1    // non-ws
      , ping:     2
      , pong:     3
      , message:  4
      , upgrade:  5
      , noop:     6
    };

    var packetslist = keys(packets);

    /**
     * Premade error packet.
     */

    var err = { type: 'error', data: 'parser error' };

    /**
     * Create a blob api even for blob builder when vendor prefixes exist
     */

    var Blob = blob;

    /**
     * Encodes a packet.
     *
     *     <packet type id> [ <data> ]
     *
     * Example:
     *
     *     5hello world
     *     3
     *     4
     *
     * Binary is encoded in an identical principle
     *
     * @api private
     */

    exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
      if (typeof supportsBinary === 'function') {
        callback = supportsBinary;
        supportsBinary = false;
      }

      if (typeof utf8encode === 'function') {
        callback = utf8encode;
        utf8encode = null;
      }

      var data = (packet.data === undefined)
        ? undefined
        : packet.data.buffer || packet.data;

      if (typeof ArrayBuffer !== 'undefined' && data instanceof ArrayBuffer) {
        return encodeArrayBuffer(packet, supportsBinary, callback);
      } else if (typeof Blob !== 'undefined' && data instanceof Blob) {
        return encodeBlob(packet, supportsBinary, callback);
      }

      // might be an object with { base64: true, data: dataAsBase64String }
      if (data && data.base64) {
        return encodeBase64Object(packet, callback);
      }

      // Sending data as a utf-8 string
      var encoded = packets[packet.type];

      // data fragment is optional
      if (undefined !== packet.data) {
        encoded += utf8encode ? utf8$1.encode(String(packet.data), { strict: false }) : String(packet.data);
      }

      return callback('' + encoded);

    };

    function encodeBase64Object(packet, callback) {
      // packet data is an object { base64: true, data: dataAsBase64String }
      var message = 'b' + exports.packets[packet.type] + packet.data.data;
      return callback(message);
    }

    /**
     * Encode packet helpers for binary types
     */

    function encodeArrayBuffer(packet, supportsBinary, callback) {
      if (!supportsBinary) {
        return exports.encodeBase64Packet(packet, callback);
      }

      var data = packet.data;
      var contentArray = new Uint8Array(data);
      var resultBuffer = new Uint8Array(1 + data.byteLength);

      resultBuffer[0] = packets[packet.type];
      for (var i = 0; i < contentArray.length; i++) {
        resultBuffer[i+1] = contentArray[i];
      }

      return callback(resultBuffer.buffer);
    }

    function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
      if (!supportsBinary) {
        return exports.encodeBase64Packet(packet, callback);
      }

      var fr = new FileReader();
      fr.onload = function() {
        exports.encodePacket({ type: packet.type, data: fr.result }, supportsBinary, true, callback);
      };
      return fr.readAsArrayBuffer(packet.data);
    }

    function encodeBlob(packet, supportsBinary, callback) {
      if (!supportsBinary) {
        return exports.encodeBase64Packet(packet, callback);
      }

      if (dontSendBlobs) {
        return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
      }

      var length = new Uint8Array(1);
      length[0] = packets[packet.type];
      var blob = new Blob([length.buffer, packet.data]);

      return callback(blob);
    }

    /**
     * Encodes a packet with binary data in a base64 string
     *
     * @param {Object} packet, has `type` and `data`
     * @return {String} base64 encoded message
     */

    exports.encodeBase64Packet = function(packet, callback) {
      var message = 'b' + exports.packets[packet.type];
      if (typeof Blob !== 'undefined' && packet.data instanceof Blob) {
        var fr = new FileReader();
        fr.onload = function() {
          var b64 = fr.result.split(',')[1];
          callback(message + b64);
        };
        return fr.readAsDataURL(packet.data);
      }

      var b64data;
      try {
        b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
      } catch (e) {
        // iPhone Safari doesn't let you apply with typed arrays
        var typed = new Uint8Array(packet.data);
        var basic = new Array(typed.length);
        for (var i = 0; i < typed.length; i++) {
          basic[i] = typed[i];
        }
        b64data = String.fromCharCode.apply(null, basic);
      }
      message += btoa(b64data);
      return callback(message);
    };

    /**
     * Decodes a packet. Changes format to Blob if requested.
     *
     * @return {Object} with `type` and `data` (if any)
     * @api private
     */

    exports.decodePacket = function (data, binaryType, utf8decode) {
      if (data === undefined) {
        return err;
      }
      // String data
      if (typeof data === 'string') {
        if (data.charAt(0) === 'b') {
          return exports.decodeBase64Packet(data.substr(1), binaryType);
        }

        if (utf8decode) {
          data = tryDecode(data);
          if (data === false) {
            return err;
          }
        }
        var type = data.charAt(0);

        if (Number(type) != type || !packetslist[type]) {
          return err;
        }

        if (data.length > 1) {
          return { type: packetslist[type], data: data.substring(1) };
        } else {
          return { type: packetslist[type] };
        }
      }

      var asArray = new Uint8Array(data);
      var type = asArray[0];
      var rest = sliceBuffer(data, 1);
      if (Blob && binaryType === 'blob') {
        rest = new Blob([rest]);
      }
      return { type: packetslist[type], data: rest };
    };

    function tryDecode(data) {
      try {
        data = utf8$1.decode(data, { strict: false });
      } catch (e) {
        return false;
      }
      return data;
    }

    /**
     * Decodes a packet encoded in a base64 string
     *
     * @param {String} base64 encoded message
     * @return {Object} with `type` and `data` (if any)
     */

    exports.decodeBase64Packet = function(msg, binaryType) {
      var type = packetslist[msg.charAt(0)];
      if (!base64encoder) {
        return { type: type, data: { base64: true, data: msg.substr(1) } };
      }

      var data = base64encoder.decode(msg.substr(1));

      if (binaryType === 'blob' && Blob) {
        data = new Blob([data]);
      }

      return { type: type, data: data };
    };

    /**
     * Encodes multiple messages (payload).
     *
     *     <length>:data
     *
     * Example:
     *
     *     11:hello world2:hi
     *
     * If any contents are binary, they will be encoded as base64 strings. Base64
     * encoded strings are marked with a b before the length specifier
     *
     * @param {Array} packets
     * @api private
     */

    exports.encodePayload = function (packets, supportsBinary, callback) {
      if (typeof supportsBinary === 'function') {
        callback = supportsBinary;
        supportsBinary = null;
      }

      var isBinary = hasBinary(packets);

      if (supportsBinary && isBinary) {
        if (Blob && !dontSendBlobs) {
          return exports.encodePayloadAsBlob(packets, callback);
        }

        return exports.encodePayloadAsArrayBuffer(packets, callback);
      }

      if (!packets.length) {
        return callback('0:');
      }

      function setLengthHeader(message) {
        return message.length + ':' + message;
      }

      function encodeOne(packet, doneCallback) {
        exports.encodePacket(packet, !isBinary ? false : supportsBinary, false, function(message) {
          doneCallback(null, setLengthHeader(message));
        });
      }

      map(packets, encodeOne, function(err, results) {
        return callback(results.join(''));
      });
    };

    /**
     * Async array map using after
     */

    function map(ary, each, done) {
      var result = new Array(ary.length);
      var next = after(ary.length, done);

      var eachWithIndex = function(i, el, cb) {
        each(el, function(error, msg) {
          result[i] = msg;
          cb(error, result);
        });
      };

      for (var i = 0; i < ary.length; i++) {
        eachWithIndex(i, ary[i], next);
      }
    }

    /*
     * Decodes data when a payload is maybe expected. Possible binary contents are
     * decoded from their base64 representation
     *
     * @param {String} data, callback method
     * @api public
     */

    exports.decodePayload = function (data, binaryType, callback) {
      if (typeof data !== 'string') {
        return exports.decodePayloadAsBinary(data, binaryType, callback);
      }

      if (typeof binaryType === 'function') {
        callback = binaryType;
        binaryType = null;
      }

      var packet;
      if (data === '') {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      var length = '', n, msg;

      for (var i = 0, l = data.length; i < l; i++) {
        var chr = data.charAt(i);

        if (chr !== ':') {
          length += chr;
          continue;
        }

        if (length === '' || (length != (n = Number(length)))) {
          // parser error - ignoring payload
          return callback(err, 0, 1);
        }

        msg = data.substr(i + 1, n);

        if (length != msg.length) {
          // parser error - ignoring payload
          return callback(err, 0, 1);
        }

        if (msg.length) {
          packet = exports.decodePacket(msg, binaryType, false);

          if (err.type === packet.type && err.data === packet.data) {
            // parser error in individual packet - ignoring payload
            return callback(err, 0, 1);
          }

          var ret = callback(packet, i + n, l);
          if (false === ret) return;
        }

        // advance cursor
        i += n;
        length = '';
      }

      if (length !== '') {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

    };

    /**
     * Encodes multiple messages (payload) as binary.
     *
     * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
     * 255><data>
     *
     * Example:
     * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
     *
     * @param {Array} packets
     * @return {ArrayBuffer} encoded payload
     * @api private
     */

    exports.encodePayloadAsArrayBuffer = function(packets, callback) {
      if (!packets.length) {
        return callback(new ArrayBuffer(0));
      }

      function encodeOne(packet, doneCallback) {
        exports.encodePacket(packet, true, true, function(data) {
          return doneCallback(null, data);
        });
      }

      map(packets, encodeOne, function(err, encodedPackets) {
        var totalLength = encodedPackets.reduce(function(acc, p) {
          var len;
          if (typeof p === 'string'){
            len = p.length;
          } else {
            len = p.byteLength;
          }
          return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
        }, 0);

        var resultArray = new Uint8Array(totalLength);

        var bufferIndex = 0;
        encodedPackets.forEach(function(p) {
          var isString = typeof p === 'string';
          var ab = p;
          if (isString) {
            var view = new Uint8Array(p.length);
            for (var i = 0; i < p.length; i++) {
              view[i] = p.charCodeAt(i);
            }
            ab = view.buffer;
          }

          if (isString) { // not true binary
            resultArray[bufferIndex++] = 0;
          } else { // true binary
            resultArray[bufferIndex++] = 1;
          }

          var lenStr = ab.byteLength.toString();
          for (var i = 0; i < lenStr.length; i++) {
            resultArray[bufferIndex++] = parseInt(lenStr[i]);
          }
          resultArray[bufferIndex++] = 255;

          var view = new Uint8Array(ab);
          for (var i = 0; i < view.length; i++) {
            resultArray[bufferIndex++] = view[i];
          }
        });

        return callback(resultArray.buffer);
      });
    };

    /**
     * Encode as Blob
     */

    exports.encodePayloadAsBlob = function(packets, callback) {
      function encodeOne(packet, doneCallback) {
        exports.encodePacket(packet, true, true, function(encoded) {
          var binaryIdentifier = new Uint8Array(1);
          binaryIdentifier[0] = 1;
          if (typeof encoded === 'string') {
            var view = new Uint8Array(encoded.length);
            for (var i = 0; i < encoded.length; i++) {
              view[i] = encoded.charCodeAt(i);
            }
            encoded = view.buffer;
            binaryIdentifier[0] = 0;
          }

          var len = (encoded instanceof ArrayBuffer)
            ? encoded.byteLength
            : encoded.size;

          var lenStr = len.toString();
          var lengthAry = new Uint8Array(lenStr.length + 1);
          for (var i = 0; i < lenStr.length; i++) {
            lengthAry[i] = parseInt(lenStr[i]);
          }
          lengthAry[lenStr.length] = 255;

          if (Blob) {
            var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
            doneCallback(null, blob);
          }
        });
      }

      map(packets, encodeOne, function(err, results) {
        return callback(new Blob(results));
      });
    };

    /*
     * Decodes data when a payload is maybe expected. Strings are decoded by
     * interpreting each byte as a key code for entries marked to start with 0. See
     * description of encodePayloadAsBinary
     *
     * @param {ArrayBuffer} data, callback method
     * @api public
     */

    exports.decodePayloadAsBinary = function (data, binaryType, callback) {
      if (typeof binaryType === 'function') {
        callback = binaryType;
        binaryType = null;
      }

      var bufferTail = data;
      var buffers = [];

      while (bufferTail.byteLength > 0) {
        var tailArray = new Uint8Array(bufferTail);
        var isString = tailArray[0] === 0;
        var msgLength = '';

        for (var i = 1; ; i++) {
          if (tailArray[i] === 255) break;

          // 310 = char length of Number.MAX_VALUE
          if (msgLength.length > 310) {
            return callback(err, 0, 1);
          }

          msgLength += tailArray[i];
        }

        bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
        msgLength = parseInt(msgLength);

        var msg = sliceBuffer(bufferTail, 0, msgLength);
        if (isString) {
          try {
            msg = String.fromCharCode.apply(null, new Uint8Array(msg));
          } catch (e) {
            // iPhone Safari doesn't let you apply to typed arrays
            var typed = new Uint8Array(msg);
            msg = '';
            for (var i = 0; i < typed.length; i++) {
              msg += String.fromCharCode(typed[i]);
            }
          }
        }

        buffers.push(msg);
        bufferTail = sliceBuffer(bufferTail, msgLength);
      }

      var total = buffers.length;
      buffers.forEach(function(buffer, i) {
        callback(exports.decodePacket(buffer, binaryType, true), i, total);
      });
    };
    }(browser));

    /**
     * Module dependencies.
     */

    var parser$4 = browser;
    var Emitter$3 = componentEmitter.exports;

    /**
     * Module exports.
     */

    var transport = Transport$2;

    /**
     * Transport abstract constructor.
     *
     * @param {Object} options.
     * @api private
     */

    function Transport$2 (opts) {
      this.path = opts.path;
      this.hostname = opts.hostname;
      this.port = opts.port;
      this.secure = opts.secure;
      this.query = opts.query;
      this.timestampParam = opts.timestampParam;
      this.timestampRequests = opts.timestampRequests;
      this.readyState = '';
      this.agent = opts.agent || false;
      this.socket = opts.socket;
      this.enablesXDR = opts.enablesXDR;
      this.withCredentials = opts.withCredentials;

      // SSL options for Node.js client
      this.pfx = opts.pfx;
      this.key = opts.key;
      this.passphrase = opts.passphrase;
      this.cert = opts.cert;
      this.ca = opts.ca;
      this.ciphers = opts.ciphers;
      this.rejectUnauthorized = opts.rejectUnauthorized;
      this.forceNode = opts.forceNode;

      // results of ReactNative environment detection
      this.isReactNative = opts.isReactNative;

      // other options for Node.js client
      this.extraHeaders = opts.extraHeaders;
      this.localAddress = opts.localAddress;
    }

    /**
     * Mix in `Emitter`.
     */

    Emitter$3(Transport$2.prototype);

    /**
     * Emits an error.
     *
     * @param {String} str
     * @return {Transport} for chaining
     * @api public
     */

    Transport$2.prototype.onError = function (msg, desc) {
      var err = new Error(msg);
      err.type = 'TransportError';
      err.description = desc;
      this.emit('error', err);
      return this;
    };

    /**
     * Opens the transport.
     *
     * @api public
     */

    Transport$2.prototype.open = function () {
      if ('closed' === this.readyState || '' === this.readyState) {
        this.readyState = 'opening';
        this.doOpen();
      }

      return this;
    };

    /**
     * Closes the transport.
     *
     * @api private
     */

    Transport$2.prototype.close = function () {
      if ('opening' === this.readyState || 'open' === this.readyState) {
        this.doClose();
        this.onClose();
      }

      return this;
    };

    /**
     * Sends multiple packets.
     *
     * @param {Array} packets
     * @api private
     */

    Transport$2.prototype.send = function (packets) {
      if ('open' === this.readyState) {
        this.write(packets);
      } else {
        throw new Error('Transport not open');
      }
    };

    /**
     * Called upon open
     *
     * @api private
     */

    Transport$2.prototype.onOpen = function () {
      this.readyState = 'open';
      this.writable = true;
      this.emit('open');
    };

    /**
     * Called with data.
     *
     * @param {String} data
     * @api private
     */

    Transport$2.prototype.onData = function (data) {
      var packet = parser$4.decodePacket(data, this.socket.binaryType);
      this.onPacket(packet);
    };

    /**
     * Called with a decoded packet.
     */

    Transport$2.prototype.onPacket = function (packet) {
      this.emit('packet', packet);
    };

    /**
     * Called upon close.
     *
     * @api private
     */

    Transport$2.prototype.onClose = function () {
      this.readyState = 'closed';
      this.emit('close');
    };

    var parseqs$3 = {};

    /**
     * Compiles a querystring
     * Returns string representation of the object
     *
     * @param {Object}
     * @api private
     */

    parseqs$3.encode = function (obj) {
      var str = '';

      for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
          if (str.length) str += '&';
          str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
        }
      }

      return str;
    };

    /**
     * Parses a simple querystring into an object
     *
     * @param {String} qs
     * @api private
     */

    parseqs$3.decode = function(qs){
      var qry = {};
      var pairs = qs.split('&');
      for (var i = 0, l = pairs.length; i < l; i++) {
        var pair = pairs[i].split('=');
        qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
      }
      return qry;
    };

    var componentInherit = function(a, b){
      var fn = function(){};
      fn.prototype = b.prototype;
      a.prototype = new fn;
      a.prototype.constructor = a;
    };

    var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
      , length = 64
      , map$1 = {}
      , seed = 0
      , i$1 = 0
      , prev;

    /**
     * Return a string representing the specified number.
     *
     * @param {Number} num The number to convert.
     * @returns {String} The string representation of the number.
     * @api public
     */
    function encode(num) {
      var encoded = '';

      do {
        encoded = alphabet[num % length] + encoded;
        num = Math.floor(num / length);
      } while (num > 0);

      return encoded;
    }

    /**
     * Return the integer value specified by the given string.
     *
     * @param {String} str The string to convert.
     * @returns {Number} The integer value represented by the string.
     * @api public
     */
    function decode(str) {
      var decoded = 0;

      for (i$1 = 0; i$1 < str.length; i$1++) {
        decoded = decoded * length + map$1[str.charAt(i$1)];
      }

      return decoded;
    }

    /**
     * Yeast: A tiny growing id generator.
     *
     * @returns {String} A unique id.
     * @api public
     */
    function yeast$2() {
      var now = encode(+new Date());

      if (now !== prev) return seed = 0, prev = now;
      return now +'.'+ encode(seed++);
    }

    //
    // Map each character to its index.
    //
    for (; i$1 < length; i$1++) map$1[alphabet[i$1]] = i$1;

    //
    // Expose the `yeast`, `encode` and `decode` functions.
    //
    yeast$2.encode = encode;
    yeast$2.decode = decode;
    var yeast_1 = yeast$2;

    /**
     * Module dependencies.
     */

    var Transport$1 = transport;
    var parseqs$2 = parseqs$3;
    var parser$3 = browser;
    var inherit$5 = componentInherit;
    var yeast$1 = yeast_1;
    var debug$4 = browser$1.exports('engine.io-client:polling');

    /**
     * Module exports.
     */

    var polling$1 = Polling$2;

    /**
     * Is XHR2 supported?
     */

    var hasXHR2 = (function () {
      var XMLHttpRequest = xmlhttprequest;
      var xhr = new XMLHttpRequest({ xdomain: false });
      return null != xhr.responseType;
    })();

    /**
     * Polling interface.
     *
     * @param {Object} opts
     * @api private
     */

    function Polling$2 (opts) {
      var forceBase64 = (opts && opts.forceBase64);
      if (!hasXHR2 || forceBase64) {
        this.supportsBinary = false;
      }
      Transport$1.call(this, opts);
    }

    /**
     * Inherits from Transport.
     */

    inherit$5(Polling$2, Transport$1);

    /**
     * Transport name.
     */

    Polling$2.prototype.name = 'polling';

    /**
     * Opens the socket (triggers polling). We write a PING message to determine
     * when the transport is open.
     *
     * @api private
     */

    Polling$2.prototype.doOpen = function () {
      this.poll();
    };

    /**
     * Pauses polling.
     *
     * @param {Function} callback upon buffers are flushed and transport is paused
     * @api private
     */

    Polling$2.prototype.pause = function (onPause) {
      var self = this;

      this.readyState = 'pausing';

      function pause () {
        debug$4('paused');
        self.readyState = 'paused';
        onPause();
      }

      if (this.polling || !this.writable) {
        var total = 0;

        if (this.polling) {
          debug$4('we are currently polling - waiting to pause');
          total++;
          this.once('pollComplete', function () {
            debug$4('pre-pause polling complete');
            --total || pause();
          });
        }

        if (!this.writable) {
          debug$4('we are currently writing - waiting to pause');
          total++;
          this.once('drain', function () {
            debug$4('pre-pause writing complete');
            --total || pause();
          });
        }
      } else {
        pause();
      }
    };

    /**
     * Starts polling cycle.
     *
     * @api public
     */

    Polling$2.prototype.poll = function () {
      debug$4('polling');
      this.polling = true;
      this.doPoll();
      this.emit('poll');
    };

    /**
     * Overloads onData to detect payloads.
     *
     * @api private
     */

    Polling$2.prototype.onData = function (data) {
      var self = this;
      debug$4('polling got data %s', data);
      var callback = function (packet, index, total) {
        // if its the first message we consider the transport open
        if ('opening' === self.readyState && packet.type === 'open') {
          self.onOpen();
        }

        // if its a close packet, we close the ongoing requests
        if ('close' === packet.type) {
          self.onClose();
          return false;
        }

        // otherwise bypass onData and handle the message
        self.onPacket(packet);
      };

      // decode payload
      parser$3.decodePayload(data, this.socket.binaryType, callback);

      // if an event did not trigger closing
      if ('closed' !== this.readyState) {
        // if we got data we're not polling
        this.polling = false;
        this.emit('pollComplete');

        if ('open' === this.readyState) {
          this.poll();
        } else {
          debug$4('ignoring poll - transport state "%s"', this.readyState);
        }
      }
    };

    /**
     * For polling, send a close packet.
     *
     * @api private
     */

    Polling$2.prototype.doClose = function () {
      var self = this;

      function close () {
        debug$4('writing close packet');
        self.write([{ type: 'close' }]);
      }

      if ('open' === this.readyState) {
        debug$4('transport open - closing');
        close();
      } else {
        // in case we're trying to close while
        // handshaking is in progress (GH-164)
        debug$4('transport not open - deferring close');
        this.once('open', close);
      }
    };

    /**
     * Writes a packets payload.
     *
     * @param {Array} data packets
     * @param {Function} drain callback
     * @api private
     */

    Polling$2.prototype.write = function (packets) {
      var self = this;
      this.writable = false;
      var callbackfn = function () {
        self.writable = true;
        self.emit('drain');
      };

      parser$3.encodePayload(packets, this.supportsBinary, function (data) {
        self.doWrite(data, callbackfn);
      });
    };

    /**
     * Generates uri for connection.
     *
     * @api private
     */

    Polling$2.prototype.uri = function () {
      var query = this.query || {};
      var schema = this.secure ? 'https' : 'http';
      var port = '';

      // cache busting is forced
      if (false !== this.timestampRequests) {
        query[this.timestampParam] = yeast$1();
      }

      if (!this.supportsBinary && !query.sid) {
        query.b64 = 1;
      }

      query = parseqs$2.encode(query);

      // avoid port if default for schema
      if (this.port && (('https' === schema && Number(this.port) !== 443) ||
         ('http' === schema && Number(this.port) !== 80))) {
        port = ':' + this.port;
      }

      // prepend ? to query
      if (query.length) {
        query = '?' + query;
      }

      var ipv6 = this.hostname.indexOf(':') !== -1;
      return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
    };

    /* global attachEvent */

    /**
     * Module requirements.
     */

    var XMLHttpRequest$2 = xmlhttprequest;
    var Polling$1 = polling$1;
    var Emitter$2 = componentEmitter.exports;
    var inherit$4 = componentInherit;
    var debug$3 = browser$1.exports('engine.io-client:polling-xhr');
    var globalThis$2 = globalThis_browser;

    /**
     * Module exports.
     */

    pollingXhr.exports = XHR$1;
    pollingXhr.exports.Request = Request;

    /**
     * Empty function
     */

    function empty$1 () {}

    /**
     * XHR Polling constructor.
     *
     * @param {Object} opts
     * @api public
     */

    function XHR$1 (opts) {
      Polling$1.call(this, opts);
      this.requestTimeout = opts.requestTimeout;
      this.extraHeaders = opts.extraHeaders;

      if (typeof location !== 'undefined') {
        var isSSL = 'https:' === location.protocol;
        var port = location.port;

        // some user agents have empty `location.port`
        if (!port) {
          port = isSSL ? 443 : 80;
        }

        this.xd = (typeof location !== 'undefined' && opts.hostname !== location.hostname) ||
          port !== opts.port;
        this.xs = opts.secure !== isSSL;
      }
    }

    /**
     * Inherits from Polling.
     */

    inherit$4(XHR$1, Polling$1);

    /**
     * XHR supports binary
     */

    XHR$1.prototype.supportsBinary = true;

    /**
     * Creates a request.
     *
     * @param {String} method
     * @api private
     */

    XHR$1.prototype.request = function (opts) {
      opts = opts || {};
      opts.uri = this.uri();
      opts.xd = this.xd;
      opts.xs = this.xs;
      opts.agent = this.agent || false;
      opts.supportsBinary = this.supportsBinary;
      opts.enablesXDR = this.enablesXDR;
      opts.withCredentials = this.withCredentials;

      // SSL options for Node.js client
      opts.pfx = this.pfx;
      opts.key = this.key;
      opts.passphrase = this.passphrase;
      opts.cert = this.cert;
      opts.ca = this.ca;
      opts.ciphers = this.ciphers;
      opts.rejectUnauthorized = this.rejectUnauthorized;
      opts.requestTimeout = this.requestTimeout;

      // other options for Node.js client
      opts.extraHeaders = this.extraHeaders;

      return new Request(opts);
    };

    /**
     * Sends data.
     *
     * @param {String} data to send.
     * @param {Function} called upon flush.
     * @api private
     */

    XHR$1.prototype.doWrite = function (data, fn) {
      var isBinary = typeof data !== 'string' && data !== undefined;
      var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
      var self = this;
      req.on('success', fn);
      req.on('error', function (err) {
        self.onError('xhr post error', err);
      });
      this.sendXhr = req;
    };

    /**
     * Starts a poll cycle.
     *
     * @api private
     */

    XHR$1.prototype.doPoll = function () {
      debug$3('xhr poll');
      var req = this.request();
      var self = this;
      req.on('data', function (data) {
        self.onData(data);
      });
      req.on('error', function (err) {
        self.onError('xhr poll error', err);
      });
      this.pollXhr = req;
    };

    /**
     * Request constructor
     *
     * @param {Object} options
     * @api public
     */

    function Request (opts) {
      this.method = opts.method || 'GET';
      this.uri = opts.uri;
      this.xd = !!opts.xd;
      this.xs = !!opts.xs;
      this.async = false !== opts.async;
      this.data = undefined !== opts.data ? opts.data : null;
      this.agent = opts.agent;
      this.isBinary = opts.isBinary;
      this.supportsBinary = opts.supportsBinary;
      this.enablesXDR = opts.enablesXDR;
      this.withCredentials = opts.withCredentials;
      this.requestTimeout = opts.requestTimeout;

      // SSL options for Node.js client
      this.pfx = opts.pfx;
      this.key = opts.key;
      this.passphrase = opts.passphrase;
      this.cert = opts.cert;
      this.ca = opts.ca;
      this.ciphers = opts.ciphers;
      this.rejectUnauthorized = opts.rejectUnauthorized;

      // other options for Node.js client
      this.extraHeaders = opts.extraHeaders;

      this.create();
    }

    /**
     * Mix in `Emitter`.
     */

    Emitter$2(Request.prototype);

    /**
     * Creates the XHR object and sends the request.
     *
     * @api private
     */

    Request.prototype.create = function () {
      var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

      // SSL options for Node.js client
      opts.pfx = this.pfx;
      opts.key = this.key;
      opts.passphrase = this.passphrase;
      opts.cert = this.cert;
      opts.ca = this.ca;
      opts.ciphers = this.ciphers;
      opts.rejectUnauthorized = this.rejectUnauthorized;

      var xhr = this.xhr = new XMLHttpRequest$2(opts);
      var self = this;

      try {
        debug$3('xhr open %s: %s', this.method, this.uri);
        xhr.open(this.method, this.uri, this.async);
        try {
          if (this.extraHeaders) {
            xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
            for (var i in this.extraHeaders) {
              if (this.extraHeaders.hasOwnProperty(i)) {
                xhr.setRequestHeader(i, this.extraHeaders[i]);
              }
            }
          }
        } catch (e) {}

        if ('POST' === this.method) {
          try {
            if (this.isBinary) {
              xhr.setRequestHeader('Content-type', 'application/octet-stream');
            } else {
              xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
            }
          } catch (e) {}
        }

        try {
          xhr.setRequestHeader('Accept', '*/*');
        } catch (e) {}

        // ie6 check
        if ('withCredentials' in xhr) {
          xhr.withCredentials = this.withCredentials;
        }

        if (this.requestTimeout) {
          xhr.timeout = this.requestTimeout;
        }

        if (this.hasXDR()) {
          xhr.onload = function () {
            self.onLoad();
          };
          xhr.onerror = function () {
            self.onError(xhr.responseText);
          };
        } else {
          xhr.onreadystatechange = function () {
            if (xhr.readyState === 2) {
              try {
                var contentType = xhr.getResponseHeader('Content-Type');
                if (self.supportsBinary && contentType === 'application/octet-stream' || contentType === 'application/octet-stream; charset=UTF-8') {
                  xhr.responseType = 'arraybuffer';
                }
              } catch (e) {}
            }
            if (4 !== xhr.readyState) return;
            if (200 === xhr.status || 1223 === xhr.status) {
              self.onLoad();
            } else {
              // make sure the `error` event handler that's user-set
              // does not throw in the same tick and gets caught here
              setTimeout(function () {
                self.onError(typeof xhr.status === 'number' ? xhr.status : 0);
              }, 0);
            }
          };
        }

        debug$3('xhr data %s', this.data);
        xhr.send(this.data);
      } catch (e) {
        // Need to defer since .create() is called directly fhrom the constructor
        // and thus the 'error' event can only be only bound *after* this exception
        // occurs.  Therefore, also, we cannot throw here at all.
        setTimeout(function () {
          self.onError(e);
        }, 0);
        return;
      }

      if (typeof document !== 'undefined') {
        this.index = Request.requestsCount++;
        Request.requests[this.index] = this;
      }
    };

    /**
     * Called upon successful response.
     *
     * @api private
     */

    Request.prototype.onSuccess = function () {
      this.emit('success');
      this.cleanup();
    };

    /**
     * Called if we have data.
     *
     * @api private
     */

    Request.prototype.onData = function (data) {
      this.emit('data', data);
      this.onSuccess();
    };

    /**
     * Called upon error.
     *
     * @api private
     */

    Request.prototype.onError = function (err) {
      this.emit('error', err);
      this.cleanup(true);
    };

    /**
     * Cleans up house.
     *
     * @api private
     */

    Request.prototype.cleanup = function (fromError) {
      if ('undefined' === typeof this.xhr || null === this.xhr) {
        return;
      }
      // xmlhttprequest
      if (this.hasXDR()) {
        this.xhr.onload = this.xhr.onerror = empty$1;
      } else {
        this.xhr.onreadystatechange = empty$1;
      }

      if (fromError) {
        try {
          this.xhr.abort();
        } catch (e) {}
      }

      if (typeof document !== 'undefined') {
        delete Request.requests[this.index];
      }

      this.xhr = null;
    };

    /**
     * Called upon load.
     *
     * @api private
     */

    Request.prototype.onLoad = function () {
      var data;
      try {
        var contentType;
        try {
          contentType = this.xhr.getResponseHeader('Content-Type');
        } catch (e) {}
        if (contentType === 'application/octet-stream' || contentType === 'application/octet-stream; charset=UTF-8') {
          data = this.xhr.response || this.xhr.responseText;
        } else {
          data = this.xhr.responseText;
        }
      } catch (e) {
        this.onError(e);
      }
      if (null != data) {
        this.onData(data);
      }
    };

    /**
     * Check if it has XDomainRequest.
     *
     * @api private
     */

    Request.prototype.hasXDR = function () {
      return typeof XDomainRequest !== 'undefined' && !this.xs && this.enablesXDR;
    };

    /**
     * Aborts the request.
     *
     * @api public
     */

    Request.prototype.abort = function () {
      this.cleanup();
    };

    /**
     * Aborts pending requests when unloading the window. This is needed to prevent
     * memory leaks (e.g. when using IE) and to ensure that no spurious error is
     * emitted.
     */

    Request.requestsCount = 0;
    Request.requests = {};

    if (typeof document !== 'undefined') {
      if (typeof attachEvent === 'function') {
        attachEvent('onunload', unloadHandler);
      } else if (typeof addEventListener === 'function') {
        var terminationEvent = 'onpagehide' in globalThis$2 ? 'pagehide' : 'unload';
        addEventListener(terminationEvent, unloadHandler, false);
      }
    }

    function unloadHandler () {
      for (var i in Request.requests) {
        if (Request.requests.hasOwnProperty(i)) {
          Request.requests[i].abort();
        }
      }
    }

    /**
     * Module requirements.
     */

    var Polling = polling$1;
    var inherit$3 = componentInherit;
    var globalThis$1 = globalThis_browser;

    /**
     * Module exports.
     */

    var pollingJsonp = JSONPPolling;

    /**
     * Cached regular expressions.
     */

    var rNewline = /\n/g;
    var rEscapedNewline = /\\n/g;

    /**
     * Global JSONP callbacks.
     */

    var callbacks;

    /**
     * Noop.
     */

    function empty () { }

    /**
     * JSONP Polling constructor.
     *
     * @param {Object} opts.
     * @api public
     */

    function JSONPPolling (opts) {
      Polling.call(this, opts);

      this.query = this.query || {};

      // define global callbacks array if not present
      // we do this here (lazily) to avoid unneeded global pollution
      if (!callbacks) {
        // we need to consider multiple engines in the same page
        callbacks = globalThis$1.___eio = (globalThis$1.___eio || []);
      }

      // callback identifier
      this.index = callbacks.length;

      // add callback to jsonp global
      var self = this;
      callbacks.push(function (msg) {
        self.onData(msg);
      });

      // append to query string
      this.query.j = this.index;

      // prevent spurious errors from being emitted when the window is unloaded
      if (typeof addEventListener === 'function') {
        addEventListener('beforeunload', function () {
          if (self.script) self.script.onerror = empty;
        }, false);
      }
    }

    /**
     * Inherits from Polling.
     */

    inherit$3(JSONPPolling, Polling);

    /*
     * JSONP only supports binary as base64 encoded strings
     */

    JSONPPolling.prototype.supportsBinary = false;

    /**
     * Closes the socket.
     *
     * @api private
     */

    JSONPPolling.prototype.doClose = function () {
      if (this.script) {
        this.script.parentNode.removeChild(this.script);
        this.script = null;
      }

      if (this.form) {
        this.form.parentNode.removeChild(this.form);
        this.form = null;
        this.iframe = null;
      }

      Polling.prototype.doClose.call(this);
    };

    /**
     * Starts a poll cycle.
     *
     * @api private
     */

    JSONPPolling.prototype.doPoll = function () {
      var self = this;
      var script = document.createElement('script');

      if (this.script) {
        this.script.parentNode.removeChild(this.script);
        this.script = null;
      }

      script.async = true;
      script.src = this.uri();
      script.onerror = function (e) {
        self.onError('jsonp poll error', e);
      };

      var insertAt = document.getElementsByTagName('script')[0];
      if (insertAt) {
        insertAt.parentNode.insertBefore(script, insertAt);
      } else {
        (document.head || document.body).appendChild(script);
      }
      this.script = script;

      var isUAgecko = 'undefined' !== typeof navigator && /gecko/i.test(navigator.userAgent);

      if (isUAgecko) {
        setTimeout(function () {
          var iframe = document.createElement('iframe');
          document.body.appendChild(iframe);
          document.body.removeChild(iframe);
        }, 100);
      }
    };

    /**
     * Writes with a hidden iframe.
     *
     * @param {String} data to send
     * @param {Function} called upon flush.
     * @api private
     */

    JSONPPolling.prototype.doWrite = function (data, fn) {
      var self = this;

      if (!this.form) {
        var form = document.createElement('form');
        var area = document.createElement('textarea');
        var id = this.iframeId = 'eio_iframe_' + this.index;
        var iframe;

        form.className = 'socketio';
        form.style.position = 'absolute';
        form.style.top = '-1000px';
        form.style.left = '-1000px';
        form.target = id;
        form.method = 'POST';
        form.setAttribute('accept-charset', 'utf-8');
        area.name = 'd';
        form.appendChild(area);
        document.body.appendChild(form);

        this.form = form;
        this.area = area;
      }

      this.form.action = this.uri();

      function complete () {
        initIframe();
        fn();
      }

      function initIframe () {
        if (self.iframe) {
          try {
            self.form.removeChild(self.iframe);
          } catch (e) {
            self.onError('jsonp polling iframe removal error', e);
          }
        }

        try {
          // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
          var html = '<iframe src="javascript:0" name="' + self.iframeId + '">';
          iframe = document.createElement(html);
        } catch (e) {
          iframe = document.createElement('iframe');
          iframe.name = self.iframeId;
          iframe.src = 'javascript:0';
        }

        iframe.id = self.iframeId;

        self.form.appendChild(iframe);
        self.iframe = iframe;
      }

      initIframe();

      // escape \n to prevent it from being converted into \r\n by some UAs
      // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
      data = data.replace(rEscapedNewline, '\\\n');
      this.area.value = data.replace(rNewline, '\\n');

      try {
        this.form.submit();
      } catch (e) {}

      if (this.iframe.attachEvent) {
        this.iframe.onreadystatechange = function () {
          if (self.iframe.readyState === 'complete') {
            complete();
          }
        };
      } else {
        this.iframe.onload = complete;
      }
    };

    var _nodeResolve_empty = {};

    var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': _nodeResolve_empty
    });

    var require$$6 = /*@__PURE__*/getAugmentedNamespace(_nodeResolve_empty$1);

    /**
     * Module dependencies.
     */

    var Transport = transport;
    var parser$2 = browser;
    var parseqs$1 = parseqs$3;
    var inherit$2 = componentInherit;
    var yeast = yeast_1;
    var debug$2 = browser$1.exports('engine.io-client:websocket');

    var BrowserWebSocket, NodeWebSocket;

    if (typeof WebSocket !== 'undefined') {
      BrowserWebSocket = WebSocket;
    } else if (typeof self !== 'undefined') {
      BrowserWebSocket = self.WebSocket || self.MozWebSocket;
    }

    if (typeof window === 'undefined') {
      try {
        NodeWebSocket = require$$6;
      } catch (e) { }
    }

    /**
     * Get either the `WebSocket` or `MozWebSocket` globals
     * in the browser or try to resolve WebSocket-compatible
     * interface exposed by `ws` for Node-like environment.
     */

    var WebSocketImpl = BrowserWebSocket || NodeWebSocket;

    /**
     * Module exports.
     */

    var websocket$1 = WS;

    /**
     * WebSocket transport constructor.
     *
     * @api {Object} connection options
     * @api public
     */

    function WS (opts) {
      var forceBase64 = (opts && opts.forceBase64);
      if (forceBase64) {
        this.supportsBinary = false;
      }
      this.perMessageDeflate = opts.perMessageDeflate;
      this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;
      this.protocols = opts.protocols;
      if (!this.usingBrowserWebSocket) {
        WebSocketImpl = NodeWebSocket;
      }
      Transport.call(this, opts);
    }

    /**
     * Inherits from Transport.
     */

    inherit$2(WS, Transport);

    /**
     * Transport name.
     *
     * @api public
     */

    WS.prototype.name = 'websocket';

    /*
     * WebSockets support binary
     */

    WS.prototype.supportsBinary = true;

    /**
     * Opens socket.
     *
     * @api private
     */

    WS.prototype.doOpen = function () {
      if (!this.check()) {
        // let probe timeout
        return;
      }

      var uri = this.uri();
      var protocols = this.protocols;

      var opts = {};

      if (!this.isReactNative) {
        opts.agent = this.agent;
        opts.perMessageDeflate = this.perMessageDeflate;

        // SSL options for Node.js client
        opts.pfx = this.pfx;
        opts.key = this.key;
        opts.passphrase = this.passphrase;
        opts.cert = this.cert;
        opts.ca = this.ca;
        opts.ciphers = this.ciphers;
        opts.rejectUnauthorized = this.rejectUnauthorized;
      }

      if (this.extraHeaders) {
        opts.headers = this.extraHeaders;
      }
      if (this.localAddress) {
        opts.localAddress = this.localAddress;
      }

      try {
        this.ws =
          this.usingBrowserWebSocket && !this.isReactNative
            ? protocols
              ? new WebSocketImpl(uri, protocols)
              : new WebSocketImpl(uri)
            : new WebSocketImpl(uri, protocols, opts);
      } catch (err) {
        return this.emit('error', err);
      }

      if (this.ws.binaryType === undefined) {
        this.supportsBinary = false;
      }

      if (this.ws.supports && this.ws.supports.binary) {
        this.supportsBinary = true;
        this.ws.binaryType = 'nodebuffer';
      } else {
        this.ws.binaryType = 'arraybuffer';
      }

      this.addEventListeners();
    };

    /**
     * Adds event listeners to the socket
     *
     * @api private
     */

    WS.prototype.addEventListeners = function () {
      var self = this;

      this.ws.onopen = function () {
        self.onOpen();
      };
      this.ws.onclose = function () {
        self.onClose();
      };
      this.ws.onmessage = function (ev) {
        self.onData(ev.data);
      };
      this.ws.onerror = function (e) {
        self.onError('websocket error', e);
      };
    };

    /**
     * Writes data to socket.
     *
     * @param {Array} array of packets.
     * @api private
     */

    WS.prototype.write = function (packets) {
      var self = this;
      this.writable = false;

      // encodePacket efficient as it uses WS framing
      // no need for encodePayload
      var total = packets.length;
      for (var i = 0, l = total; i < l; i++) {
        (function (packet) {
          parser$2.encodePacket(packet, self.supportsBinary, function (data) {
            if (!self.usingBrowserWebSocket) {
              // always create a new object (GH-437)
              var opts = {};
              if (packet.options) {
                opts.compress = packet.options.compress;
              }

              if (self.perMessageDeflate) {
                var len = 'string' === typeof data ? Buffer.byteLength(data) : data.length;
                if (len < self.perMessageDeflate.threshold) {
                  opts.compress = false;
                }
              }
            }

            // Sometimes the websocket has already been closed but the browser didn't
            // have a chance of informing us about it yet, in that case send will
            // throw an error
            try {
              if (self.usingBrowserWebSocket) {
                // TypeError is thrown when passing the second argument on Safari
                self.ws.send(data);
              } else {
                self.ws.send(data, opts);
              }
            } catch (e) {
              debug$2('websocket closed before onclose event');
            }

            --total || done();
          });
        })(packets[i]);
      }

      function done () {
        self.emit('flush');

        // fake drain
        // defer to next tick to allow Socket to clear writeBuffer
        setTimeout(function () {
          self.writable = true;
          self.emit('drain');
        }, 0);
      }
    };

    /**
     * Called upon close
     *
     * @api private
     */

    WS.prototype.onClose = function () {
      Transport.prototype.onClose.call(this);
    };

    /**
     * Closes socket.
     *
     * @api private
     */

    WS.prototype.doClose = function () {
      if (typeof this.ws !== 'undefined') {
        this.ws.close();
      }
    };

    /**
     * Generates uri for connection.
     *
     * @api private
     */

    WS.prototype.uri = function () {
      var query = this.query || {};
      var schema = this.secure ? 'wss' : 'ws';
      var port = '';

      // avoid port if default for schema
      if (this.port && (('wss' === schema && Number(this.port) !== 443) ||
        ('ws' === schema && Number(this.port) !== 80))) {
        port = ':' + this.port;
      }

      // append timestamp to URI
      if (this.timestampRequests) {
        query[this.timestampParam] = yeast();
      }

      // communicate binary support capabilities
      if (!this.supportsBinary) {
        query.b64 = 1;
      }

      query = parseqs$1.encode(query);

      // prepend ? to query
      if (query.length) {
        query = '?' + query;
      }

      var ipv6 = this.hostname.indexOf(':') !== -1;
      return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
    };

    /**
     * Feature detection for WebSocket.
     *
     * @return {Boolean} whether this transport is available.
     * @api public
     */

    WS.prototype.check = function () {
      return !!WebSocketImpl && !('__initialize' in WebSocketImpl && this.name === WS.prototype.name);
    };

    /**
     * Module dependencies
     */

    var XMLHttpRequest$1 = xmlhttprequest;
    var XHR = pollingXhr.exports;
    var JSONP = pollingJsonp;
    var websocket = websocket$1;

    /**
     * Export transports.
     */

    transports$1.polling = polling;
    transports$1.websocket = websocket;

    /**
     * Polling transport polymorphic constructor.
     * Decides on xhr vs jsonp based on feature detection.
     *
     * @api private
     */

    function polling (opts) {
      var xhr;
      var xd = false;
      var xs = false;
      var jsonp = false !== opts.jsonp;

      if (typeof location !== 'undefined') {
        var isSSL = 'https:' === location.protocol;
        var port = location.port;

        // some user agents have empty `location.port`
        if (!port) {
          port = isSSL ? 443 : 80;
        }

        xd = opts.hostname !== location.hostname || port !== opts.port;
        xs = opts.secure !== isSSL;
      }

      opts.xdomain = xd;
      opts.xscheme = xs;
      xhr = new XMLHttpRequest$1(opts);

      if ('open' in xhr && !opts.forceJSONP) {
        return new XHR(opts);
      } else {
        if (!jsonp) throw new Error('JSONP disabled');
        return new JSONP(opts);
      }
    }

    var indexOf$2 = [].indexOf;

    var indexof = function(arr, obj){
      if (indexOf$2) return arr.indexOf(obj);
      for (var i = 0; i < arr.length; ++i) {
        if (arr[i] === obj) return i;
      }
      return -1;
    };

    /**
     * Module dependencies.
     */

    var transports = transports$1;
    var Emitter$1 = componentEmitter.exports;
    var debug$1 = browser$1.exports('engine.io-client:socket');
    var index = indexof;
    var parser$1 = browser;
    var parseuri = parseuri$2;
    var parseqs = parseqs$3;

    /**
     * Module exports.
     */

    var socket$1 = Socket$1;

    /**
     * Socket constructor.
     *
     * @param {String|Object} uri or options
     * @param {Object} options
     * @api public
     */

    function Socket$1 (uri, opts) {
      if (!(this instanceof Socket$1)) return new Socket$1(uri, opts);

      opts = opts || {};

      if (uri && 'object' === typeof uri) {
        opts = uri;
        uri = null;
      }

      if (uri) {
        uri = parseuri(uri);
        opts.hostname = uri.host;
        opts.secure = uri.protocol === 'https' || uri.protocol === 'wss';
        opts.port = uri.port;
        if (uri.query) opts.query = uri.query;
      } else if (opts.host) {
        opts.hostname = parseuri(opts.host).host;
      }

      this.secure = null != opts.secure ? opts.secure
        : (typeof location !== 'undefined' && 'https:' === location.protocol);

      if (opts.hostname && !opts.port) {
        // if no port is specified manually, use the protocol default
        opts.port = this.secure ? '443' : '80';
      }

      this.agent = opts.agent || false;
      this.hostname = opts.hostname ||
        (typeof location !== 'undefined' ? location.hostname : 'localhost');
      this.port = opts.port || (typeof location !== 'undefined' && location.port
          ? location.port
          : (this.secure ? 443 : 80));
      this.query = opts.query || {};
      if ('string' === typeof this.query) this.query = parseqs.decode(this.query);
      this.upgrade = false !== opts.upgrade;
      this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
      this.forceJSONP = !!opts.forceJSONP;
      this.jsonp = false !== opts.jsonp;
      this.forceBase64 = !!opts.forceBase64;
      this.enablesXDR = !!opts.enablesXDR;
      this.withCredentials = false !== opts.withCredentials;
      this.timestampParam = opts.timestampParam || 't';
      this.timestampRequests = opts.timestampRequests;
      this.transports = opts.transports || ['polling', 'websocket'];
      this.transportOptions = opts.transportOptions || {};
      this.readyState = '';
      this.writeBuffer = [];
      this.prevBufferLen = 0;
      this.policyPort = opts.policyPort || 843;
      this.rememberUpgrade = opts.rememberUpgrade || false;
      this.binaryType = null;
      this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
      this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;

      if (true === this.perMessageDeflate) this.perMessageDeflate = {};
      if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
        this.perMessageDeflate.threshold = 1024;
      }

      // SSL options for Node.js client
      this.pfx = opts.pfx || undefined;
      this.key = opts.key || undefined;
      this.passphrase = opts.passphrase || undefined;
      this.cert = opts.cert || undefined;
      this.ca = opts.ca || undefined;
      this.ciphers = opts.ciphers || undefined;
      this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;
      this.forceNode = !!opts.forceNode;

      // detect ReactNative environment
      this.isReactNative = (typeof navigator !== 'undefined' && typeof navigator.product === 'string' && navigator.product.toLowerCase() === 'reactnative');

      // other options for Node.js or ReactNative client
      if (typeof self === 'undefined' || this.isReactNative) {
        if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
          this.extraHeaders = opts.extraHeaders;
        }

        if (opts.localAddress) {
          this.localAddress = opts.localAddress;
        }
      }

      // set on handshake
      this.id = null;
      this.upgrades = null;
      this.pingInterval = null;
      this.pingTimeout = null;

      // set on heartbeat
      this.pingIntervalTimer = null;
      this.pingTimeoutTimer = null;

      this.open();
    }

    Socket$1.priorWebsocketSuccess = false;

    /**
     * Mix in `Emitter`.
     */

    Emitter$1(Socket$1.prototype);

    /**
     * Protocol version.
     *
     * @api public
     */

    Socket$1.protocol = parser$1.protocol; // this is an int

    /**
     * Expose deps for legacy compatibility
     * and standalone browser access.
     */

    Socket$1.Socket = Socket$1;
    Socket$1.Transport = transport;
    Socket$1.transports = transports$1;
    Socket$1.parser = browser;

    /**
     * Creates transport of the given type.
     *
     * @param {String} transport name
     * @return {Transport}
     * @api private
     */

    Socket$1.prototype.createTransport = function (name) {
      debug$1('creating transport "%s"', name);
      var query = clone$1(this.query);

      // append engine.io protocol identifier
      query.EIO = parser$1.protocol;

      // transport name
      query.transport = name;

      // per-transport options
      var options = this.transportOptions[name] || {};

      // session id if we already have one
      if (this.id) query.sid = this.id;

      var transport = new transports[name]({
        query: query,
        socket: this,
        agent: options.agent || this.agent,
        hostname: options.hostname || this.hostname,
        port: options.port || this.port,
        secure: options.secure || this.secure,
        path: options.path || this.path,
        forceJSONP: options.forceJSONP || this.forceJSONP,
        jsonp: options.jsonp || this.jsonp,
        forceBase64: options.forceBase64 || this.forceBase64,
        enablesXDR: options.enablesXDR || this.enablesXDR,
        withCredentials: options.withCredentials || this.withCredentials,
        timestampRequests: options.timestampRequests || this.timestampRequests,
        timestampParam: options.timestampParam || this.timestampParam,
        policyPort: options.policyPort || this.policyPort,
        pfx: options.pfx || this.pfx,
        key: options.key || this.key,
        passphrase: options.passphrase || this.passphrase,
        cert: options.cert || this.cert,
        ca: options.ca || this.ca,
        ciphers: options.ciphers || this.ciphers,
        rejectUnauthorized: options.rejectUnauthorized || this.rejectUnauthorized,
        perMessageDeflate: options.perMessageDeflate || this.perMessageDeflate,
        extraHeaders: options.extraHeaders || this.extraHeaders,
        forceNode: options.forceNode || this.forceNode,
        localAddress: options.localAddress || this.localAddress,
        requestTimeout: options.requestTimeout || this.requestTimeout,
        protocols: options.protocols || void (0),
        isReactNative: this.isReactNative
      });

      return transport;
    };

    function clone$1 (obj) {
      var o = {};
      for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
          o[i] = obj[i];
        }
      }
      return o;
    }

    /**
     * Initializes transport to use and starts probe.
     *
     * @api private
     */
    Socket$1.prototype.open = function () {
      var transport;
      if (this.rememberUpgrade && Socket$1.priorWebsocketSuccess && this.transports.indexOf('websocket') !== -1) {
        transport = 'websocket';
      } else if (0 === this.transports.length) {
        // Emit error on next tick so it can be listened to
        var self = this;
        setTimeout(function () {
          self.emit('error', 'No transports available');
        }, 0);
        return;
      } else {
        transport = this.transports[0];
      }
      this.readyState = 'opening';

      // Retry with the next transport if the transport is disabled (jsonp: false)
      try {
        transport = this.createTransport(transport);
      } catch (e) {
        this.transports.shift();
        this.open();
        return;
      }

      transport.open();
      this.setTransport(transport);
    };

    /**
     * Sets the current transport. Disables the existing one (if any).
     *
     * @api private
     */

    Socket$1.prototype.setTransport = function (transport) {
      debug$1('setting transport %s', transport.name);
      var self = this;

      if (this.transport) {
        debug$1('clearing existing transport %s', this.transport.name);
        this.transport.removeAllListeners();
      }

      // set up transport
      this.transport = transport;

      // set up transport listeners
      transport
      .on('drain', function () {
        self.onDrain();
      })
      .on('packet', function (packet) {
        self.onPacket(packet);
      })
      .on('error', function (e) {
        self.onError(e);
      })
      .on('close', function () {
        self.onClose('transport close');
      });
    };

    /**
     * Probes a transport.
     *
     * @param {String} transport name
     * @api private
     */

    Socket$1.prototype.probe = function (name) {
      debug$1('probing transport "%s"', name);
      var transport = this.createTransport(name, { probe: 1 });
      var failed = false;
      var self = this;

      Socket$1.priorWebsocketSuccess = false;

      function onTransportOpen () {
        if (self.onlyBinaryUpgrades) {
          var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
          failed = failed || upgradeLosesBinary;
        }
        if (failed) return;

        debug$1('probe transport "%s" opened', name);
        transport.send([{ type: 'ping', data: 'probe' }]);
        transport.once('packet', function (msg) {
          if (failed) return;
          if ('pong' === msg.type && 'probe' === msg.data) {
            debug$1('probe transport "%s" pong', name);
            self.upgrading = true;
            self.emit('upgrading', transport);
            if (!transport) return;
            Socket$1.priorWebsocketSuccess = 'websocket' === transport.name;

            debug$1('pausing current transport "%s"', self.transport.name);
            self.transport.pause(function () {
              if (failed) return;
              if ('closed' === self.readyState) return;
              debug$1('changing transport and sending upgrade packet');

              cleanup();

              self.setTransport(transport);
              transport.send([{ type: 'upgrade' }]);
              self.emit('upgrade', transport);
              transport = null;
              self.upgrading = false;
              self.flush();
            });
          } else {
            debug$1('probe transport "%s" failed', name);
            var err = new Error('probe error');
            err.transport = transport.name;
            self.emit('upgradeError', err);
          }
        });
      }

      function freezeTransport () {
        if (failed) return;

        // Any callback called by transport should be ignored since now
        failed = true;

        cleanup();

        transport.close();
        transport = null;
      }

      // Handle any error that happens while probing
      function onerror (err) {
        var error = new Error('probe error: ' + err);
        error.transport = transport.name;

        freezeTransport();

        debug$1('probe transport "%s" failed because of error: %s', name, err);

        self.emit('upgradeError', error);
      }

      function onTransportClose () {
        onerror('transport closed');
      }

      // When the socket is closed while we're probing
      function onclose () {
        onerror('socket closed');
      }

      // When the socket is upgraded while we're probing
      function onupgrade (to) {
        if (transport && to.name !== transport.name) {
          debug$1('"%s" works - aborting "%s"', to.name, transport.name);
          freezeTransport();
        }
      }

      // Remove all listeners on the transport and on self
      function cleanup () {
        transport.removeListener('open', onTransportOpen);
        transport.removeListener('error', onerror);
        transport.removeListener('close', onTransportClose);
        self.removeListener('close', onclose);
        self.removeListener('upgrading', onupgrade);
      }

      transport.once('open', onTransportOpen);
      transport.once('error', onerror);
      transport.once('close', onTransportClose);

      this.once('close', onclose);
      this.once('upgrading', onupgrade);

      transport.open();
    };

    /**
     * Called when connection is deemed open.
     *
     * @api public
     */

    Socket$1.prototype.onOpen = function () {
      debug$1('socket open');
      this.readyState = 'open';
      Socket$1.priorWebsocketSuccess = 'websocket' === this.transport.name;
      this.emit('open');
      this.flush();

      // we check for `readyState` in case an `open`
      // listener already closed the socket
      if ('open' === this.readyState && this.upgrade && this.transport.pause) {
        debug$1('starting upgrade probes');
        for (var i = 0, l = this.upgrades.length; i < l; i++) {
          this.probe(this.upgrades[i]);
        }
      }
    };

    /**
     * Handles a packet.
     *
     * @api private
     */

    Socket$1.prototype.onPacket = function (packet) {
      if ('opening' === this.readyState || 'open' === this.readyState ||
          'closing' === this.readyState) {
        debug$1('socket receive: type "%s", data "%s"', packet.type, packet.data);

        this.emit('packet', packet);

        // Socket is live - any packet counts
        this.emit('heartbeat');

        switch (packet.type) {
          case 'open':
            this.onHandshake(JSON.parse(packet.data));
            break;

          case 'pong':
            this.setPing();
            this.emit('pong');
            break;

          case 'error':
            var err = new Error('server error');
            err.code = packet.data;
            this.onError(err);
            break;

          case 'message':
            this.emit('data', packet.data);
            this.emit('message', packet.data);
            break;
        }
      } else {
        debug$1('packet received with socket readyState "%s"', this.readyState);
      }
    };

    /**
     * Called upon handshake completion.
     *
     * @param {Object} handshake obj
     * @api private
     */

    Socket$1.prototype.onHandshake = function (data) {
      this.emit('handshake', data);
      this.id = data.sid;
      this.transport.query.sid = data.sid;
      this.upgrades = this.filterUpgrades(data.upgrades);
      this.pingInterval = data.pingInterval;
      this.pingTimeout = data.pingTimeout;
      this.onOpen();
      // In case open handler closes socket
      if ('closed' === this.readyState) return;
      this.setPing();

      // Prolong liveness of socket on heartbeat
      this.removeListener('heartbeat', this.onHeartbeat);
      this.on('heartbeat', this.onHeartbeat);
    };

    /**
     * Resets ping timeout.
     *
     * @api private
     */

    Socket$1.prototype.onHeartbeat = function (timeout) {
      clearTimeout(this.pingTimeoutTimer);
      var self = this;
      self.pingTimeoutTimer = setTimeout(function () {
        if ('closed' === self.readyState) return;
        self.onClose('ping timeout');
      }, timeout || (self.pingInterval + self.pingTimeout));
    };

    /**
     * Pings server every `this.pingInterval` and expects response
     * within `this.pingTimeout` or closes connection.
     *
     * @api private
     */

    Socket$1.prototype.setPing = function () {
      var self = this;
      clearTimeout(self.pingIntervalTimer);
      self.pingIntervalTimer = setTimeout(function () {
        debug$1('writing ping packet - expecting pong within %sms', self.pingTimeout);
        self.ping();
        self.onHeartbeat(self.pingTimeout);
      }, self.pingInterval);
    };

    /**
    * Sends a ping packet.
    *
    * @api private
    */

    Socket$1.prototype.ping = function () {
      var self = this;
      this.sendPacket('ping', function () {
        self.emit('ping');
      });
    };

    /**
     * Called on `drain` event
     *
     * @api private
     */

    Socket$1.prototype.onDrain = function () {
      this.writeBuffer.splice(0, this.prevBufferLen);

      // setting prevBufferLen = 0 is very important
      // for example, when upgrading, upgrade packet is sent over,
      // and a nonzero prevBufferLen could cause problems on `drain`
      this.prevBufferLen = 0;

      if (0 === this.writeBuffer.length) {
        this.emit('drain');
      } else {
        this.flush();
      }
    };

    /**
     * Flush write buffers.
     *
     * @api private
     */

    Socket$1.prototype.flush = function () {
      if ('closed' !== this.readyState && this.transport.writable &&
        !this.upgrading && this.writeBuffer.length) {
        debug$1('flushing %d packets in socket', this.writeBuffer.length);
        this.transport.send(this.writeBuffer);
        // keep track of current length of writeBuffer
        // splice writeBuffer and callbackBuffer on `drain`
        this.prevBufferLen = this.writeBuffer.length;
        this.emit('flush');
      }
    };

    /**
     * Sends a message.
     *
     * @param {String} message.
     * @param {Function} callback function.
     * @param {Object} options.
     * @return {Socket} for chaining.
     * @api public
     */

    Socket$1.prototype.write =
    Socket$1.prototype.send = function (msg, options, fn) {
      this.sendPacket('message', msg, options, fn);
      return this;
    };

    /**
     * Sends a packet.
     *
     * @param {String} packet type.
     * @param {String} data.
     * @param {Object} options.
     * @param {Function} callback function.
     * @api private
     */

    Socket$1.prototype.sendPacket = function (type, data, options, fn) {
      if ('function' === typeof data) {
        fn = data;
        data = undefined;
      }

      if ('function' === typeof options) {
        fn = options;
        options = null;
      }

      if ('closing' === this.readyState || 'closed' === this.readyState) {
        return;
      }

      options = options || {};
      options.compress = false !== options.compress;

      var packet = {
        type: type,
        data: data,
        options: options
      };
      this.emit('packetCreate', packet);
      this.writeBuffer.push(packet);
      if (fn) this.once('flush', fn);
      this.flush();
    };

    /**
     * Closes the connection.
     *
     * @api private
     */

    Socket$1.prototype.close = function () {
      if ('opening' === this.readyState || 'open' === this.readyState) {
        this.readyState = 'closing';

        var self = this;

        if (this.writeBuffer.length) {
          this.once('drain', function () {
            if (this.upgrading) {
              waitForUpgrade();
            } else {
              close();
            }
          });
        } else if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      }

      function close () {
        self.onClose('forced close');
        debug$1('socket closing - telling transport to close');
        self.transport.close();
      }

      function cleanupAndClose () {
        self.removeListener('upgrade', cleanupAndClose);
        self.removeListener('upgradeError', cleanupAndClose);
        close();
      }

      function waitForUpgrade () {
        // wait for upgrade to finish since we can't send packets while pausing a transport
        self.once('upgrade', cleanupAndClose);
        self.once('upgradeError', cleanupAndClose);
      }

      return this;
    };

    /**
     * Called upon transport error
     *
     * @api private
     */

    Socket$1.prototype.onError = function (err) {
      debug$1('socket error %j', err);
      Socket$1.priorWebsocketSuccess = false;
      this.emit('error', err);
      this.onClose('transport error', err);
    };

    /**
     * Called upon transport close.
     *
     * @api private
     */

    Socket$1.prototype.onClose = function (reason, desc) {
      if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {
        debug$1('socket close with reason: "%s"', reason);
        var self = this;

        // clear timers
        clearTimeout(this.pingIntervalTimer);
        clearTimeout(this.pingTimeoutTimer);

        // stop event from firing again for transport
        this.transport.removeAllListeners('close');

        // ensure transport won't stay open
        this.transport.close();

        // ignore further transport communication
        this.transport.removeAllListeners();

        // set ready state
        this.readyState = 'closed';

        // clear session id
        this.id = null;

        // emit close event
        this.emit('close', reason, desc);

        // clean buffers after, so users can still
        // grab the buffers on `close` event
        self.writeBuffer = [];
        self.prevBufferLen = 0;
      }
    };

    /**
     * Filters upgrades, returning only those matching client transports.
     *
     * @param {Array} server upgrades
     * @api private
     *
     */

    Socket$1.prototype.filterUpgrades = function (upgrades) {
      var filteredUpgrades = [];
      for (var i = 0, j = upgrades.length; i < j; i++) {
        if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
      }
      return filteredUpgrades;
    };

    lib.exports = socket$1;

    /**
     * Exports parser
     *
     * @api public
     *
     */
    lib.exports.parser = browser;

    var socket = {exports: {}};

    var toArray_1 = toArray$1;

    function toArray$1(list, index) {
        var array = [];

        index = index || 0;

        for (var i = index || 0; i < list.length; i++) {
            array[i - index] = list[i];
        }

        return array
    }

    /**
     * Module exports.
     */

    var on_1 = on$1;

    /**
     * Helper for subscriptions.
     *
     * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
     * @param {String} event name
     * @param {Function} callback
     * @api public
     */

    function on$1 (obj, ev, fn) {
      obj.on(ev, fn);
      return {
        destroy: function () {
          obj.removeListener(ev, fn);
        }
      };
    }

    /**
     * Slice reference.
     */

    var slice$1 = [].slice;

    /**
     * Bind `obj` to `fn`.
     *
     * @param {Object} obj
     * @param {Function|String} fn or string
     * @return {Function}
     * @api public
     */

    var componentBind = function(obj, fn){
      if ('string' == typeof fn) fn = obj[fn];
      if ('function' != typeof fn) throw new Error('bind() requires a function');
      var args = slice$1.call(arguments, 2);
      return function(){
        return fn.apply(obj, args.concat(slice$1.call(arguments)));
      }
    };

    (function (module, exports) {
    /**
     * Module dependencies.
     */

    var parser = socket_ioParser;
    var Emitter = componentEmitter.exports;
    var toArray = toArray_1;
    var on = on_1;
    var bind = componentBind;
    var debug = browser$1.exports('socket.io-client:socket');
    var parseqs = parseqs$3;
    var hasBin = hasBinary2;

    /**
     * Module exports.
     */

    module.exports = Socket;

    /**
     * Internal events (blacklisted).
     * These events can't be emitted by the user.
     *
     * @api private
     */

    var events = {
      connect: 1,
      connect_error: 1,
      connect_timeout: 1,
      connecting: 1,
      disconnect: 1,
      error: 1,
      reconnect: 1,
      reconnect_attempt: 1,
      reconnect_failed: 1,
      reconnect_error: 1,
      reconnecting: 1,
      ping: 1,
      pong: 1
    };

    /**
     * Shortcut to `Emitter#emit`.
     */

    var emit = Emitter.prototype.emit;

    /**
     * `Socket` constructor.
     *
     * @api public
     */

    function Socket (io, nsp, opts) {
      this.io = io;
      this.nsp = nsp;
      this.json = this; // compat
      this.ids = 0;
      this.acks = {};
      this.receiveBuffer = [];
      this.sendBuffer = [];
      this.connected = false;
      this.disconnected = true;
      this.flags = {};
      if (opts && opts.query) {
        this.query = opts.query;
      }
      if (this.io.autoConnect) this.open();
    }

    /**
     * Mix in `Emitter`.
     */

    Emitter(Socket.prototype);

    /**
     * Subscribe to open, close and packet events
     *
     * @api private
     */

    Socket.prototype.subEvents = function () {
      if (this.subs) return;

      var io = this.io;
      this.subs = [
        on(io, 'open', bind(this, 'onopen')),
        on(io, 'packet', bind(this, 'onpacket')),
        on(io, 'close', bind(this, 'onclose'))
      ];
    };

    /**
     * "Opens" the socket.
     *
     * @api public
     */

    Socket.prototype.open =
    Socket.prototype.connect = function () {
      if (this.connected) return this;

      this.subEvents();
      if (!this.io.reconnecting) this.io.open(); // ensure open
      if ('open' === this.io.readyState) this.onopen();
      this.emit('connecting');
      return this;
    };

    /**
     * Sends a `message` event.
     *
     * @return {Socket} self
     * @api public
     */

    Socket.prototype.send = function () {
      var args = toArray(arguments);
      args.unshift('message');
      this.emit.apply(this, args);
      return this;
    };

    /**
     * Override `emit`.
     * If the event is in `events`, it's emitted normally.
     *
     * @param {String} event name
     * @return {Socket} self
     * @api public
     */

    Socket.prototype.emit = function (ev) {
      if (events.hasOwnProperty(ev)) {
        emit.apply(this, arguments);
        return this;
      }

      var args = toArray(arguments);
      var packet = {
        type: (this.flags.binary !== undefined ? this.flags.binary : hasBin(args)) ? parser.BINARY_EVENT : parser.EVENT,
        data: args
      };

      packet.options = {};
      packet.options.compress = !this.flags || false !== this.flags.compress;

      // event ack callback
      if ('function' === typeof args[args.length - 1]) {
        debug('emitting packet with ack id %d', this.ids);
        this.acks[this.ids] = args.pop();
        packet.id = this.ids++;
      }

      if (this.connected) {
        this.packet(packet);
      } else {
        this.sendBuffer.push(packet);
      }

      this.flags = {};

      return this;
    };

    /**
     * Sends a packet.
     *
     * @param {Object} packet
     * @api private
     */

    Socket.prototype.packet = function (packet) {
      packet.nsp = this.nsp;
      this.io.packet(packet);
    };

    /**
     * Called upon engine `open`.
     *
     * @api private
     */

    Socket.prototype.onopen = function () {
      debug('transport is open - connecting');

      // write connect packet if necessary
      if ('/' !== this.nsp) {
        if (this.query) {
          var query = typeof this.query === 'object' ? parseqs.encode(this.query) : this.query;
          debug('sending connect packet with query %s', query);
          this.packet({type: parser.CONNECT, query: query});
        } else {
          this.packet({type: parser.CONNECT});
        }
      }
    };

    /**
     * Called upon engine `close`.
     *
     * @param {String} reason
     * @api private
     */

    Socket.prototype.onclose = function (reason) {
      debug('close (%s)', reason);
      this.connected = false;
      this.disconnected = true;
      delete this.id;
      this.emit('disconnect', reason);
    };

    /**
     * Called with socket packet.
     *
     * @param {Object} packet
     * @api private
     */

    Socket.prototype.onpacket = function (packet) {
      var sameNamespace = packet.nsp === this.nsp;
      var rootNamespaceError = packet.type === parser.ERROR && packet.nsp === '/';

      if (!sameNamespace && !rootNamespaceError) return;

      switch (packet.type) {
        case parser.CONNECT:
          this.onconnect();
          break;

        case parser.EVENT:
          this.onevent(packet);
          break;

        case parser.BINARY_EVENT:
          this.onevent(packet);
          break;

        case parser.ACK:
          this.onack(packet);
          break;

        case parser.BINARY_ACK:
          this.onack(packet);
          break;

        case parser.DISCONNECT:
          this.ondisconnect();
          break;

        case parser.ERROR:
          this.emit('error', packet.data);
          break;
      }
    };

    /**
     * Called upon a server event.
     *
     * @param {Object} packet
     * @api private
     */

    Socket.prototype.onevent = function (packet) {
      var args = packet.data || [];
      debug('emitting event %j', args);

      if (null != packet.id) {
        debug('attaching ack callback to event');
        args.push(this.ack(packet.id));
      }

      if (this.connected) {
        emit.apply(this, args);
      } else {
        this.receiveBuffer.push(args);
      }
    };

    /**
     * Produces an ack callback to emit with an event.
     *
     * @api private
     */

    Socket.prototype.ack = function (id) {
      var self = this;
      var sent = false;
      return function () {
        // prevent double callbacks
        if (sent) return;
        sent = true;
        var args = toArray(arguments);
        debug('sending ack %j', args);

        self.packet({
          type: hasBin(args) ? parser.BINARY_ACK : parser.ACK,
          id: id,
          data: args
        });
      };
    };

    /**
     * Called upon a server acknowlegement.
     *
     * @param {Object} packet
     * @api private
     */

    Socket.prototype.onack = function (packet) {
      var ack = this.acks[packet.id];
      if ('function' === typeof ack) {
        debug('calling ack %s with %j', packet.id, packet.data);
        ack.apply(this, packet.data);
        delete this.acks[packet.id];
      } else {
        debug('bad ack %s', packet.id);
      }
    };

    /**
     * Called upon server connect.
     *
     * @api private
     */

    Socket.prototype.onconnect = function () {
      this.connected = true;
      this.disconnected = false;
      this.emit('connect');
      this.emitBuffered();
    };

    /**
     * Emit buffered events (received and emitted).
     *
     * @api private
     */

    Socket.prototype.emitBuffered = function () {
      var i;
      for (i = 0; i < this.receiveBuffer.length; i++) {
        emit.apply(this, this.receiveBuffer[i]);
      }
      this.receiveBuffer = [];

      for (i = 0; i < this.sendBuffer.length; i++) {
        this.packet(this.sendBuffer[i]);
      }
      this.sendBuffer = [];
    };

    /**
     * Called upon server disconnect.
     *
     * @api private
     */

    Socket.prototype.ondisconnect = function () {
      debug('server disconnect (%s)', this.nsp);
      this.destroy();
      this.onclose('io server disconnect');
    };

    /**
     * Called upon forced client/server side disconnections,
     * this method ensures the manager stops tracking us and
     * that reconnections don't get triggered for this.
     *
     * @api private.
     */

    Socket.prototype.destroy = function () {
      if (this.subs) {
        // clean subscriptions to avoid reconnections
        for (var i = 0; i < this.subs.length; i++) {
          this.subs[i].destroy();
        }
        this.subs = null;
      }

      this.io.destroy(this);
    };

    /**
     * Disconnects the socket manually.
     *
     * @return {Socket} self
     * @api public
     */

    Socket.prototype.close =
    Socket.prototype.disconnect = function () {
      if (this.connected) {
        debug('performing disconnect (%s)', this.nsp);
        this.packet({ type: parser.DISCONNECT });
      }

      // remove socket from pool
      this.destroy();

      if (this.connected) {
        // fire events
        this.onclose('io client disconnect');
      }
      return this;
    };

    /**
     * Sets the compress flag.
     *
     * @param {Boolean} if `true`, compresses the sending data
     * @return {Socket} self
     * @api public
     */

    Socket.prototype.compress = function (compress) {
      this.flags.compress = compress;
      return this;
    };

    /**
     * Sets the binary flag
     *
     * @param {Boolean} whether the emitted data contains binary
     * @return {Socket} self
     * @api public
     */

    Socket.prototype.binary = function (binary) {
      this.flags.binary = binary;
      return this;
    };
    }(socket));

    /**
     * Expose `Backoff`.
     */

    var backo2 = Backoff$1;

    /**
     * Initialize backoff timer with `opts`.
     *
     * - `min` initial timeout in milliseconds [100]
     * - `max` max timeout [10000]
     * - `jitter` [0]
     * - `factor` [2]
     *
     * @param {Object} opts
     * @api public
     */

    function Backoff$1(opts) {
      opts = opts || {};
      this.ms = opts.min || 100;
      this.max = opts.max || 10000;
      this.factor = opts.factor || 2;
      this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
      this.attempts = 0;
    }

    /**
     * Return the backoff duration.
     *
     * @return {Number}
     * @api public
     */

    Backoff$1.prototype.duration = function(){
      var ms = this.ms * Math.pow(this.factor, this.attempts++);
      if (this.jitter) {
        var rand =  Math.random();
        var deviation = Math.floor(rand * this.jitter * ms);
        ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
      }
      return Math.min(ms, this.max) | 0;
    };

    /**
     * Reset the number of attempts.
     *
     * @api public
     */

    Backoff$1.prototype.reset = function(){
      this.attempts = 0;
    };

    /**
     * Set the minimum duration
     *
     * @api public
     */

    Backoff$1.prototype.setMin = function(min){
      this.ms = min;
    };

    /**
     * Set the maximum duration
     *
     * @api public
     */

    Backoff$1.prototype.setMax = function(max){
      this.max = max;
    };

    /**
     * Set the jitter
     *
     * @api public
     */

    Backoff$1.prototype.setJitter = function(jitter){
      this.jitter = jitter;
    };

    /**
     * Module dependencies.
     */

    var eio = lib.exports;
    var Socket = socket.exports;
    var Emitter = componentEmitter.exports;
    var parser = socket_ioParser;
    var on = on_1;
    var bind$1 = componentBind;
    var debug = browser$1.exports('socket.io-client:manager');
    var indexOf$1 = indexof;
    var Backoff = backo2;

    /**
     * IE6+ hasOwnProperty
     */

    var has$2 = Object.prototype.hasOwnProperty;

    /**
     * Module exports
     */

    var manager = Manager;

    /**
     * `Manager` constructor.
     *
     * @param {String} engine instance or engine uri/opts
     * @param {Object} options
     * @api public
     */

    function Manager (uri, opts) {
      if (!(this instanceof Manager)) return new Manager(uri, opts);
      if (uri && ('object' === typeof uri)) {
        opts = uri;
        uri = undefined;
      }
      opts = opts || {};

      opts.path = opts.path || '/socket.io';
      this.nsps = {};
      this.subs = [];
      this.opts = opts;
      this.reconnection(opts.reconnection !== false);
      this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
      this.reconnectionDelay(opts.reconnectionDelay || 1000);
      this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
      this.randomizationFactor(opts.randomizationFactor || 0.5);
      this.backoff = new Backoff({
        min: this.reconnectionDelay(),
        max: this.reconnectionDelayMax(),
        jitter: this.randomizationFactor()
      });
      this.timeout(null == opts.timeout ? 20000 : opts.timeout);
      this.readyState = 'closed';
      this.uri = uri;
      this.connecting = [];
      this.lastPing = null;
      this.encoding = false;
      this.packetBuffer = [];
      var _parser = opts.parser || parser;
      this.encoder = new _parser.Encoder();
      this.decoder = new _parser.Decoder();
      this.autoConnect = opts.autoConnect !== false;
      if (this.autoConnect) this.open();
    }

    /**
     * Propagate given event to sockets and emit on `this`
     *
     * @api private
     */

    Manager.prototype.emitAll = function () {
      this.emit.apply(this, arguments);
      for (var nsp in this.nsps) {
        if (has$2.call(this.nsps, nsp)) {
          this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
        }
      }
    };

    /**
     * Update `socket.id` of all sockets
     *
     * @api private
     */

    Manager.prototype.updateSocketIds = function () {
      for (var nsp in this.nsps) {
        if (has$2.call(this.nsps, nsp)) {
          this.nsps[nsp].id = this.generateId(nsp);
        }
      }
    };

    /**
     * generate `socket.id` for the given `nsp`
     *
     * @param {String} nsp
     * @return {String}
     * @api private
     */

    Manager.prototype.generateId = function (nsp) {
      return (nsp === '/' ? '' : (nsp + '#')) + this.engine.id;
    };

    /**
     * Mix in `Emitter`.
     */

    Emitter(Manager.prototype);

    /**
     * Sets the `reconnection` config.
     *
     * @param {Boolean} true/false if it should automatically reconnect
     * @return {Manager} self or value
     * @api public
     */

    Manager.prototype.reconnection = function (v) {
      if (!arguments.length) return this._reconnection;
      this._reconnection = !!v;
      return this;
    };

    /**
     * Sets the reconnection attempts config.
     *
     * @param {Number} max reconnection attempts before giving up
     * @return {Manager} self or value
     * @api public
     */

    Manager.prototype.reconnectionAttempts = function (v) {
      if (!arguments.length) return this._reconnectionAttempts;
      this._reconnectionAttempts = v;
      return this;
    };

    /**
     * Sets the delay between reconnections.
     *
     * @param {Number} delay
     * @return {Manager} self or value
     * @api public
     */

    Manager.prototype.reconnectionDelay = function (v) {
      if (!arguments.length) return this._reconnectionDelay;
      this._reconnectionDelay = v;
      this.backoff && this.backoff.setMin(v);
      return this;
    };

    Manager.prototype.randomizationFactor = function (v) {
      if (!arguments.length) return this._randomizationFactor;
      this._randomizationFactor = v;
      this.backoff && this.backoff.setJitter(v);
      return this;
    };

    /**
     * Sets the maximum delay between reconnections.
     *
     * @param {Number} delay
     * @return {Manager} self or value
     * @api public
     */

    Manager.prototype.reconnectionDelayMax = function (v) {
      if (!arguments.length) return this._reconnectionDelayMax;
      this._reconnectionDelayMax = v;
      this.backoff && this.backoff.setMax(v);
      return this;
    };

    /**
     * Sets the connection timeout. `false` to disable
     *
     * @return {Manager} self or value
     * @api public
     */

    Manager.prototype.timeout = function (v) {
      if (!arguments.length) return this._timeout;
      this._timeout = v;
      return this;
    };

    /**
     * Starts trying to reconnect if reconnection is enabled and we have not
     * started reconnecting yet
     *
     * @api private
     */

    Manager.prototype.maybeReconnectOnOpen = function () {
      // Only try to reconnect if it's the first time we're connecting
      if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
        // keeps reconnection from firing twice for the same reconnection loop
        this.reconnect();
      }
    };

    /**
     * Sets the current transport `socket`.
     *
     * @param {Function} optional, callback
     * @return {Manager} self
     * @api public
     */

    Manager.prototype.open =
    Manager.prototype.connect = function (fn, opts) {
      debug('readyState %s', this.readyState);
      if (~this.readyState.indexOf('open')) return this;

      debug('opening %s', this.uri);
      this.engine = eio(this.uri, this.opts);
      var socket = this.engine;
      var self = this;
      this.readyState = 'opening';
      this.skipReconnect = false;

      // emit `open`
      var openSub = on(socket, 'open', function () {
        self.onopen();
        fn && fn();
      });

      // emit `connect_error`
      var errorSub = on(socket, 'error', function (data) {
        debug('connect_error');
        self.cleanup();
        self.readyState = 'closed';
        self.emitAll('connect_error', data);
        if (fn) {
          var err = new Error('Connection error');
          err.data = data;
          fn(err);
        } else {
          // Only do this if there is no fn to handle the error
          self.maybeReconnectOnOpen();
        }
      });

      // emit `connect_timeout`
      if (false !== this._timeout) {
        var timeout = this._timeout;
        debug('connect attempt will timeout after %d', timeout);

        if (timeout === 0) {
          openSub.destroy(); // prevents a race condition with the 'open' event
        }

        // set timer
        var timer = setTimeout(function () {
          debug('connect attempt timed out after %d', timeout);
          openSub.destroy();
          socket.close();
          socket.emit('error', 'timeout');
          self.emitAll('connect_timeout', timeout);
        }, timeout);

        this.subs.push({
          destroy: function () {
            clearTimeout(timer);
          }
        });
      }

      this.subs.push(openSub);
      this.subs.push(errorSub);

      return this;
    };

    /**
     * Called upon transport open.
     *
     * @api private
     */

    Manager.prototype.onopen = function () {
      debug('open');

      // clear old subs
      this.cleanup();

      // mark as open
      this.readyState = 'open';
      this.emit('open');

      // add new subs
      var socket = this.engine;
      this.subs.push(on(socket, 'data', bind$1(this, 'ondata')));
      this.subs.push(on(socket, 'ping', bind$1(this, 'onping')));
      this.subs.push(on(socket, 'pong', bind$1(this, 'onpong')));
      this.subs.push(on(socket, 'error', bind$1(this, 'onerror')));
      this.subs.push(on(socket, 'close', bind$1(this, 'onclose')));
      this.subs.push(on(this.decoder, 'decoded', bind$1(this, 'ondecoded')));
    };

    /**
     * Called upon a ping.
     *
     * @api private
     */

    Manager.prototype.onping = function () {
      this.lastPing = new Date();
      this.emitAll('ping');
    };

    /**
     * Called upon a packet.
     *
     * @api private
     */

    Manager.prototype.onpong = function () {
      this.emitAll('pong', new Date() - this.lastPing);
    };

    /**
     * Called with data.
     *
     * @api private
     */

    Manager.prototype.ondata = function (data) {
      this.decoder.add(data);
    };

    /**
     * Called when parser fully decodes a packet.
     *
     * @api private
     */

    Manager.prototype.ondecoded = function (packet) {
      this.emit('packet', packet);
    };

    /**
     * Called upon socket error.
     *
     * @api private
     */

    Manager.prototype.onerror = function (err) {
      debug('error', err);
      this.emitAll('error', err);
    };

    /**
     * Creates a new socket for the given `nsp`.
     *
     * @return {Socket}
     * @api public
     */

    Manager.prototype.socket = function (nsp, opts) {
      var socket = this.nsps[nsp];
      if (!socket) {
        socket = new Socket(this, nsp, opts);
        this.nsps[nsp] = socket;
        var self = this;
        socket.on('connecting', onConnecting);
        socket.on('connect', function () {
          socket.id = self.generateId(nsp);
        });

        if (this.autoConnect) {
          // manually call here since connecting event is fired before listening
          onConnecting();
        }
      }

      function onConnecting () {
        if (!~indexOf$1(self.connecting, socket)) {
          self.connecting.push(socket);
        }
      }

      return socket;
    };

    /**
     * Called upon a socket close.
     *
     * @param {Socket} socket
     */

    Manager.prototype.destroy = function (socket) {
      var index = indexOf$1(this.connecting, socket);
      if (~index) this.connecting.splice(index, 1);
      if (this.connecting.length) return;

      this.close();
    };

    /**
     * Writes a packet.
     *
     * @param {Object} packet
     * @api private
     */

    Manager.prototype.packet = function (packet) {
      debug('writing packet %j', packet);
      var self = this;
      if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query;

      if (!self.encoding) {
        // encode, then write to engine with result
        self.encoding = true;
        this.encoder.encode(packet, function (encodedPackets) {
          for (var i = 0; i < encodedPackets.length; i++) {
            self.engine.write(encodedPackets[i], packet.options);
          }
          self.encoding = false;
          self.processPacketQueue();
        });
      } else { // add packet to the queue
        self.packetBuffer.push(packet);
      }
    };

    /**
     * If packet buffer is non-empty, begins encoding the
     * next packet in line.
     *
     * @api private
     */

    Manager.prototype.processPacketQueue = function () {
      if (this.packetBuffer.length > 0 && !this.encoding) {
        var pack = this.packetBuffer.shift();
        this.packet(pack);
      }
    };

    /**
     * Clean up transport subscriptions and packet buffer.
     *
     * @api private
     */

    Manager.prototype.cleanup = function () {
      debug('cleanup');

      var subsLength = this.subs.length;
      for (var i = 0; i < subsLength; i++) {
        var sub = this.subs.shift();
        sub.destroy();
      }

      this.packetBuffer = [];
      this.encoding = false;
      this.lastPing = null;

      this.decoder.destroy();
    };

    /**
     * Close the current socket.
     *
     * @api private
     */

    Manager.prototype.close =
    Manager.prototype.disconnect = function () {
      debug('disconnect');
      this.skipReconnect = true;
      this.reconnecting = false;
      if ('opening' === this.readyState) {
        // `onclose` will not fire because
        // an open event never happened
        this.cleanup();
      }
      this.backoff.reset();
      this.readyState = 'closed';
      if (this.engine) this.engine.close();
    };

    /**
     * Called upon engine close.
     *
     * @api private
     */

    Manager.prototype.onclose = function (reason) {
      debug('onclose');

      this.cleanup();
      this.backoff.reset();
      this.readyState = 'closed';
      this.emit('close', reason);

      if (this._reconnection && !this.skipReconnect) {
        this.reconnect();
      }
    };

    /**
     * Attempt a reconnection.
     *
     * @api private
     */

    Manager.prototype.reconnect = function () {
      if (this.reconnecting || this.skipReconnect) return this;

      var self = this;

      if (this.backoff.attempts >= this._reconnectionAttempts) {
        debug('reconnect failed');
        this.backoff.reset();
        this.emitAll('reconnect_failed');
        this.reconnecting = false;
      } else {
        var delay = this.backoff.duration();
        debug('will wait %dms before reconnect attempt', delay);

        this.reconnecting = true;
        var timer = setTimeout(function () {
          if (self.skipReconnect) return;

          debug('attempting reconnect');
          self.emitAll('reconnect_attempt', self.backoff.attempts);
          self.emitAll('reconnecting', self.backoff.attempts);

          // check again for the case socket closed in above events
          if (self.skipReconnect) return;

          self.open(function (err) {
            if (err) {
              debug('reconnect attempt error');
              self.reconnecting = false;
              self.reconnect();
              self.emitAll('reconnect_error', err.data);
            } else {
              debug('reconnect success');
              self.onreconnect();
            }
          });
        }, delay);

        this.subs.push({
          destroy: function () {
            clearTimeout(timer);
          }
        });
      }
    };

    /**
     * Called upon successful reconnect.
     *
     * @api private
     */

    Manager.prototype.onreconnect = function () {
      var attempt = this.backoff.attempts;
      this.reconnecting = false;
      this.backoff.reset();
      this.updateSocketIds();
      this.emitAll('reconnect', attempt);
    };

    (function (module, exports) {
    /**
     * Module dependencies.
     */

    var url = url_1;
    var parser = socket_ioParser;
    var Manager = manager;
    var debug = browser$1.exports('socket.io-client');

    /**
     * Module exports.
     */

    module.exports = exports = lookup;

    /**
     * Managers cache.
     */

    var cache = exports.managers = {};

    /**
     * Looks up an existing `Manager` for multiplexing.
     * If the user summons:
     *
     *   `io('http://localhost/a');`
     *   `io('http://localhost/b');`
     *
     * We reuse the existing instance based on same scheme/port/host,
     * and we initialize sockets for each namespace.
     *
     * @api public
     */

    function lookup (uri, opts) {
      if (typeof uri === 'object') {
        opts = uri;
        uri = undefined;
      }

      opts = opts || {};

      var parsed = url(uri);
      var source = parsed.source;
      var id = parsed.id;
      var path = parsed.path;
      var sameNamespace = cache[id] && path in cache[id].nsps;
      var newConnection = opts.forceNew || opts['force new connection'] ||
                          false === opts.multiplex || sameNamespace;

      var io;

      if (newConnection) {
        debug('ignoring socket cache for %s', source);
        io = Manager(source, opts);
      } else {
        if (!cache[id]) {
          debug('new io instance for %s', source);
          cache[id] = Manager(source, opts);
        }
        io = cache[id];
      }
      if (parsed.query && !opts.query) {
        opts.query = parsed.query;
      }
      return io.socket(parsed.path, opts);
    }

    /**
     * Protocol version.
     *
     * @api public
     */

    exports.protocol = parser.protocol;

    /**
     * `connect`.
     *
     * @param {String} uri
     * @api public
     */

    exports.connect = lookup;

    /**
     * Expose constructors for standalone build.
     *
     * @api public
     */

    exports.Manager = manager;
    exports.Socket = socket.exports;
    }(lib$1, lib$1.exports));

    var __awaiter$6 = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(BaseServiceClient$1, "__esModule", { value: true });
    BaseServiceClient$1.BaseServiceClient = void 0;
    const SocketIOTopicServiceClientProxy_1 = SocketIOTopicServiceClientProxy$1;
    const socket_io_client_1 = __importDefault(lib$1.exports);
    class BaseServiceClient {
        constructor(url, service) {
            this.url = url;
            this.service = service;
        }
        getOrCreateTopicServiceClient(socketIoUrl, env) {
            return __awaiter$6(this, void 0, void 0, function* () {
                if (!BaseServiceClient.topicServiceClient) {
                    let socket = socket_io_client_1.default(socketIoUrl, {
                        transports: ['websocket'],
                        rejectUnauthorized: !(env === 'dev')
                    });
                    BaseServiceClient.topicServiceClient = new SocketIOTopicServiceClientProxy_1.SocketIOTopicServiceClientProxy(socket);
                    BaseServiceClient.topicServiceClient.readyHandler = () => {
                        if (BaseServiceClient.topicServiceClient)
                            BaseServiceClient.topicServiceClient.isReady = true;
                    };
                }
                return BaseServiceClient.topicServiceClient;
            });
        }
        subscribeToTopic(topic, handler, addNewHandler = false) {
            var _a, _b;
            return __awaiter$6(this, void 0, void 0, function* () {
                const subscribe = () => __awaiter$6(this, void 0, void 0, function* () {
                    var _c;
                    yield ((_c = BaseServiceClient.topicServiceClient) === null || _c === void 0 ? void 0 : _c.subscribe(topic, (t, m) => __awaiter$6(this, void 0, void 0, function* () {
                        try {
                            yield handler(m.content);
                        }
                        catch (error) {
                            console.error(error);
                        }
                    })));
                });
                if (typeof handler === 'function') {
                    if (BaseServiceClient.topicServiceClient && BaseServiceClient.topicServiceClient.isReady) {
                        if ((((_a = BaseServiceClient.topicServiceClient.subscriptions) === null || _a === void 0 ? void 0 : _a.indexOf(topic)) >= 0 && addNewHandler) ||
                            ((_b = BaseServiceClient.topicServiceClient.subscriptions) === null || _b === void 0 ? void 0 : _b.indexOf(topic)) < 0) {
                            yield subscribe();
                        }
                    }
                    else {
                        window.setTimeout(() => __awaiter$6(this, void 0, void 0, function* () {
                            console.log(`retrying subscribe to ${topic} ...`);
                            yield this.subscribeToTopic(topic, handler, addNewHandler);
                        }), 2000);
                    }
                }
            });
        }
        createHeaders(request) {
            request.withCredentials = true;
            request.setRequestHeader('Content-Type', 'application/json');
            request.setRequestHeader("Cache-Control", "no-cache, no-store, max-age=0");
        }
        create(entity) {
            return __awaiter$6(this, void 0, void 0, function* () {
                const request = new XMLHttpRequest();
                request.open('POST', `${this.url}/${this.service}`, true);
                const requestPromise = new Promise((resolve, reject) => {
                    this.createHeaders(request);
                    request.onreadystatechange = () => {
                        if (request.readyState === 4) {
                            if (request.status === 201 || request.status === 200)
                                resolve(JSON.parse(request.responseText));
                            else
                                reject(new Error(`Error ${request.status} : ${request.responseText}`));
                        }
                    };
                    request.send(JSON.stringify(entity));
                });
                return yield requestPromise;
            });
        }
        update(entity) {
            return __awaiter$6(this, void 0, void 0, function* () {
                const request = new XMLHttpRequest();
                request.open('PUT', `${this.url}/${this.service}/${entity.id}`, true);
                const requestPromise = new Promise((resolve, reject) => {
                    this.createHeaders(request);
                    request.onreadystatechange = () => {
                        if (request.readyState === 4) {
                            if (request.status === 200 || request.status === 201)
                                resolve(JSON.parse(request.responseText));
                            else {
                                try {
                                    reject(JSON.parse(request.responseText));
                                }
                                catch (error) {
                                    reject(new Error(`${request.status} : ${request.responseText}`));
                                }
                            }
                        }
                    };
                    request.send(JSON.stringify(entity));
                });
                return yield requestPromise;
            });
        }
        get(entityKeyOrId) {
            return __awaiter$6(this, void 0, void 0, function* () {
                const request = new XMLHttpRequest();
                const params = typeof entityKeyOrId === 'string' ?
                    new URLSearchParams() :
                    undefined;
                if (params)
                    params.append('key', entityKeyOrId.toString());
                const url = params ?
                    `${this.url}/${this.service}?${params.toString()}` :
                    `${this.url}/${this.service}/${entityKeyOrId}`;
                request.open('GET', url, true);
                const requestPromise = new Promise((resolve, reject) => {
                    this.createHeaders(request);
                    request.onreadystatechange = () => {
                        if (request.readyState === 4) {
                            if (request.status === 200) {
                                const found = JSON.parse(request.responseText);
                                if (Array.isArray(found) && found.length > 0) {
                                    resolve(found[0]);
                                }
                                else
                                    resolve(found);
                            }
                            else
                                reject(new Error(`Error ${request.status} : ${request.responseText}`));
                        }
                    };
                    request.send();
                });
                return this.makeReadable(yield requestPromise);
            });
        }
        find(entityFilter) {
            return __awaiter$6(this, void 0, void 0, function* () {
                const request = new XMLHttpRequest();
                const params = entityFilter ?
                    new URLSearchParams() :
                    undefined;
                if (params && entityFilter)
                    for (const propName in entityFilter) {
                        if (entityFilter.hasOwnProperty(propName)) {
                            if (entityFilter[propName] instanceof Date) {
                                const date = entityFilter[propName];
                                params.append(propName, date.getTime().toString());
                            }
                            else {
                                params.append(propName, entityFilter[propName].toString());
                            }
                        }
                    }
                const url = params ?
                    `${this.url}/${this.service}?${params.toString()}` :
                    `${this.url}/${this.service}`;
                request.open('GET', url, true);
                const requestPromise = new Promise((resolve, reject) => {
                    this.createHeaders(request);
                    request.onreadystatechange = () => {
                        if (request.readyState === 4) {
                            if (request.status === 200)
                                resolve(JSON.parse(request.responseText));
                            else
                                reject(new Error(`Error ${request.status} : ${request.responseText}`));
                        }
                    };
                    request.send();
                });
                const found = yield requestPromise;
                for (let e of found) {
                    this.makeReadable(e);
                }
                return found;
            });
        }
        delete(entityKeyOrId) {
            return __awaiter$6(this, void 0, void 0, function* () {
                const request = new XMLHttpRequest();
                let id = typeof entityKeyOrId === 'number' ?
                    entityKeyOrId :
                    (yield this.get(entityKeyOrId)).id;
                const url = `${this.url}/${this.service}/${id}`;
                request.open('DELETE', url, true);
                const requestPromise = new Promise((resolve, reject) => {
                    this.createHeaders(request);
                    request.onreadystatechange = () => {
                        if (request.readyState === 4) {
                            if (request.status === 200)
                                resolve(JSON.parse(request.responseText));
                            else
                                reject(new Error(`Error ${request.status} : ${request.responseText}`));
                        }
                    };
                    request.send();
                });
                return yield requestPromise;
            });
        }
        makeReadable(entity) {
            return entity;
        }
    }
    BaseServiceClient$1.BaseServiceClient = BaseServiceClient;

    var dist = {};

    var helpers = {};

    Object.defineProperty(helpers, "__esModule", { value: true });
    helpers.isNumber = void 0;
    function isNumber$1(toTest) {
        if (typeof toTest === 'number')
            return true;
        if (toTest !== null && typeof toTest !== 'undefined') {
            const regexpIsNumber = /^[0-9]+$/g;
            return regexpIsNumber.test(toTest.toString());
        }
        return false;
    }
    helpers.isNumber = isNumber$1;

    var Errors = {};

    var AlreadyExistsError$1 = {};

    Object.defineProperty(AlreadyExistsError$1, "__esModule", { value: true });
    AlreadyExistsError$1.AlreadyExistsError = void 0;
    class AlreadyExistsError extends Error {
        constructor(message = 'Entity already exists') {
            super(message);
        }
    }
    AlreadyExistsError$1.AlreadyExistsError = AlreadyExistsError;

    var InvalidAuthenticationError$1 = {};

    Object.defineProperty(InvalidAuthenticationError$1, "__esModule", { value: true });
    InvalidAuthenticationError$1.InvalidAuthenticationError = void 0;
    class InvalidAuthenticationError extends Error {
        constructor(msg = 'Your authentication is invalid.') {
            super(msg);
        }
    }
    InvalidAuthenticationError$1.InvalidAuthenticationError = InvalidAuthenticationError;

    var InvalidKeyError$1 = {};

    Object.defineProperty(InvalidKeyError$1, "__esModule", { value: true });
    InvalidKeyError$1.InvalidKeyError = void 0;
    class InvalidKeyError extends Error {
        constructor(message = 'Key is invalid') {
            super(message);
        }
    }
    InvalidKeyError$1.InvalidKeyError = InvalidKeyError;

    var NotAuthorizedError$1 = {};

    Object.defineProperty(NotAuthorizedError$1, "__esModule", { value: true });
    NotAuthorizedError$1.NotAuthorizedError = void 0;
    class NotAuthorizedError extends Error {
        constructor(message = 'Not Authorized Error') {
            super(message);
        }
    }
    NotAuthorizedError$1.NotAuthorizedError = NotAuthorizedError;

    var NotFoundError$1 = {};

    Object.defineProperty(NotFoundError$1, "__esModule", { value: true });
    NotFoundError$1.NotFoundError = void 0;
    class NotFoundError extends Error {
        constructor(message = 'Entity not found') {
            super(message);
        }
    }
    NotFoundError$1.NotFoundError = NotFoundError;

    var NotImplementedError$1 = {};

    Object.defineProperty(NotImplementedError$1, "__esModule", { value: true });
    NotImplementedError$1.NotImplementedError = void 0;
    class NotImplementedError extends Error {
        constructor(message = 'Method is not implemented') {
            super(message);
        }
    }
    NotImplementedError$1.NotImplementedError = NotImplementedError;

    var InvalidDataError$1 = {};

    Object.defineProperty(InvalidDataError$1, "__esModule", { value: true });
    InvalidDataError$1.InvalidDataError = void 0;
    class InvalidDataError extends Error {
        constructor(msg = 'The Data is invalid.') {
            super(msg);
        }
    }
    InvalidDataError$1.InvalidDataError = InvalidDataError;

    (function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InvalidDataError = exports.NotImplementedError = exports.NotFoundError = exports.NotAuthorizedError = exports.InvalidKeyError = exports.InvalidAuthenticationError = exports.AlreadyExistsError = void 0;
    var AlreadyExistsError_1 = AlreadyExistsError$1;
    Object.defineProperty(exports, "AlreadyExistsError", { enumerable: true, get: function () { return AlreadyExistsError_1.AlreadyExistsError; } });
    var InvalidAuthenticationError_1 = InvalidAuthenticationError$1;
    Object.defineProperty(exports, "InvalidAuthenticationError", { enumerable: true, get: function () { return InvalidAuthenticationError_1.InvalidAuthenticationError; } });
    var InvalidKeyError_1 = InvalidKeyError$1;
    Object.defineProperty(exports, "InvalidKeyError", { enumerable: true, get: function () { return InvalidKeyError_1.InvalidKeyError; } });
    var NotAuthorizedError_1 = NotAuthorizedError$1;
    Object.defineProperty(exports, "NotAuthorizedError", { enumerable: true, get: function () { return NotAuthorizedError_1.NotAuthorizedError; } });
    var NotFoundError_1 = NotFoundError$1;
    Object.defineProperty(exports, "NotFoundError", { enumerable: true, get: function () { return NotFoundError_1.NotFoundError; } });
    var NotImplementedError_1 = NotImplementedError$1;
    Object.defineProperty(exports, "NotImplementedError", { enumerable: true, get: function () { return NotImplementedError_1.NotImplementedError; } });
    var InvalidDataError_1 = InvalidDataError$1;
    Object.defineProperty(exports, "InvalidDataError", { enumerable: true, get: function () { return InvalidDataError_1.InvalidDataError; } });
    }(Errors));

    var Channel = {};

    var Entity = {};

    Object.defineProperty(Entity, "__esModule", { value: true });
    Entity.EntityFields = void 0;
    Entity.EntityFields = [
        {
            name: 'id',
            label: 'Id',
            type: 'number',
            visible: true,
            description: 'Identifiant unique',
            editable: false,
            masked: false
        },
        {
            name: 'isReader',
            label: 'Lecteur',
            type: 'boolean',
            visible: false,
            description: 'Indique si l\'utilisateur courant est lecteur de la donnée',
            editable: false,
            masked: false
        },
        {
            name: 'isEditor',
            label: 'Editeur',
            type: 'boolean',
            visible: false,
            description: 'Indique si l\'utilisateur courant est Editeur de la donnée',
            editable: false,
            masked: false
        }
    ];

    Object.defineProperty(Channel, "__esModule", { value: true });
    Channel.Meta = Channel.ChannelVisibility = void 0;
    const Entity_1$a = Entity;
    Channel.ChannelVisibility = {
        public: "public",
        protected: "protected",
        private: "private"
    };
    Channel.Meta = {
        label: 'Canaux',
        name: 'channel',
        fields: [
            ...Entity_1$a.EntityFields,
            {
                name: 'key',
                label: 'Clé',
                type: 'string',
                visible: true,
                editable: true,
                description: 'Clé unique du Canal',
                masked: false
            },
            {
                name: 'visibility',
                label: 'Visibilité',
                type: 'string',
                visible: true,
                editable: true,
                description: 'Visibilité du canal',
                masked: false
            },
            {
                name: 'label',
                label: 'Label',
                type: 'string',
                visible: true,
                editable: true,
                description: 'Label du Canal',
                masked: false
            },
            {
                name: 'readers',
                label: 'Lecteurs',
                type: 'array:role',
                visible: true,
                editable: true,
                description: 'Liste des identifiants de roles lecteurs du canal',
                masked: false
            },
            {
                name: 'contributors',
                label: 'Contributeurs',
                type: 'array:role',
                visible: true,
                editable: true,
                description: 'Liste des identifiants de roles contributeurs du canal',
                masked: false
            },
            {
                name: 'editors',
                label: 'Editeurs',
                type: 'array:role',
                visible: true,
                editable: true,
                description: 'Liste des identifiants de roles Editeurs du canal',
                masked: false
            },
            {
                name: 'administrators',
                label: 'Administrateurs',
                type: 'array:role',
                visible: true,
                editable: true,
                description: 'Liste des identifiants de roles Administrateurs du canal',
                masked: false
            }
        ]
    };

    var Document = {};

    Object.defineProperty(Document, "__esModule", { value: true });
    Document.Meta = Document.DocumentVisibility = void 0;
    const Entity_1$9 = Entity;
    Document.DocumentVisibility = {
        public: "public",
        protected: "protected",
        private: "private"
    };
    Document.Meta = {
        label: 'Documents',
        name: 'document',
        fields: [
            ...Entity_1$9.EntityFields,
            {
                name: 'key',
                type: 'string',
                visible: true,
                editable: true,
                description: 'Clé unique du document',
                label: 'Clé',
                masked: false
            },
            {
                name: 'content',
                type: 'object',
                visible: false,
                editable: false,
                description: 'Contenu et structure du document',
                label: 'Contenu',
                masked: false
            },
            {
                name: 'visibility',
                type: 'string',
                visible: true,
                editable: true,
                label: 'Visibilité',
                description: 'Visibilité du document',
                masked: false
            },
            {
                name: 'ownerId',
                label: 'Propriétaire',
                description: 'Identifiant du créateur/propriétaire du document',
                visible: true,
                editable: false,
                type: 'user',
                masked: false
            },
            {
                name: 'documentType',
                visible: true,
                editable: true,
                description: 'Type du document',
                type: 'string',
                label: 'Type',
                masked: false
            },
            {
                name: 'editorRoles',
                type: 'array:role',
                label: 'Roles d\'édition',
                description: 'Roles pouvant éditer le document',
                visible: true,
                editable: true,
                masked: false
            },
            {
                name: 'editor',
                type: 'array:user',
                label: 'Editeurs',
                description: 'Identifiants des utilisateurs pouvant éditer le document',
                visible: true,
                editable: true,
                masked: false
            },
            {
                name: 'readerRoles',
                type: 'array:role',
                label: 'Roles lecteurs',
                description: 'Roles pouvant lire le document',
                visible: true,
                editable: true,
                masked: false
            },
            {
                name: 'readers',
                type: 'array:user',
                label: 'Lecteurs',
                description: 'Identifiants des utilisateurs pouvant lire le document',
                visible: true,
                editable: true,
                masked: false
            },
            {
                name: 'creationDate',
                type: 'date',
                label: 'Date de création',
                description: 'Date de création du document',
                visible: true,
                editable: true,
                masked: false
            },
            {
                name: 'updateDate',
                type: 'date',
                label: 'Date de Mise à jour',
                description: 'Date de mise à jour du document',
                visible: true,
                editable: true,
                masked: false
            }
        ]
    };

    var Media = {};

    Object.defineProperty(Media, "__esModule", { value: true });
    Media.Meta = Media.MediaVisibility = void 0;
    const Entity_1$8 = Entity;
    Media.MediaVisibility = {
        public: "public",
        protected: "protected",
        private: "private"
    };
    Media.Meta = {
        label: 'Média',
        name: 'media',
        fields: [
            ...Entity_1$8.EntityFields,
            {
                name: 'visibility',
                type: 'string',
                visible: true,
                editable: true,
                description: 'Visibilité du media',
                label: 'Visibilité',
                masked: false
            },
            {
                name: 'key',
                label: 'Clé',
                type: 'string',
                visible: true,
                editable: true,
                description: 'Clé unique du media',
                masked: false
            },
            {
                name: 'label',
                label: 'Label',
                type: 'string',
                visible: true,
                editable: true,
                description: 'Label du media',
                masked: false
            },
            {
                name: 'mediaType',
                type: 'string',
                visible: true,
                editable: true,
                description: 'Mime type du Média',
                label: 'MimeType',
                masked: false
            },
            {
                name: 'storagePath',
                label: 'Chemin',
                type: 'string',
                visible: true,
                editable: false,
                description: 'Chemin de stockage local du media',
                masked: false
            },
            {
                name: 'ownerId',
                type: 'user',
                visible: true,
                editable: false,
                description: 'Identifiant du propriétaire du media',
                label: 'Propriétaire',
                masked: false
            },
            {
                name: 'readers',
                type: 'array:role',
                visible: true,
                editable: true,
                description: 'Identifiants des roles lecteurs du media',
                label: 'Roles lecteurs',
                masked: false
            },
            {
                name: 'blob',
                type: 'object',
                visible: false,
                editable: false,
                label: 'Contenu',
                description: 'Contenu du media',
                masked: false
            },
            {
                name: 'tags',
                type: 'array:string',
                visible: true,
                editable: true,
                description: 'List des étiquettes associés au média',
                label: 'Etiquettes',
                masked: false
            }
        ]
    };

    var UserEvent = {};

    Object.defineProperty(UserEvent, "__esModule", { value: true });
    UserEvent.Meta = UserEvent.UserAvailabilityStatus = UserEvent.UserEventVisibility = void 0;
    const Entity_1$7 = Entity;
    UserEvent.UserEventVisibility = {
        protected: "protected",
        private: "private",
        isValidVisibility(visibility) {
            return visibility === this.protected ||
                visibility === this.private;
        }
    };
    UserEvent.UserAvailabilityStatus = {
        busy: "busy",
        available: "available",
        isValidAvailability(ownerAvailabilityStatus) {
            return ownerAvailabilityStatus === this.busy ||
                ownerAvailabilityStatus === this.available;
        }
    };
    UserEvent.Meta = {
        name: 'user-event',
        label: 'Evènements',
        fields: [
            ...Entity_1$7.EntityFields,
            {
                name: 'startDate',
                type: 'date',
                visible: true,
                editable: true,
                description: 'Date de début de l\'évènement',
                label: 'Début',
                masked: false
            },
            {
                name: 'endDate',
                type: 'date',
                visible: true,
                editable: true,
                description: 'Date de fin de l\'évènement',
                label: 'Fin',
                masked: false
            },
            {
                name: 'ownerId',
                label: 'Propriétaire',
                type: 'user',
                description: 'Identifiant unique du propriétaire',
                visible: true,
                editable: false,
                masked: false
            },
            {
                name: 'category',
                label: 'Catégorie',
                type: 'string',
                description: 'Catégorie de l\'évènement',
                visible: true,
                editable: true,
                masked: false
            },
            {
                name: 'ownerAvailabilityStatus',
                label: 'Disponibilité',
                type: 'string',
                description: 'Disponibilité du propriétaire de l\'évènement',
                visible: true,
                editable: true,
                masked: false
            },
            {
                name: 'description',
                label: 'Description',
                type: 'string',
                visible: true,
                editable: true,
                description: 'Description de l\'évènement',
                masked: false
            },
            {
                name: 'label',
                label: 'Label',
                type: 'string',
                visible: true,
                editable: true,
                description: 'Label du media',
                masked: false
            },
            {
                name: 'visibility',
                type: 'string',
                visible: true,
                editable: true,
                label: 'Visibilité',
                description: 'Visibilité de l\'évènement',
                masked: false
            },
            {
                name: 'location',
                type: 'string',
                visible: true,
                editable: true,
                label: 'Localisation',
                description: 'Localisation',
                masked: false
            },
            {
                name: 'color',
                type: 'color',
                visible: true,
                editable: true,
                label: 'Couleur',
                description: 'Couleur de l\'évènement',
                masked: false
            }
        ]
    };

    var Authentication$1 = {};

    Object.defineProperty(Authentication$1, "__esModule", { value: true });
    Authentication$1.Meta = void 0;
    const Entity_1$6 = Entity;
    Authentication$1.Meta = {
        label: 'Authentifications',
        name: 'authentication',
        fields: [
            ...Entity_1$6.EntityFields,
            {
                name: 'login',
                label: 'Login',
                type: 'string',
                visible: true,
                description: 'Login',
                editable: false,
                masked: false
            },
            {
                name: 'encryptedToken',
                label: 'Token',
                type: 'string',
                visible: true,
                description: 'Token d\'authentification crypté',
                editable: false,
                masked: false
            },
            {
                name: 'clientUniqueId',
                label: 'Identifiant Client',
                type: 'string',
                visible: true,
                description: 'Identifiant du client',
                editable: false,
                masked: false
            }
        ]
    };

    var Authorization = {};

    Object.defineProperty(Authorization, "__esModule", { value: true });
    Authorization.Meta = void 0;
    const Entity_1$5 = Entity;
    Authorization.Meta = {
        name: 'authorization',
        label: 'Autorisations',
        fields: [
            ...Entity_1$5.EntityFields,
            {
                name: 'on',
                label: 'Catégorie',
                type: 'string',
                visible: true,
                description: 'Opération ou Données',
                editable: true,
                masked: false
            },
            {
                name: 'onType',
                label: 'Sous Catégorie',
                type: 'string',
                visible: true,
                description: 'Type d\'opération REST ou type de donnée',
                editable: true,
                masked: false
            },
            {
                name: 'for',
                label: 'Entité',
                type: 'string',
                visible: true,
                description: 'Identifiant de service ou de donnée',
                editable: true,
                masked: false
            },
            {
                name: 'right',
                label: 'Droit',
                type: 'string',
                visible: true,
                description: 'Type de droit : x pour execution, r pour lecture, et w pour écriture',
                editable: true,
                masked: false
            },
            {
                name: 'role',
                label: 'Role',
                type: 'number',
                visible: true,
                description: 'Identifiant du role pour lequel ce droit s\'applique',
                editable: true,
                masked: false
            },
        ]
    };

    var ChannelPost = {};

    Object.defineProperty(ChannelPost, "__esModule", { value: true });
    ChannelPost.Meta = void 0;
    const Entity_1$4 = Entity;
    ChannelPost.Meta = {
        label: 'Publications',
        name: 'channel-post',
        fields: [
            ...Entity_1$4.EntityFields,
            {
                name: 'author',
                label: 'Auteur',
                description: 'Auteur du post ou identifiant de l\'auteur du post',
                type: 'user',
                visible: true,
                editable: false,
                masked: false
            },
            {
                name: 'creationDate',
                label: 'Date de création',
                description: 'Date de création',
                type: 'date',
                visible: true,
                editable: false,
                masked: false
            },
            {
                name: 'channelKey',
                label: 'Clé du canal',
                description: 'Clé du canal du post',
                type: 'string',
                visible: true,
                editable: false,
                masked: false
            },
            {
                name: 'parentPost',
                label: 'Post parent',
                description: 'Identifiant du post parent',
                type: 'number',
                visible: true,
                editable: false,
                masked: false
            },
            {
                name: 'content',
                label: 'Contenu',
                description: 'Contenu du post',
                type: 'string',
                visible: true,
                editable: true,
                masked: false
            },
            {
                name: 'attachments',
                label: 'Pièces jointes',
                description: 'Listes des clés uniques des média liés aux posts',
                type: 'array:string',
                visible: true,
                editable: true,
                masked: false
            },
            {
                name: 'tags',
                label: 'Etiquettes',
                description: 'Etiquettes du post',
                type: 'array:string',
                visible: true,
                editable: true,
                masked: false
            }
        ]
    };

    var Metadata = {};

    Object.defineProperty(Metadata, "__esModule", { value: true });
    Metadata.Meta = void 0;
    const Entity_1$3 = Entity;
    Metadata.Meta = {
        label: 'Métadonnées',
        name: 'metadata',
        fields: [
            ...Entity_1$3.EntityFields,
            {
                name: 'key',
                type: 'string',
                label: 'Clé',
                description: 'Clé unique de la metadonnée',
                visible: true,
                editable: true,
                masked: false
            },
            {
                name: 'value',
                type: 'string',
                visible: true,
                editable: true,
                label: 'Valeur',
                description: 'Valeur de la metadonnée',
                masked: false
            },
            {
                name: 'isPublic',
                label: 'Visibilité',
                type: 'boolean',
                description: 'Visibilité de la métadonnée. Vrai si public, sinon privé',
                visible: true,
                editable: true,
                masked: false
            },
            {
                name: 'ownerType',
                label: 'Type de propriétaire',
                type: 'string',
                visible: true,
                editable: true,
                description: 'Type de propriétaire (user, document, etc ...)',
                masked: false
            },
            {
                name: 'ownerId',
                label: 'Propriétaire',
                type: 'user',
                description: 'Identifiant unique du propriétaire',
                visible: true,
                editable: true,
                masked: false
            }
        ]
    };

    var Project = {};

    Object.defineProperty(Project, "__esModule", { value: true });
    Project.Meta = void 0;
    const Entity_1$2 = Entity;
    Project.Meta = {
        label: 'Projets',
        name: 'project',
        fields: [
            ...Entity_1$2.EntityFields,
            {
                name: 'key',
                label: 'Clé',
                type: 'string',
                visible: true,
                editable: true,
                description: 'Clé unique du projet',
                masked: false
            },
            {
                name: 'label',
                label: 'Label',
                type: 'string',
                visible: true,
                editable: true,
                description: 'Label du projet',
                masked: false
            },
            {
                name: 'description',
                label: 'Description',
                type: 'string',
                visible: true,
                editable: true,
                description: 'Description du projet',
                masked: false
            }
        ]
    };

    var Role = {};

    Object.defineProperty(Role, "__esModule", { value: true });
    Role.Meta = void 0;
    const Entity_1$1 = Entity;
    Role.Meta = {
        label: 'Rôles',
        name: 'role',
        fields: [
            ...Entity_1$1.EntityFields,
            {
                name: 'key',
                type: 'string',
                visible: true,
                editable: true,
                description: 'Clé unique du role',
                label: 'Clé',
                masked: false
            },
            {
                name: 'description',
                label: 'Description',
                type: 'string',
                visible: true,
                editable: true,
                description: 'Description du role',
                masked: false
            },
            {
                name: 'members',
                label: 'Membres',
                type: 'array:user',
                description: 'Membres du role',
                visible: true,
                editable: true,
                masked: false
            },
            {
                name: 'ownerId',
                label: 'Propriétaire',
                type: 'user',
                description: 'Identifiant unique du propriétaire',
                visible: true,
                editable: true,
                masked: false
            },
            {
                name: 'ownerRoles',
                label: 'Propriétaires',
                type: 'array:role',
                description: 'Identifiants unique des roles éditeurs de ce rôle',
                visible: true,
                editable: true,
                masked: false
            },
            {
                name: 'creationDate',
                type: 'date',
                visible: true,
                editable: false,
                label: 'Date de création',
                description: 'Date de création',
                masked: false
            }
        ]
    };

    var User$1 = {};

    Object.defineProperty(User$1, "__esModule", { value: true });
    User$1.Meta = void 0;
    const Entity_1 = Entity;
    User$1.Meta = {
        label: 'Utilisateurs',
        name: 'user',
        fields: [
            ...Entity_1.EntityFields,
            {
                name: 'login',
                label: 'Login',
                editable: false,
                visible: true,
                description: 'Login de l\'utilisateur',
                type: 'string',
                masked: false
            },
            {
                name: 'password',
                label: 'Mot de passe',
                type: 'string',
                visible: true,
                editable: true,
                description: 'Mot de passe',
                masked: true
            },
            {
                name: 'isActive',
                description: 'Indique si l\'utilisateur est considéré comme actif',
                visible: true,
                editable: true,
                type: 'boolean',
                label: 'Actif ?',
                masked: false
            }
        ]
    };

    (function (exports) {
    var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InterfaceMetadata = exports.UserEventVisibility = exports.UserAvailabilityStatus = exports.MediaVisibility = exports.DocumentVisibility = exports.ChannelVisibility = void 0;
    __exportStar(helpers, exports);
    __exportStar(Errors, exports);
    var Channel_1 = Channel;
    Object.defineProperty(exports, "ChannelVisibility", { enumerable: true, get: function () { return Channel_1.ChannelVisibility; } });
    var Document_1 = Document;
    Object.defineProperty(exports, "DocumentVisibility", { enumerable: true, get: function () { return Document_1.DocumentVisibility; } });
    var Media_1 = Media;
    Object.defineProperty(exports, "MediaVisibility", { enumerable: true, get: function () { return Media_1.MediaVisibility; } });
    var UserEvent_1 = UserEvent;
    Object.defineProperty(exports, "UserAvailabilityStatus", { enumerable: true, get: function () { return UserEvent_1.UserAvailabilityStatus; } });
    Object.defineProperty(exports, "UserEventVisibility", { enumerable: true, get: function () { return UserEvent_1.UserEventVisibility; } });
    const Authentication_1 = Authentication$1;
    const Authorization_1 = Authorization;
    const Channel_2 = Channel;
    const ChannelPost_1 = ChannelPost;
    const Document_2 = Document;
    const Media_2 = Media;
    const Metadata_1 = Metadata;
    const Project_1 = Project;
    const Role_1 = Role;
    const User_1 = User$1;
    const UserEvent_2 = UserEvent;
    exports.InterfaceMetadata = {
        authentication: Authentication_1.Meta,
        authorization: Authorization_1.Meta,
        channel: Channel_2.Meta,
        'channel-post': ChannelPost_1.Meta,
        document: Document_2.Meta,
        media: Media_2.Meta,
        metadata: Metadata_1.Meta,
        project: Project_1.Meta,
        role: Role_1.Meta,
        user: User_1.Meta,
        'user-event': UserEvent_2.Meta
    };
    }(dist));

    var __awaiter$5 = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    Object.defineProperty(MediaService$1, "__esModule", { value: true });
    MediaService$1.MediaService = void 0;
    const BaseServiceClient_1$5 = BaseServiceClient$1;
    const dist_1 = dist;
    class MediaService extends BaseServiceClient_1$5.BaseServiceClient {
        constructor(url) {
            super(url, 'media');
        }
        getMedia(keyOrId) {
            return __awaiter$5(this, void 0, void 0, function* () {
                try {
                    if (typeof keyOrId === "number")
                        return yield this.get(keyOrId);
                    else {
                        const metadata = yield this.getMediaMetadata(keyOrId);
                        if (metadata && typeof metadata.id === 'number')
                            return yield this.get(metadata.id);
                        else
                            throw new Error(`No Media with key ${keyOrId}`);
                    }
                }
                catch (error) {
                    console.error(error);
                }
            });
        }
        getMediaMetadata(key) {
            return __awaiter$5(this, void 0, void 0, function* () {
                try {
                    return (yield this.find({
                        key: key
                    }))[0];
                }
                catch (error) {
                    console.error(error);
                }
            });
        }
        findMedia(filter) {
            return __awaiter$5(this, void 0, void 0, function* () {
                try {
                    return yield this.find(filter);
                }
                catch (error) {
                    console.error(error);
                }
            });
        }
        createMedia(file, key, label, visibility, tags = [], readers = []) {
            return __awaiter$5(this, void 0, void 0, function* () {
                try {
                    const b = new Blob([file]);
                    const f = new FormData();
                    f.append('visibility', visibility);
                    f.append('label', label);
                    f.append('key', key);
                    f.append('blob', b);
                    for (const tag of tags) {
                        f.append(`tags[${tags.indexOf(tag)}]`, tag);
                    }
                    for (const readerRoleId of readers) {
                        f.append(`readers[${readers.indexOf(readerRoleId)}]`, readerRoleId);
                    }
                    const request = new XMLHttpRequest();
                    request.open('POST', `${this.url}/${this.service}`, true);
                    const requestPromise = new Promise((resolve, reject) => {
                        request.withCredentials = true;
                        // request.setRequestHeader('Content-Type', 'multipart/form-data; boundary=${data._boundary}')
                        request.onreadystatechange = () => {
                            if (request.readyState === 4) {
                                if (request.status === 201)
                                    resolve(JSON.parse(request.responseText));
                                else
                                    reject(new Error(`Error ${request.status} : ${request.responseText}`));
                            }
                        };
                        request.send(f);
                    });
                    return yield requestPromise;
                }
                catch (error) {
                    throw error;
                }
            });
        }
        create(entity) {
            return __awaiter$5(this, void 0, void 0, function* () {
                throw new dist_1.NotAuthorizedError('This method is not available for media creation. Use createMedia instead.');
            });
        }
        update(entity) {
            return __awaiter$5(this, void 0, void 0, function* () {
                throw new dist_1.NotAuthorizedError('This method is not available for media creation. Use updateMedia instead.');
            });
        }
        updateMedia(key, label, visibility, tags = [], readers = []) {
            return __awaiter$5(this, void 0, void 0, function* () {
                try {
                    const f = {
                        key,
                        visibility,
                        label,
                        tags,
                        readers
                    };
                    const request = new XMLHttpRequest();
                    request.open('PATCH', `${this.url}/${this.service}/${key}`, true);
                    const requestPromise = new Promise((resolve, reject) => {
                        this.createHeaders(request);
                        request.onreadystatechange = () => {
                            if (request.readyState === 4) {
                                if (request.status === 201 || request.status === 200)
                                    resolve(JSON.parse(request.responseText));
                                else
                                    reject(new Error(`Error ${request.status} : ${request.responseText}`));
                            }
                        };
                        request.send(JSON.stringify(f));
                    });
                    return yield requestPromise;
                }
                catch (error) {
                    throw error;
                }
            });
        }
        mediaExists(key) {
            return __awaiter$5(this, void 0, void 0, function* () {
                try {
                    const media = yield this.getMediaMetadata(key);
                    return typeof media !== 'undefined' && media !== null;
                }
                catch (ex) {
                    console.error(ex);
                }
                return false;
            });
        }
    }
    MediaService$1.MediaService = MediaService;
    MediaService.AuthorizedMimeTypes = [
        'image/gif',
        'image/png',
        'image/jpeg',
        'image/bmp',
        'image/webp',
        'image/svg+xml',
        'audio/mp3',
        'audio/mpeg',
        'audio/webm',
        'audio/ogg',
        'audio/aac',
        'audio/wav',
        'video/webm',
        'video/ogg',
        'video/mp4',
        'video/x-msvideo',
        'application/pdf'
    ];

    var PostService$1 = {};

    var __awaiter$4 = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    Object.defineProperty(PostService$1, "__esModule", { value: true });
    PostService$1.PostService = void 0;
    const BaseServiceClient_1$4 = BaseServiceClient$1;
    class PostService extends BaseServiceClient_1$4.BaseServiceClient {
        constructor(url) {
            super(url, 'posts');
        }
        createPost(channelKey, postContent, attachments, parentId) {
            return __awaiter$4(this, void 0, void 0, function* () {
                try {
                    const attachmentsKeys = [];
                    attachments.map((a) => attachmentsKeys.push(a.key));
                    let data;
                    if (typeof parentId !== 'number')
                        data = {
                            content: postContent,
                            attachments: attachmentsKeys
                        };
                    else
                        data = {
                            parentPost: parentId,
                            content: postContent,
                            attachments: attachmentsKeys
                        };
                    const request = new XMLHttpRequest();
                    request.open('POST', `${this.url}/channel/${channelKey}/posts`, true);
                    const requestPromise = new Promise((resolve, reject) => {
                        this.createHeaders(request);
                        request.onreadystatechange = () => {
                            if (request.readyState === 4) {
                                if (request.status === 201 || request.status === 200)
                                    resolve(JSON.parse(request.responseText));
                                else
                                    reject(new Error(`Error ${request.status} : ${request.responseText}`));
                            }
                        };
                        request.send(JSON.stringify(data));
                    });
                    return yield requestPromise;
                }
                catch (error) {
                    console.log(error);
                }
            });
        }
    }
    PostService$1.PostService = PostService;

    var DocumentService = {};

    var NodeCMSFrontEndEvents$1 = {};

    Object.defineProperty(NodeCMSFrontEndEvents$1, "__esModule", { value: true });
    NodeCMSFrontEndEvents$1.NodeCMSFrontEndEvents = void 0;
    class NodeCMSFrontEndEvents {
    }
    NodeCMSFrontEndEvents$1.NodeCMSFrontEndEvents = NodeCMSFrontEndEvents;
    NodeCMSFrontEndEvents.UserAuthenticatedEventName = 'UserAuthenticated';
    NodeCMSFrontEndEvents.UserLogoutEventName = 'UserLogout';

    (function (exports) {
    var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DocumentService = exports.documentsEventName = void 0;
    const BaseServiceClient_1 = BaseServiceClient$1;
    const NodeCMSFrontEndEvents_1 = NodeCMSFrontEndEvents$1;
    const services_factory_1 = servicesFactory;
    exports.documentsEventName = {
        documentsActions: 'documents.actions'
    };
    class DocumentService extends BaseServiceClient_1.BaseServiceClient {
        constructor(url, socketIoHost = '/', env) {
            super(url, 'document');
            this.socketIoUrl = socketIoHost ? socketIoHost : this.url;
            document.addEventListener(NodeCMSFrontEndEvents_1.NodeCMSFrontEndEvents.UserAuthenticatedEventName, () => __awaiter(this, void 0, void 0, function* () {
                this.topicServiceClient = yield this.getOrCreateTopicServiceClient(this.socketIoUrl, env);
                yield this.subscribeToTopic(exports.documentsEventName.documentsActions, (documentAction) => __awaiter(this, void 0, void 0, function* () {
                    document.dispatchEvent(new CustomEvent(exports.documentsEventName.documentsActions, {
                        detail: documentAction
                    }));
                }));
            }));
        }
        findDocument(filter) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const documents = yield this.find(filter);
                    const services = yield services_factory_1.getBackendClient();
                    for (const doc of documents) {
                        const author = yield services.userService.get(doc.ownerId);
                        doc.author = author;
                    }
                    return documents;
                }
                catch (error) {
                    throw (error);
                }
            });
        }
        getDocument(key) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    console.log(`Getting document with key ${key}`);
                    const obtained = yield this.get(key);
                    const services = yield services_factory_1.getBackendClient();
                    if (services.userService.isAuthenticated) {
                        obtained.author = yield services.userService.getUser(obtained.ownerId);
                    }
                    return obtained;
                }
                catch (error) {
                    throw (error);
                }
            });
        }
        exists(key) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return typeof (yield this.get(key)).id === 'number';
                }
                catch (error) {
                }
                return false;
            });
        }
        createDocument(newDocument) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return yield this.create(newDocument);
                }
                catch (error) {
                    throw error;
                }
            });
        }
        updateDocument(documentUpdated) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return yield this.update(documentUpdated);
                }
                catch (error) {
                    throw error;
                }
            });
        }
    }
    exports.DocumentService = DocumentService;
    }(DocumentService));

    var ChannelsService = {};

    var UserService = {};

    // Unique ID creation requires a high quality random # generator. In the browser we therefore
    // require the crypto API and do not support built-in fallback to lower quality random number
    // generators (like Math.random()).
    var getRandomValues;
    var rnds8 = new Uint8Array(16);
    function rng() {
      // lazy load so that environments that need to polyfill have a chance to do so
      if (!getRandomValues) {
        // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
        // find the complete implementation of crypto (msCrypto) on IE11.
        getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

        if (!getRandomValues) {
          throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
        }
      }

      return getRandomValues(rnds8);
    }

    var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

    function validate(uuid) {
      return typeof uuid === 'string' && REGEX.test(uuid);
    }

    /**
     * Convert array of 16 byte values to UUID string format of the form:
     * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
     */

    var byteToHex = [];

    for (var i = 0; i < 256; ++i) {
      byteToHex.push((i + 0x100).toString(16).substr(1));
    }

    function stringify(arr) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      // Note: Be careful editing this code!  It's been tuned for performance
      // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
      var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
      // of the following:
      // - One or more input array values don't map to a hex octet (leading to
      // "undefined" in the uuid)
      // - Invalid input values for the RFC `version` or `variant` fields

      if (!validate(uuid)) {
        throw TypeError('Stringified UUID is invalid');
      }

      return uuid;
    }

    //
    // Inspired by https://github.com/LiosK/UUID.js
    // and http://docs.python.org/library/uuid.html

    var _nodeId;

    var _clockseq; // Previous uuid creation time


    var _lastMSecs = 0;
    var _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

    function v1(options, buf, offset) {
      var i = buf && offset || 0;
      var b = buf || new Array(16);
      options = options || {};
      var node = options.node || _nodeId;
      var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
      // specified.  We do this lazily to minimize issues related to insufficient
      // system entropy.  See #189

      if (node == null || clockseq == null) {
        var seedBytes = options.random || (options.rng || rng)();

        if (node == null) {
          // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
          node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
        }

        if (clockseq == null) {
          // Per 4.2.2, randomize (14 bit) clockseq
          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
        }
      } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
      // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
      // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
      // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


      var msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
      // cycle to simulate higher resolution clock

      var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

      var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

      if (dt < 0 && options.clockseq === undefined) {
        clockseq = clockseq + 1 & 0x3fff;
      } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
      // time interval


      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
        nsecs = 0;
      } // Per 4.2.1.2 Throw error if too many uuids are requested


      if (nsecs >= 10000) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }

      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

      msecs += 12219292800000; // `time_low`

      var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
      b[i++] = tl >>> 24 & 0xff;
      b[i++] = tl >>> 16 & 0xff;
      b[i++] = tl >>> 8 & 0xff;
      b[i++] = tl & 0xff; // `time_mid`

      var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
      b[i++] = tmh >>> 8 & 0xff;
      b[i++] = tmh & 0xff; // `time_high_and_version`

      b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

      b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

      b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

      b[i++] = clockseq & 0xff; // `node`

      for (var n = 0; n < 6; ++n) {
        b[i + n] = node[n];
      }

      return buf || stringify(b);
    }

    function parse(uuid) {
      if (!validate(uuid)) {
        throw TypeError('Invalid UUID');
      }

      var v;
      var arr = new Uint8Array(16); // Parse ########-....-....-....-............

      arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
      arr[1] = v >>> 16 & 0xff;
      arr[2] = v >>> 8 & 0xff;
      arr[3] = v & 0xff; // Parse ........-####-....-....-............

      arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
      arr[5] = v & 0xff; // Parse ........-....-####-....-............

      arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
      arr[7] = v & 0xff; // Parse ........-....-....-####-............

      arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
      arr[9] = v & 0xff; // Parse ........-....-....-....-############
      // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

      arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
      arr[11] = v / 0x100000000 & 0xff;
      arr[12] = v >>> 24 & 0xff;
      arr[13] = v >>> 16 & 0xff;
      arr[14] = v >>> 8 & 0xff;
      arr[15] = v & 0xff;
      return arr;
    }

    function stringToBytes(str) {
      str = unescape(encodeURIComponent(str)); // UTF8 escape

      var bytes = [];

      for (var i = 0; i < str.length; ++i) {
        bytes.push(str.charCodeAt(i));
      }

      return bytes;
    }

    var DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
    var URL$1 = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
    function v35 (name, version, hashfunc) {
      function generateUUID(value, namespace, buf, offset) {
        if (typeof value === 'string') {
          value = stringToBytes(value);
        }

        if (typeof namespace === 'string') {
          namespace = parse(namespace);
        }

        if (namespace.length !== 16) {
          throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
        } // Compute hash of namespace and value, Per 4.3
        // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
        // hashfunc([...namespace, ... value])`


        var bytes = new Uint8Array(16 + value.length);
        bytes.set(namespace);
        bytes.set(value, namespace.length);
        bytes = hashfunc(bytes);
        bytes[6] = bytes[6] & 0x0f | version;
        bytes[8] = bytes[8] & 0x3f | 0x80;

        if (buf) {
          offset = offset || 0;

          for (var i = 0; i < 16; ++i) {
            buf[offset + i] = bytes[i];
          }

          return buf;
        }

        return stringify(bytes);
      } // Function#name is not settable on some platforms (#270)


      try {
        generateUUID.name = name; // eslint-disable-next-line no-empty
      } catch (err) {} // For CommonJS default export support


      generateUUID.DNS = DNS;
      generateUUID.URL = URL$1;
      return generateUUID;
    }

    /*
     * Browser-compatible JavaScript MD5
     *
     * Modification of JavaScript MD5
     * https://github.com/blueimp/JavaScript-MD5
     *
     * Copyright 2011, Sebastian Tschan
     * https://blueimp.net
     *
     * Licensed under the MIT license:
     * https://opensource.org/licenses/MIT
     *
     * Based on
     * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
     * Digest Algorithm, as defined in RFC 1321.
     * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
     * Distributed under the BSD License
     * See http://pajhome.org.uk/crypt/md5 for more info.
     */
    function md5(bytes) {
      if (typeof bytes === 'string') {
        var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

        bytes = new Uint8Array(msg.length);

        for (var i = 0; i < msg.length; ++i) {
          bytes[i] = msg.charCodeAt(i);
        }
      }

      return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
    }
    /*
     * Convert an array of little-endian words to an array of bytes
     */


    function md5ToHexEncodedArray(input) {
      var output = [];
      var length32 = input.length * 32;
      var hexTab = '0123456789abcdef';

      for (var i = 0; i < length32; i += 8) {
        var x = input[i >> 5] >>> i % 32 & 0xff;
        var hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
        output.push(hex);
      }

      return output;
    }
    /**
     * Calculate output length with padding and bit length
     */


    function getOutputLength(inputLength8) {
      return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
    }
    /*
     * Calculate the MD5 of an array of little-endian words, and a bit length.
     */


    function wordsToMd5(x, len) {
      /* append padding */
      x[len >> 5] |= 0x80 << len % 32;
      x[getOutputLength(len) - 1] = len;
      var a = 1732584193;
      var b = -271733879;
      var c = -1732584194;
      var d = 271733878;

      for (var i = 0; i < x.length; i += 16) {
        var olda = a;
        var oldb = b;
        var oldc = c;
        var oldd = d;
        a = md5ff(a, b, c, d, x[i], 7, -680876936);
        d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
        c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
        b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
        a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
        d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
        c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
        b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
        a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
        d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
        c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
        b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
        a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
        d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
        c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
        b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
        a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
        d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
        c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
        b = md5gg(b, c, d, a, x[i], 20, -373897302);
        a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
        d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
        c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
        b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
        a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
        d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
        c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
        b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
        a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
        d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
        c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
        b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
        a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
        d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
        c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
        b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
        a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
        d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
        c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
        b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
        a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
        d = md5hh(d, a, b, c, x[i], 11, -358537222);
        c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
        b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
        a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
        d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
        c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
        b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
        a = md5ii(a, b, c, d, x[i], 6, -198630844);
        d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
        c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
        b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
        a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
        d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
        c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
        b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
        a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
        d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
        c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
        b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
        a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
        d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
        c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
        b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
        a = safeAdd(a, olda);
        b = safeAdd(b, oldb);
        c = safeAdd(c, oldc);
        d = safeAdd(d, oldd);
      }

      return [a, b, c, d];
    }
    /*
     * Convert an array bytes to an array of little-endian words
     * Characters >255 have their high-byte silently ignored.
     */


    function bytesToWords(input) {
      if (input.length === 0) {
        return [];
      }

      var length8 = input.length * 8;
      var output = new Uint32Array(getOutputLength(length8));

      for (var i = 0; i < length8; i += 8) {
        output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
      }

      return output;
    }
    /*
     * Add integers, wrapping at 2^32. This uses 16-bit operations internally
     * to work around bugs in some JS interpreters.
     */


    function safeAdd(x, y) {
      var lsw = (x & 0xffff) + (y & 0xffff);
      var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
      return msw << 16 | lsw & 0xffff;
    }
    /*
     * Bitwise rotate a 32-bit number to the left.
     */


    function bitRotateLeft(num, cnt) {
      return num << cnt | num >>> 32 - cnt;
    }
    /*
     * These functions implement the four basic operations the algorithm uses.
     */


    function md5cmn(q, a, b, x, s, t) {
      return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
    }

    function md5ff(a, b, c, d, x, s, t) {
      return md5cmn(b & c | ~b & d, a, b, x, s, t);
    }

    function md5gg(a, b, c, d, x, s, t) {
      return md5cmn(b & d | c & ~d, a, b, x, s, t);
    }

    function md5hh(a, b, c, d, x, s, t) {
      return md5cmn(b ^ c ^ d, a, b, x, s, t);
    }

    function md5ii(a, b, c, d, x, s, t) {
      return md5cmn(c ^ (b | ~d), a, b, x, s, t);
    }

    var v3 = v35('v3', 0x30, md5);

    function v4(options, buf, offset) {
      options = options || {};
      var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

      rnds[6] = rnds[6] & 0x0f | 0x40;
      rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

      if (buf) {
        offset = offset || 0;

        for (var i = 0; i < 16; ++i) {
          buf[offset + i] = rnds[i];
        }

        return buf;
      }

      return stringify(rnds);
    }

    // Adapted from Chris Veness' SHA1 code at
    // http://www.movable-type.co.uk/scripts/sha1.html
    function f(s, x, y, z) {
      switch (s) {
        case 0:
          return x & y ^ ~x & z;

        case 1:
          return x ^ y ^ z;

        case 2:
          return x & y ^ x & z ^ y & z;

        case 3:
          return x ^ y ^ z;
      }
    }

    function ROTL(x, n) {
      return x << n | x >>> 32 - n;
    }

    function sha1(bytes) {
      var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
      var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

      if (typeof bytes === 'string') {
        var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

        bytes = [];

        for (var i = 0; i < msg.length; ++i) {
          bytes.push(msg.charCodeAt(i));
        }
      } else if (!Array.isArray(bytes)) {
        // Convert Array-like to Array
        bytes = Array.prototype.slice.call(bytes);
      }

      bytes.push(0x80);
      var l = bytes.length / 4 + 2;
      var N = Math.ceil(l / 16);
      var M = new Array(N);

      for (var _i = 0; _i < N; ++_i) {
        var arr = new Uint32Array(16);

        for (var j = 0; j < 16; ++j) {
          arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
        }

        M[_i] = arr;
      }

      M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
      M[N - 1][14] = Math.floor(M[N - 1][14]);
      M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;

      for (var _i2 = 0; _i2 < N; ++_i2) {
        var W = new Uint32Array(80);

        for (var t = 0; t < 16; ++t) {
          W[t] = M[_i2][t];
        }

        for (var _t = 16; _t < 80; ++_t) {
          W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
        }

        var a = H[0];
        var b = H[1];
        var c = H[2];
        var d = H[3];
        var e = H[4];

        for (var _t2 = 0; _t2 < 80; ++_t2) {
          var s = Math.floor(_t2 / 20);
          var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
          e = d;
          d = c;
          c = ROTL(b, 30) >>> 0;
          b = a;
          a = T;
        }

        H[0] = H[0] + a >>> 0;
        H[1] = H[1] + b >>> 0;
        H[2] = H[2] + c >>> 0;
        H[3] = H[3] + d >>> 0;
        H[4] = H[4] + e >>> 0;
      }

      return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
    }

    var v5 = v35('v5', 0x50, sha1);

    var nil = '00000000-0000-0000-0000-000000000000';

    function version$1(uuid) {
      if (!validate(uuid)) {
        throw TypeError('Invalid UUID');
      }

      return parseInt(uuid.substr(14, 1), 16);
    }

    var uuid = /*#__PURE__*/Object.freeze({
        __proto__: null,
        v1: v1,
        v3: v3,
        v4: v4,
        v5: v5,
        NIL: nil,
        version: version$1,
        validate: validate,
        stringify: stringify,
        parse: parse
    });

    var require$$2 = /*@__PURE__*/getAugmentedNamespace(uuid);

    var UserEventService$1 = {};

    var __awaiter$3 = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    Object.defineProperty(UserEventService$1, "__esModule", { value: true });
    UserEventService$1.UserEventService = void 0;
    const BaseServiceClient_1$3 = BaseServiceClient$1;
    class UserEventService extends BaseServiceClient_1$3.BaseServiceClient {
        constructor(url) {
            super(url, 'user-events');
        }
        getUserEvent(id) {
            return __awaiter$3(this, void 0, void 0, function* () {
                return yield this.get(id);
            });
        }
        findUserEvents(ownerId, startDate, endDate) {
            return __awaiter$3(this, void 0, void 0, function* () {
                return yield this.find({
                    ownerId: ownerId,
                    startDate: startDate,
                    endDate: endDate
                });
            });
        }
        makeReadable(entity) {
            if (typeof entity.startDate === 'string') {
                entity.startDate = new Date(entity.startDate);
            }
            if (typeof entity.endDate === 'string') {
                entity.endDate = new Date(entity.endDate);
            }
            return entity;
        }
        updateUserEvent(userEvent) {
            return __awaiter$3(this, void 0, void 0, function* () {
                return yield this.update(userEvent);
            });
        }
    }
    UserEventService$1.UserEventService = UserEventService;

    (function (exports) {
    var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UserService = exports.userEventsEventName = exports.AuthenticationService = void 0;
    const BaseServiceClient_1 = BaseServiceClient$1;
    const NodeCMSFrontEndEvents_1 = NodeCMSFrontEndEvents$1;
    const uuid_1 = require$$2;
    const UserEventService_1 = UserEventService$1;
    class AuthenticationService extends BaseServiceClient_1.BaseServiceClient {
        constructor(url) {
            super(url, 'authentication');
        }
    }
    exports.AuthenticationService = AuthenticationService;
    exports.userEventsEventName = {
        userEventActions: 'user-events.actions'
    };
    class UserService extends BaseServiceClient_1.BaseServiceClient {
        constructor(url, socketIoHost = '/', env) {
            super(url, 'user');
            this.isAuthenticated = false;
            this.authenticationService = new AuthenticationService(this.url);
            this.userEventService = new UserEventService_1.UserEventService(this.url);
            this.socketIoUrl = socketIoHost ? socketIoHost : this.url;
            document.addEventListener(NodeCMSFrontEndEvents_1.NodeCMSFrontEndEvents.UserAuthenticatedEventName, () => __awaiter(this, void 0, void 0, function* () {
                this.topicServiceClient = yield this.getOrCreateTopicServiceClient(this.socketIoUrl, env);
            }));
        }
        getClientUniqueId() {
            let clientId = localStorage.getItem('clientUniqueId');
            if (!clientId) {
                console.log(`adding client unique Id`);
                clientId = uuid_1.v4();
                localStorage.setItem('clientUniqueId', clientId);
            }
            console.log(`client unique Id is ${clientId}`);
            return clientId;
        }
        checkAuthentication() {
            return __awaiter(this, void 0, void 0, function* () {
                const value = yield this.authenticationService.find();
                const authenticateEvent = new Event(NodeCMSFrontEndEvents_1.NodeCMSFrontEndEvents.UserAuthenticatedEventName);
                document.dispatchEvent(authenticateEvent);
                console.log(`authentication : ${value}`);
                this.isAuthenticated = true;
                return value;
            });
        }
        authenticate(login, password) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.authenticationService.create({
                    login,
                    password,
                    clientUniqueId: this.getClientUniqueId()
                });
                this.isAuthenticated = true;
                const authenticateEvent = new Event(NodeCMSFrontEndEvents_1.NodeCMSFrontEndEvents.UserAuthenticatedEventName);
                document.dispatchEvent(authenticateEvent);
            });
        }
        logOut() {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const response = yield this.authenticationService.delete(0);
                    const logoutEvent = new Event(NodeCMSFrontEndEvents_1.NodeCMSFrontEndEvents.UserLogoutEventName);
                }
                catch (error) {
                    console.error(error);
                }
                this.isAuthenticated = false;
            });
        }
        getUser(ownerId) {
            return __awaiter(this, void 0, void 0, function* () {
                return yield this.get(ownerId);
            });
        }
        createUserEvent(userEvent) {
            return __awaiter(this, void 0, void 0, function* () {
                return yield this.userEventService.create(userEvent);
            });
        }
        findUserEvents(login, startDate, endDate) {
            return __awaiter(this, void 0, void 0, function* () {
                const user = yield this.get(login);
                return yield this.userEventService.findUserEvents(user.id, startDate, endDate);
            });
        }
        subscribeToUserEvents(userLogin, handler, addNewHandler = false) {
            return __awaiter(this, void 0, void 0, function* () {
                const userEventsTopic = `${exports.userEventsEventName.userEventActions}.${userLogin}`;
                yield this.subscribeToTopic(userEventsTopic, handler, addNewHandler);
            });
        }
        updateUserEvent(userEvent) {
            return __awaiter(this, void 0, void 0, function* () {
                return yield this.userEventService.updateUserEvent(userEvent);
            });
        }
        getCurrentUser() {
            return __awaiter(this, void 0, void 0, function* () {
                const request = new XMLHttpRequest();
                const params = new URLSearchParams();
                params.append('currentUser', 'true');
                const url = `${this.url}/${this.service}/0?${params.toString()}`;
                request.open('GET', url, true);
                const requestPromise = new Promise((resolve, reject) => {
                    this.createHeaders(request);
                    request.onreadystatechange = () => {
                        if (request.readyState === 4) {
                            if (request.status === 200) {
                                const found = JSON.parse(request.responseText);
                                if (Array.isArray(found) && found.length > 0) {
                                    resolve(found[0]);
                                }
                                else
                                    resolve(found);
                            }
                            else
                                reject(new Error(`Error ${request.status} : ${request.responseText}`));
                        }
                    };
                    request.send();
                });
                return yield requestPromise;
            });
        }
        removeUserEvent(userEvent) {
            return __awaiter(this, void 0, void 0, function* () {
                if (typeof userEvent.id === 'number' || typeof userEvent.id === 'string')
                    return yield this.userEventService.delete(userEvent.id);
                throw new Error('Wrong Id for removing user event : must be of type number or string');
            });
        }
    }
    exports.UserService = UserService;
    }(UserService));

    (function (exports) {
    var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ChannelsService = exports.channelsEventNames = void 0;
    const BaseServiceClient_1 = BaseServiceClient$1;
    const NodeCMSFrontEndEvents_1 = NodeCMSFrontEndEvents$1;
    const UserService_1 = UserService;
    exports.channelsEventNames = {
        channelsActions: 'channels.actions'
    };
    class ChannelsService extends BaseServiceClient_1.BaseServiceClient {
        constructor(url, socketIoHost = '/', env) {
            super(url, 'channel');
            this.socketIoUrl = socketIoHost ? socketIoHost : this.url;
            this.env = env;
            this.userService = new UserService_1.UserService(url);
            document.addEventListener(NodeCMSFrontEndEvents_1.NodeCMSFrontEndEvents.UserAuthenticatedEventName, () => __awaiter(this, void 0, void 0, function* () {
                yield this.subscribeToTopic(exports.channelsEventNames.channelsActions, (channelAction) => __awaiter(this, void 0, void 0, function* () {
                    document.dispatchEvent(new CustomEvent(exports.channelsEventNames.channelsActions, { detail: channelAction }));
                }));
                window.cmsClient = this;
            }));
            document.addEventListener(NodeCMSFrontEndEvents_1.NodeCMSFrontEndEvents.UserLogoutEventName, this.onLogOut.bind(this));
        }
        onLogOut() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this.topicServiceClient) {
                    this.topicServiceClient.socket.close();
                    this.topicServiceClient = undefined;
                }
            });
        }
        getChannel(channelName) {
            return __awaiter(this, void 0, void 0, function* () {
                return yield this.get(channelName);
            });
        }
        getChannelPosts(channelName, filter, lastPostId) {
            return __awaiter(this, void 0, void 0, function* () {
                const request = new XMLHttpRequest();
                const params = Object.assign(Object.assign({}, filter), { lastIndex: lastPostId });
                const p = new URLSearchParams();
                let paramsCount = 0;
                if (params) {
                    for (const filter in params) {
                        if (params.hasOwnProperty(filter) &&
                            typeof params[filter] !== 'undefined') {
                            p.append(filter, params[filter].toString());
                            paramsCount++;
                        }
                    }
                }
                const url = paramsCount > 0 ?
                    `${this.url}/channel/${channelName}/posts?${p.toString()}` :
                    `${this.url}/channel/${channelName}/posts`;
                request.open('GET', url, true);
                const requestPromise = new Promise((resolve, reject) => {
                    this.createHeaders(request);
                    request.onreadystatechange = () => {
                        if (request.readyState === 4) {
                            if (request.status === 200)
                                resolve(JSON.parse(request.responseText));
                            else
                                reject(new Error(`Error ${request.status} : ${request.responseText}`));
                        }
                    };
                    request.send();
                });
                const posts = yield requestPromise;
                for (const p of posts) {
                    if (typeof p.parentPost !== 'number' && p.channelKey && typeof p.id === 'number') {
                        p.answerCount = yield this.getChildrenPostsCount(p.channelKey, p.id);
                    }
                }
                return posts;
            });
        }
        subscribeToChannel(channelKey, handler, addNewHandler = false) {
            return __awaiter(this, void 0, void 0, function* () {
                const channelTopic = `channels.${channelKey}.posts`;
                yield this.subscribeToTopic(channelTopic, handler, addNewHandler);
            });
        }
        getAvailableChannels() {
            return __awaiter(this, void 0, void 0, function* () {
                return yield this.find();
            });
        }
        exists(channelKeyOrId) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return typeof (yield this.get(channelKeyOrId)).id === 'number';
                }
                catch (error) {
                }
                return false;
            });
        }
        createChannel(channel) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return this.create(channel);
                }
                catch (error) {
                    console.error(error);
                    console.log(error.response);
                    if (error.response) {
                        throw new Error(error.response.message);
                    }
                    else {
                        throw error;
                    }
                }
            });
        }
        getChildrenPosts(channelKey, parentPostId, lastPostId) {
            return __awaiter(this, void 0, void 0, function* () {
                return yield this.getChannelPosts(channelKey, {
                    parentPost: parentPostId
                }, lastPostId);
            });
        }
        getChildrenPostsCount(channelKey, id) {
            return __awaiter(this, void 0, void 0, function* () {
                let count = 0;
                let children = [];
                let lastChildrenId = undefined;
                do {
                    children = (yield this.getChildrenPosts(channelKey, id, lastChildrenId));
                    if (children.length > 0) {
                        lastChildrenId = children[children.length - 1].id;
                        count += children.length;
                    }
                } while (children.length > 0);
                return count;
            });
        }
    }
    exports.ChannelsService = ChannelsService;
    }(ChannelsService));

    var UtilsService$1 = {};

    var __awaiter$2 = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    Object.defineProperty(UtilsService$1, "__esModule", { value: true });
    UtilsService$1.UtilsService = void 0;
    const BaseServiceClient_1$2 = BaseServiceClient$1;
    class UtilsService extends BaseServiceClient_1$2.BaseServiceClient {
        constructor(url) {
            super(url, 'webthumbnail');
        }
        getWebsiteThumbnail(URL) {
            return __awaiter$2(this, void 0, void 0, function* () {
                try {
                    return yield this.get(URL);
                }
                catch (error) {
                    console.error(error);
                }
                return null;
            });
        }
    }
    UtilsService$1.UtilsService = UtilsService;

    var MetadataService$1 = {};

    Object.defineProperty(MetadataService$1, "__esModule", { value: true });
    MetadataService$1.MetadataService = void 0;
    const BaseServiceClient_1$1 = BaseServiceClient$1;
    class MetadataService extends BaseServiceClient_1$1.BaseServiceClient {
        constructor(url) {
            super(url, 'metadata');
        }
    }
    MetadataService$1.MetadataService = MetadataService;

    var __awaiter$1 = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    Object.defineProperty(NodeCMSClient$1, "__esModule", { value: true });
    NodeCMSClient$1.NodeCMSClient = void 0;
    //@ts-ignore
    const MediaService_1 = MediaService$1;
    const PostService_1 = PostService$1;
    const DocumentService_1 = DocumentService;
    const ChannelsService_1 = ChannelsService;
    const UserService_1 = UserService;
    const UtilsService_1 = UtilsService$1;
    const MetadataService_1 = MetadataService$1;
    const UserEventService_1 = UserEventService$1;
    class NodeCMSClient {
        constructor(cmsUrl = "/", socketIoHost = "/", env) {
            this.url = cmsUrl;
            this.env = env;
            this.services = {};
            this.mediaService = new MediaService_1.MediaService(this.url);
            this.registerNewClientService('media', this.mediaService);
            this.postService = new PostService_1.PostService(this.url);
            this.registerNewClientService('channel-post', this.postService);
            this.documentService = new DocumentService_1.DocumentService(this.url, socketIoHost, this.env);
            this.registerNewClientService('document', this.documentService);
            this.channelsService = new ChannelsService_1.ChannelsService(this.url, socketIoHost, this.env);
            this.registerNewClientService('channel', this.channelsService);
            this.userService = new UserService_1.UserService(this.url);
            this.registerNewClientService('user', this.userService);
            this.utilsService = new UtilsService_1.UtilsService(this.url);
            this.registerNewClientService('utils', this.utilsService);
            this.metadataService = new MetadataService_1.MetadataService(this.url);
            this.registerNewClientService('metadata', this.metadataService);
            this.userEventService = new UserEventService_1.UserEventService(this.url);
            this.registerNewClientService('user-event', this.userEventService);
        }
        getMetadata(key) {
            return __awaiter$1(this, void 0, void 0, function* () {
                return yield this.metadataService.get(key);
            });
        }
        registerNewClientService(serviceLabel, service) {
            this.services[serviceLabel] = service;
        }
        getService(serviceLabel) {
            return this.services[serviceLabel];
        }
        getDataService(serviceLabel) {
            return this.services[serviceLabel];
        }
    }
    NodeCMSClient$1.NodeCMSClient = NodeCMSClient;

    var AttachmentHelpers$1 = {};

    Object.defineProperty(AttachmentHelpers$1, "__esModule", { value: true });
    AttachmentHelpers$1.AttachmentHelpers = void 0;
    class AttachmentHelpers {
        static getImageUrl(media) {
            return `url(${AttachmentHelpers.getDownloadUrl(media)})`;
        }
        static getDownloadUrl(media) {
            const localBuffer = new Uint8Array(media.blob.data);
            const blob = new Blob([localBuffer], { type: media.mediaType });
            return URL.createObjectURL(blob);
        }
    }
    AttachmentHelpers$1.AttachmentHelpers = AttachmentHelpers;

    var ProjectsService$1 = {};

    var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    Object.defineProperty(ProjectsService$1, "__esModule", { value: true });
    ProjectsService$1.ProjectsService = void 0;
    const BaseServiceClient_1 = BaseServiceClient$1;
    //TODO : Move this to extensions projects
    class ProjectsService extends BaseServiceClient_1.BaseServiceClient {
        constructor(url) {
            super(url, 'project');
            this.projects = new Array();
        }
        getRandomInt(max) {
            let nextId = Math.floor(Math.random() * Math.floor(max));
            while (this.projects.find(p => p.id === nextId)) {
                nextId = Math.floor(Math.random() * Math.floor(max));
            }
            return nextId;
        }
        createProject(label, key, description) {
            return __awaiter(this, void 0, void 0, function* () {
                const p = {
                    label: '',
                    key: '',
                    description: ''
                };
                p.key = key;
                p.id = this.getRandomInt(10000);
                p.description = description ? description : '';
                p.label = label;
                this.projects.push(p);
                console.log(this);
                return p;
            });
        }
        exists(value) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.projects.findIndex(p => p.key === value) >= 0;
            });
        }
    }
    ProjectsService$1.ProjectsService = ProjectsService;

    var TempCache$1 = {};

    Object.defineProperty(TempCache$1, "__esModule", { value: true });
    TempCache$1.TempCache = void 0;
    class TempCache {
        constructor() {
            this.innerCache = {};
        }
        put(key, data) {
            this.innerCache[key] = data;
        }
        get(key) {
            const data = this.innerCache[key];
            return data;
        }
    }
    TempCache$1.TempCache = TempCache;

    (function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getBackendClient = exports.setBackendClient = exports.getClientConfig = exports.NodeCMSFrontEndEvents = exports.NodeCMSClient = exports.UtilsService = exports.UserService = exports.TempCache = exports.ProjectsService = exports.PostService = exports.MediaService = exports.UserEventService = exports.documentsEventName = exports.DocumentService = exports.channelsEventNames = exports.ChannelsService = exports.BaseServiceClient = exports.AttachmentHelpers = void 0;
    const services_factory_1 = servicesFactory;
    const NodeCMSClient_1 = NodeCMSClient$1;
    var AttachmentHelpers_1 = AttachmentHelpers$1;
    Object.defineProperty(exports, "AttachmentHelpers", { enumerable: true, get: function () { return AttachmentHelpers_1.AttachmentHelpers; } });
    var BaseServiceClient_1 = BaseServiceClient$1;
    Object.defineProperty(exports, "BaseServiceClient", { enumerable: true, get: function () { return BaseServiceClient_1.BaseServiceClient; } });
    var ChannelsService_1 = ChannelsService;
    Object.defineProperty(exports, "ChannelsService", { enumerable: true, get: function () { return ChannelsService_1.ChannelsService; } });
    Object.defineProperty(exports, "channelsEventNames", { enumerable: true, get: function () { return ChannelsService_1.channelsEventNames; } });
    var DocumentService_1 = DocumentService;
    Object.defineProperty(exports, "DocumentService", { enumerable: true, get: function () { return DocumentService_1.DocumentService; } });
    Object.defineProperty(exports, "documentsEventName", { enumerable: true, get: function () { return DocumentService_1.documentsEventName; } });
    var UserEventService_1 = UserEventService$1;
    Object.defineProperty(exports, "UserEventService", { enumerable: true, get: function () { return UserEventService_1.UserEventService; } });
    var MediaService_1 = MediaService$1;
    Object.defineProperty(exports, "MediaService", { enumerable: true, get: function () { return MediaService_1.MediaService; } });
    var PostService_1 = PostService$1;
    Object.defineProperty(exports, "PostService", { enumerable: true, get: function () { return PostService_1.PostService; } });
    var ProjectsService_1 = ProjectsService$1;
    Object.defineProperty(exports, "ProjectsService", { enumerable: true, get: function () { return ProjectsService_1.ProjectsService; } });
    var TempCache_1 = TempCache$1;
    Object.defineProperty(exports, "TempCache", { enumerable: true, get: function () { return TempCache_1.TempCache; } });
    var UserService_1 = UserService;
    Object.defineProperty(exports, "UserService", { enumerable: true, get: function () { return UserService_1.UserService; } });
    var UtilsService_1 = UtilsService$1;
    Object.defineProperty(exports, "UtilsService", { enumerable: true, get: function () { return UtilsService_1.UtilsService; } });
    var NodeCMSClient_2 = NodeCMSClient$1;
    Object.defineProperty(exports, "NodeCMSClient", { enumerable: true, get: function () { return NodeCMSClient_2.NodeCMSClient; } });
    var NodeCMSFrontEndEvents_1 = NodeCMSFrontEndEvents$1;
    Object.defineProperty(exports, "NodeCMSFrontEndEvents", { enumerable: true, get: function () { return NodeCMSFrontEndEvents_1.NodeCMSFrontEndEvents; } });
    var services_factory_2 = servicesFactory;
    Object.defineProperty(exports, "getClientConfig", { enumerable: true, get: function () { return services_factory_2.getClientConfig; } });
    Object.defineProperty(exports, "setBackendClient", { enumerable: true, get: function () { return services_factory_2.setBackendClient; } });
    Object.defineProperty(exports, "getBackendClient", { enumerable: true, get: function () { return services_factory_2.getBackendClient; } });
    const config = services_factory_1.getClientConfig();
    services_factory_1.setBackendClient(new NodeCMSClient_1.NodeCMSClient(config.backendHost, config.socketIoHost, config.env));
    }(dist$1));

    class Authentication {
    }
    const UserStore = writable(new Authentication());

    class GenericDataStorage {
    }
    const observableGenericDataStore = writable(new GenericDataStorage());

    class UserEvents {
        constructor() {
            this.eventsByUser = {};
            const now = new Date();
            this.startDate = new Date(now.getFullYear(), now.getMonth(), 1, 0, 0, 0);
            this.endDate = new Date(now.getFullYear(), now.getMonth() + 1, 0, 23, 59, 59);
        }
    }
    const UserEventsStore = writable(new UserEvents());

    /* src/components/User.svelte generated by Svelte v3.38.2 */

    const { console: console_1$p } = globals;
    const file$L = "src/components/User.svelte";

    // (149:0) {:else}
    function create_else_block$a(ctx) {
    	let div2;
    	let button0;
    	let i0;
    	let t0;
    	let div1;
    	let button1;
    	let i1;
    	let span0;
    	let t2;
    	let button2;
    	let i2;
    	let span1;
    	let t4;
    	let button3;
    	let i3;
    	let span2;
    	let t6;
    	let button4;
    	let i4;
    	let span3;
    	let t8;
    	let button5;
    	let i5;
    	let span4;
    	let t10;
    	let div0;
    	let t11;
    	let button6;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			button0 = element("button");
    			i0 = element("i");
    			t0 = space();
    			div1 = element("div");
    			button1 = element("button");
    			i1 = element("i");
    			span0 = element("span");
    			span0.textContent = "Media";
    			t2 = space();
    			button2 = element("button");
    			i2 = element("i");
    			span1 = element("span");
    			span1.textContent = "Documents";
    			t4 = space();
    			button3 = element("button");
    			i3 = element("i");
    			span2 = element("span");
    			span2.textContent = "Channels";
    			t6 = space();
    			button4 = element("button");
    			i4 = element("i");
    			span3 = element("span");
    			span3.textContent = "Mon Calendrier";
    			t8 = space();
    			button5 = element("button");
    			i5 = element("i");
    			span4 = element("span");
    			span4.textContent = "Calendrier TeamA";
    			t10 = space();
    			div0 = element("div");
    			t11 = space();
    			button6 = element("button");
    			button6.textContent = "Déconnexion";
    			attr_dev(i0, "class", "fas fa-bars");
    			add_location(i0, file$L, 152, 12, 5611);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn btn-secondary dropdown-toggle svelte-ulw3vn");
    			attr_dev(button0, "data-toggle", "dropdown");
    			add_location(button0, file$L, 150, 8, 5494);
    			attr_dev(i1, "class", "fas fa-photo-video");
    			add_location(i1, file$L, 156, 16, 5840);
    			attr_dev(span0, "class", "svelte-ulw3vn");
    			add_location(span0, file$L, 156, 50, 5874);
    			attr_dev(button1, "class", "dropdown-item svelte-ulw3vn");
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "data-document-key", "media");
    			add_location(button1, file$L, 155, 12, 5726);
    			attr_dev(i2, "class", "fas fa-file-alt");
    			add_location(i2, file$L, 159, 16, 6045);
    			attr_dev(span1, "class", "svelte-ulw3vn");
    			add_location(span1, file$L, 159, 47, 6076);
    			attr_dev(button2, "class", "dropdown-item svelte-ulw3vn");
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "data-document-key", "documents");
    			add_location(button2, file$L, 158, 12, 5927);
    			attr_dev(i3, "class", "fas fa-comments");
    			add_location(i3, file$L, 162, 16, 6250);
    			attr_dev(span2, "class", "svelte-ulw3vn");
    			add_location(span2, file$L, 162, 47, 6281);
    			attr_dev(button3, "class", "dropdown-item svelte-ulw3vn");
    			attr_dev(button3, "type", "button");
    			attr_dev(button3, "data-document-key", "channels");
    			add_location(button3, file$L, 161, 12, 6133);
    			attr_dev(i4, "class", "fa fa-calendar-alt");
    			add_location(i4, file$L, 165, 16, 6457);
    			attr_dev(span3, "class", "svelte-ulw3vn");
    			add_location(span3, file$L, 165, 50, 6491);
    			attr_dev(button4, "class", "dropdown-item svelte-ulw3vn");
    			attr_dev(button4, "type", "button");
    			attr_dev(button4, "data-document-key", "my-calendar");
    			add_location(button4, file$L, 164, 12, 6337);
    			attr_dev(i5, "class", "fas fa-calendar-alt");
    			add_location(i5, file$L, 168, 16, 6676);
    			attr_dev(span4, "class", "svelte-ulw3vn");
    			add_location(span4, file$L, 168, 51, 6711);
    			attr_dev(button5, "class", "dropdown-item svelte-ulw3vn");
    			attr_dev(button5, "type", "button");
    			attr_dev(button5, "data-document-key", "user-calendars");
    			add_location(button5, file$L, 167, 12, 6553);
    			attr_dev(div0, "class", "dropdown-divider");
    			add_location(div0, file$L, 170, 12, 6775);
    			attr_dev(button6, "class", "dropdown-item");
    			attr_dev(button6, "type", "button");
    			add_location(button6, file$L, 171, 12, 6824);
    			attr_dev(div1, "class", "dropdown-menu dropdown-menu-right ");
    			add_location(div1, file$L, 154, 8, 5665);
    			attr_dev(div2, "class", "dropdown");
    			add_location(div2, file$L, 149, 4, 5463);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, button0);
    			append_dev(button0, i0);
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			append_dev(div1, button1);
    			append_dev(button1, i1);
    			append_dev(button1, span0);
    			append_dev(div1, t2);
    			append_dev(div1, button2);
    			append_dev(button2, i2);
    			append_dev(button2, span1);
    			append_dev(div1, t4);
    			append_dev(div1, button3);
    			append_dev(button3, i3);
    			append_dev(button3, span2);
    			append_dev(div1, t6);
    			append_dev(div1, button4);
    			append_dev(button4, i4);
    			append_dev(button4, span3);
    			append_dev(div1, t8);
    			append_dev(div1, button5);
    			append_dev(button5, i5);
    			append_dev(button5, span4);
    			append_dev(div1, t10);
    			append_dev(div1, div0);
    			append_dev(div1, t11);
    			append_dev(div1, button6);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button1, "click", /*displayDocument*/ ctx[7], false, false, false),
    					listen_dev(button2, "click", /*displayDocument*/ ctx[7], false, false, false),
    					listen_dev(button3, "click", /*displayDocument*/ ctx[7], false, false, false),
    					listen_dev(button4, "click", /*displayDocument*/ ctx[7], false, false, false),
    					listen_dev(button5, "click", /*displayDocument*/ ctx[7], false, false, false),
    					listen_dev(button6, "click", /*logout*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$a.name,
    		type: "else",
    		source: "(149:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (143:0) {#if !isLogin}
    function create_if_block$t(ctx) {
    	let div;
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			button.textContent = "Connexion";
    			attr_dev(button, "type", "button");
    			add_location(button, file$L, 144, 8, 5343);
    			add_location(div, file$L, 143, 4, 5329);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*showOrHideAuthenticate*/ ctx[3], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$t.name,
    		type: "if",
    		source: "(143:0) {#if !isLogin}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$O(ctx) {
    	let t0;
    	let div9;
    	let div8;
    	let div7;
    	let div0;
    	let h5;
    	let t2;
    	let button0;
    	let span;
    	let t4;
    	let div3;
    	let form;
    	let div1;
    	let label0;
    	let t6;
    	let input0;
    	let t7;
    	let div2;
    	let label1;
    	let t9;
    	let input1;
    	let t10;
    	let div6;
    	let div5;
    	let div4;
    	let t11;
    	let button1;
    	let mounted;
    	let dispose;

    	function select_block_type(ctx, dirty) {
    		if (!/*isLogin*/ ctx[0]) return create_if_block$t;
    		return create_else_block$a;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			t0 = space();
    			div9 = element("div");
    			div8 = element("div");
    			div7 = element("div");
    			div0 = element("div");
    			h5 = element("h5");
    			h5.textContent = "Login";
    			t2 = space();
    			button0 = element("button");
    			span = element("span");
    			span.textContent = "×";
    			t4 = space();
    			div3 = element("div");
    			form = element("form");
    			div1 = element("div");
    			label0 = element("label");
    			label0.textContent = "Login";
    			t6 = space();
    			input0 = element("input");
    			t7 = space();
    			div2 = element("div");
    			label1 = element("label");
    			label1.textContent = "Password";
    			t9 = space();
    			input1 = element("input");
    			t10 = space();
    			div6 = element("div");
    			div5 = element("div");
    			div4 = element("div");
    			t11 = space();
    			button1 = element("button");
    			button1.textContent = "Login";
    			attr_dev(h5, "class", "modal-title");
    			add_location(h5, file$L, 182, 16, 7202);
    			attr_dev(span, "aria-hidden", "true");
    			add_location(span, file$L, 184, 20, 7366);
    			attr_dev(button0, "id", "LoginClose");
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "close");
    			attr_dev(button0, "data-dismiss", "modal");
    			attr_dev(button0, "aria-label", "Close");
    			add_location(button0, file$L, 183, 16, 7253);
    			attr_dev(div0, "class", "modal-header");
    			add_location(div0, file$L, 181, 12, 7159);
    			attr_dev(label0, "for", "login");
    			add_location(label0, file$L, 190, 24, 7580);
    			attr_dev(input0, "id", "login");
    			attr_dev(input0, "type", "text");
    			attr_dev(input0, "placeholder", "Type your login here");
    			add_location(input0, file$L, 191, 24, 7637);
    			attr_dev(div1, "class", "form-group");
    			add_location(div1, file$L, 189, 20, 7531);
    			attr_dev(label1, "for", "password");
    			add_location(label1, file$L, 194, 24, 7818);
    			attr_dev(input1, "id", "password");
    			attr_dev(input1, "type", "password");
    			attr_dev(input1, "placeholder", "Type your password here");
    			add_location(input1, file$L, 195, 24, 7881);
    			attr_dev(div2, "class", "form-group");
    			add_location(div2, file$L, 193, 20, 7769);
    			add_location(form, file$L, 188, 16, 7504);
    			attr_dev(div3, "class", "modal-body");
    			add_location(div3, file$L, 187, 12, 7463);
    			attr_dev(div4, "id", "errorOnLoginContent");
    			add_location(div4, file$L, 201, 20, 8180);
    			attr_dev(div5, "id", "errorOnLogin");
    			attr_dev(div5, "class", "alert alert-danger fade");
    			add_location(div5, file$L, 200, 16, 8104);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn btn-danger");
    			add_location(button1, file$L, 203, 16, 8256);
    			attr_dev(div6, "class", "modal-footer");
    			add_location(div6, file$L, 199, 12, 8061);
    			attr_dev(div7, "class", "modal-content");
    			add_location(div7, file$L, 180, 8, 7119);
    			attr_dev(div8, "class", "modal-dialog modal-dialog-centered");
    			add_location(div8, file$L, 179, 4, 7062);
    			attr_dev(div9, "id", "LoginModal");
    			attr_dev(div9, "class", "modal fade");
    			attr_dev(div9, "data-keyboard", "false");
    			add_location(div9, file$L, 178, 0, 6970);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div9, anchor);
    			append_dev(div9, div8);
    			append_dev(div8, div7);
    			append_dev(div7, div0);
    			append_dev(div0, h5);
    			append_dev(div0, t2);
    			append_dev(div0, button0);
    			append_dev(button0, span);
    			append_dev(div7, t4);
    			append_dev(div7, div3);
    			append_dev(div3, form);
    			append_dev(form, div1);
    			append_dev(div1, label0);
    			append_dev(div1, t6);
    			append_dev(div1, input0);
    			set_input_value(input0, /*login*/ ctx[1]);
    			append_dev(form, t7);
    			append_dev(form, div2);
    			append_dev(div2, label1);
    			append_dev(div2, t9);
    			append_dev(div2, input1);
    			set_input_value(input1, /*password*/ ctx[2]);
    			append_dev(div7, t10);
    			append_dev(div7, div6);
    			append_dev(div6, div5);
    			append_dev(div5, div4);
    			append_dev(div6, t11);
    			append_dev(div6, button1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[8]),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[9]),
    					listen_dev(button1, "click", /*authenticate*/ ctx[4], false, false, false),
    					listen_dev(div9, "keypress", /*onKeyPress*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(t0.parentNode, t0);
    				}
    			}

    			if (dirty & /*login*/ 2 && input0.value !== /*login*/ ctx[1]) {
    				set_input_value(input0, /*login*/ ctx[1]);
    			}

    			if (dirty & /*password*/ 4 && input1.value !== /*password*/ ctx[2]) {
    				set_input_value(input1, /*password*/ ctx[2]);
    			}
    		},
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div9);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$O.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$O($$self, $$props, $$invalidate) {
    	let $UserEventsStore;
    	let $observableGenericDataStore;
    	validate_store(UserEventsStore, "UserEventsStore");
    	component_subscribe($$self, UserEventsStore, $$value => $$invalidate(11, $UserEventsStore = $$value));
    	validate_store(observableGenericDataStore, "observableGenericDataStore");
    	component_subscribe($$self, observableGenericDataStore, $$value => $$invalidate(12, $observableGenericDataStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("User", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	let { isLogin = false } = $$props;
    	let backendService = null;
    	let login;
    	let password;

    	let showOrHideAuthenticate = () => {
    		//toggle the login modal to show
    		jQuery("#errorOnLoginContent").html("");

    		jQuery("#errorOnLogin").removeClass("show");
    		jQuery("#LoginModal").modal("toggle");
    	};

    	function onLoggedIn() {
    		var _a;

    		return __awaiter(this, void 0, void 0, function* () {
    			const services = yield dist$1.getBackendClient();
    			const currentUser = yield services.userService.getCurrentUser();

    			if (!login) {
    				$$invalidate(1, login = currentUser.login);
    			}

    			UserStore.set({ isLogin, login, id: currentUser.id });
    			const userEvents = yield services.userService.findUserEvents(login, $UserEventsStore.startDate, $UserEventsStore.endDate);

    			UserEventsStore.update(ues => {
    				ues.eventsByUser[login] = userEvents;
    				return ues;
    			});

    			const params = new URL(document.location.href).searchParams;

    			if (!params.get("documentKey")) {
    				DocumentStore.update(store => {
    					store.key = "welcomePrivate";
    					return store;
    				});
    			}

    			(_a = jQuery("#LoginModal")) === null || _a === void 0
    			? void 0
    			: _a.modal("hide");
    		});
    	}

    	let authenticate = () => __awaiter(void 0, void 0, void 0, function* () {
    		if (login && password) {
    			const alertBox = window.jQuery("#errorOnLogin");
    			alertBox.removeClass("show");

    			try {
    				yield backendService.userService.authenticate(login, password);
    				$$invalidate(0, isLogin = true);
    			} catch(e) {
    				console.log(e);
    				let message;

    				if (e.response && e.response.data && e.response.data.message) {
    					message = e.response.data.message;
    				} else {
    					message = e.message;
    				}

    				window.jQuery("#errorOnLoginContent").html(`${message}`);
    				alertBox.alert();
    				alertBox.addClass("show");
    			}

    			if (isLogin) {
    				yield onLoggedIn();
    			}
    		}
    	});

    	let onKeyPress = event => __awaiter(void 0, void 0, void 0, function* () {
    		if (event.code === "Enter") {
    			yield authenticate();
    		}
    	});

    	let logout = () => __awaiter(void 0, void 0, void 0, function* () {
    		$$invalidate(0, isLogin = false);
    		yield backendService.userService.logOut();
    		UserStore.set({ isLogin: false, login: undefined });

    		DocumentStore.update(store => {
    			store.key = "welcome";
    			return store;
    		});
    	});

    	onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    		window.jQuery("#LoginModal").on("hidden.bs.modal", e => {
    			$$invalidate(1, login = "");
    			$$invalidate(2, password = "");
    		});

    		backendService = yield dist$1.getBackendClient();
    		let loginOrFalse = yield backendService.userService.checkAuthentication();

    		if (loginOrFalse && typeof loginOrFalse === "string") {
    			$$invalidate(0, isLogin = true);
    			$$invalidate(1, login = yield backendService.userService.getCurrentUser().login);
    			yield onLoggedIn();
    		}
    	}));

    	function displayDocument(event) {
    		return __awaiter(this, void 0, void 0, function* () {
    			const documentKey = event.currentTarget.getAttribute("data-document-key");

    			if (documentKey) {
    				if (documentKey === "documents") {
    					const services = yield dist$1.getBackendClient();
    					set_store_value(observableGenericDataStore, $observableGenericDataStore.data = [], $observableGenericDataStore);
    					set_store_value(observableGenericDataStore, $observableGenericDataStore.data = yield services.documentService.findDocument(), $observableGenericDataStore);
    					const indexes = $observableGenericDataStore.data.map(d => d.id);
    					set_store_value(observableGenericDataStore, $observableGenericDataStore.hasNext = (yield services.documentService.findDocument({ lastIndex: Math.min(...indexes) })).length > 0, $observableGenericDataStore);
    				}

    				

    				DocumentStore.update(store => {
    					store.key = documentKey;
    					return store;
    				});
    			}
    		});
    	}

    	const writable_props = ["isLogin"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$p.warn(`<User> was created with unknown prop '${key}'`);
    	});

    	function input0_input_handler() {
    		login = this.value;
    		$$invalidate(1, login);
    	}

    	function input1_input_handler() {
    		password = this.value;
    		$$invalidate(2, password);
    	}

    	$$self.$$set = $$props => {
    		if ("isLogin" in $$props) $$invalidate(0, isLogin = $$props.isLogin);
    	};

    	$$self.$capture_state = () => ({
    		__awaiter,
    		getBackendClient: dist$1.getBackendClient,
    		NodeCMSClient: dist$1.NodeCMSClient,
    		NodeCMSClientContract: dist$1.NodeCMSClientContract,
    		UserService: dist$1.UserService,
    		UserEventService: dist$1.UserEventService,
    		onMount,
    		UserStore,
    		DocumentStore,
    		observableGenericDataStore,
    		UserEventsStore,
    		UserEvents,
    		isLogin,
    		backendService,
    		login,
    		password,
    		showOrHideAuthenticate,
    		onLoggedIn,
    		authenticate,
    		onKeyPress,
    		logout,
    		displayDocument,
    		$UserEventsStore,
    		$observableGenericDataStore
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("isLogin" in $$props) $$invalidate(0, isLogin = $$props.isLogin);
    		if ("backendService" in $$props) backendService = $$props.backendService;
    		if ("login" in $$props) $$invalidate(1, login = $$props.login);
    		if ("password" in $$props) $$invalidate(2, password = $$props.password);
    		if ("showOrHideAuthenticate" in $$props) $$invalidate(3, showOrHideAuthenticate = $$props.showOrHideAuthenticate);
    		if ("authenticate" in $$props) $$invalidate(4, authenticate = $$props.authenticate);
    		if ("onKeyPress" in $$props) $$invalidate(5, onKeyPress = $$props.onKeyPress);
    		if ("logout" in $$props) $$invalidate(6, logout = $$props.logout);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		isLogin,
    		login,
    		password,
    		showOrHideAuthenticate,
    		authenticate,
    		onKeyPress,
    		logout,
    		displayDocument,
    		input0_input_handler,
    		input1_input_handler
    	];
    }

    class User extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$O, create_fragment$O, safe_not_equal, { isLogin: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "User",
    			options,
    			id: create_fragment$O.name
    		});
    	}

    	get isLogin() {
    		throw new Error("<User>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isLogin(value) {
    		throw new Error("<User>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    class PanelContext {
        constructor() {
            this.isShown = false;
            this.components = [];
        }
        clearComponents() {
            this.components = [];
        }
        addComponent(componentMetadata) {
            this.components.push(componentMetadata);
        }
    }
    const leftPanelContext = writable(new PanelContext());
    writable(new PanelContext());

    /* src/components/TopNavBar.svelte generated by Svelte v3.38.2 */

    const { console: console_1$o } = globals;
    const file$K = "src/components/TopNavBar.svelte";

    function create_fragment$N(ctx) {
    	let nav;
    	let div1;
    	let div0;
    	let img;
    	let img_src_value;
    	let t0;
    	let strong;
    	let t1_value = /*innerModel*/ ctx[0].title + "";
    	let t1;
    	let t2;
    	let user;
    	let current;
    	let mounted;
    	let dispose;
    	user = new User({ $$inline: true });

    	const block = {
    		c: function create() {
    			nav = element("nav");
    			div1 = element("div");
    			div0 = element("div");
    			img = element("img");
    			t0 = space();
    			strong = element("strong");
    			t1 = text(t1_value);
    			t2 = space();
    			create_component(user.$$.fragment);
    			if (img.src !== (img_src_value = /*innerModel*/ ctx[0].imgSrc)) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "height", "45px");
    			attr_dev(img, "width", "45px");
    			attr_dev(img, "alt", "application logo");
    			add_location(img, file$K, 51, 12, 2033);
    			add_location(strong, file$K, 52, 12, 2125);
    			attr_dev(div0, "class", "navbar-brand d-flex align-items-center");
    			add_location(div0, file$K, 50, 8, 1940);
    			attr_dev(div1, "class", "container d-flex justify-content-between svelte-1omgll9");
    			add_location(div1, file$K, 49, 4, 1877);
    			attr_dev(nav, "class", "navbar navbar-dark bg-dark shadow-sm svelte-1omgll9");
    			add_location(nav, file$K, 48, 0, 1822);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, nav, anchor);
    			append_dev(nav, div1);
    			append_dev(div1, div0);
    			append_dev(div0, img);
    			append_dev(div0, t0);
    			append_dev(div0, strong);
    			append_dev(strong, t1);
    			append_dev(div1, t2);
    			mount_component(user, div1, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div0, "click", /*displayLeftPanel*/ ctx[2], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*innerModel*/ 1 && img.src !== (img_src_value = /*innerModel*/ ctx[0].imgSrc)) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if ((!current || dirty & /*innerModel*/ 1) && t1_value !== (t1_value = /*innerModel*/ ctx[0].title + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(user.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(user.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(nav);
    			destroy_component(user);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$N.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$N($$self, $$props, $$invalidate) {
    	let $model;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("TopNavBar", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	const model = writable({ title: "", imgSrc: "favicon.png" });
    	validate_store(model, "model");
    	component_subscribe($$self, model, value => $$invalidate(3, $model = value));
    	let innerModel = $model;

    	const unsubscribe = model.subscribe(m => {
    		$$invalidate(0, innerModel = m);
    	});

    	onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    		const backendClient = yield dist$1.getBackendClient();
    		const title = (yield backendClient.getMetadata("title")).value;
    		const newLogoSrc = (yield backendClient.getMetadata("logo")).value;

    		model.update(m => {
    			m.title = title;
    			m.imgSrc = newLogoSrc;
    			return m;
    		});
    	}));

    	afterUpdate(() => {
    		
    	});

    	function displayLeftPanel() {
    		return __awaiter(this, void 0, void 0, function* () {
    			leftPanelContext.update(pc => {
    				console.log(pc);
    				if (pc.isShown) pc.isShown = false; else pc.isShown = true;
    				return pc;
    			});
    		});
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$o.warn(`<TopNavBar> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		__awaiter,
    		getBackendClient: dist$1.getBackendClient,
    		User,
    		onMount,
    		afterUpdate,
    		writable,
    		leftPanelContext,
    		model,
    		innerModel,
    		unsubscribe,
    		displayLeftPanel,
    		$model
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("innerModel" in $$props) $$invalidate(0, innerModel = $$props.innerModel);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [innerModel, model, displayLeftPanel];
    }

    class TopNavBar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$N, create_fragment$N, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TopNavBar",
    			options,
    			id: create_fragment$N.name
    		});
    	}
    }

    class BaseComponentFactory {
        constructor() {
            this.registeredConstructors = {};
        }
        registerComponent(key, contentContainerConstructor, titleForEdition, cssClassesForEdition, editorConstructor, canDisplayInEditMode = true) {
            this.registeredConstructors[key] = {
                type: key,
                constructor: contentContainerConstructor,
                title: titleForEdition,
                cssClasses: cssClassesForEdition,
                editorConstructor: editorConstructor,
                canDisplayInEditMode: canDisplayInEditMode
            };
        }
        getComponent(key) {
            if (this.registeredConstructors.hasOwnProperty(key)) {
                return this.registeredConstructors[key].constructor;
            }
            throw new Error(`No ctor registered with key ${key}`);
        }
        getConstructors() {
            const constructors = [];
            for (const c in this.registeredConstructors) {
                if (this.registeredConstructors.hasOwnProperty(c)) {
                    constructors.push(this.registeredConstructors[c]);
                }
            }
            return constructors;
        }
    }

    class ContentContainerFactory extends BaseComponentFactory {
        constructor() {
            super();
        }
        getContentContainerTitle(key) {
            if (this.registeredConstructors.hasOwnProperty(key)) {
                return this.registeredConstructors[key].title;
            }
            throw new Error(`No ctor registered with key ${key}`);
        }
        getContentContainerCssClasses(key) {
            if (this.registeredConstructors.hasOwnProperty(key)) {
                return this.registeredConstructors[key].cssClasses;
            }
            throw new Error(`No ctor registered with key ${key}`);
        }
    }
    const globalContentContainerFactory = new ContentContainerFactory();
    window.globalContainerFactory = globalContentContainerFactory;

    class FEServices {
        constructor() {
            this.services = {};
        }
        registerService(serviceName, service) {
            this.services[serviceName] = service;
        }
        getService(serviceName) {
            return this.services[serviceName];
        }
    }
    const globalFEService$1 = new FEServices();
    window.globalFEService = globalFEService$1;

    /* src/components/Attachments/LoadingAttachment.svelte generated by Svelte v3.38.2 */

    const file$J = "src/components/Attachments/LoadingAttachment.svelte";

    function create_fragment$M(ctx) {
    	let div2;
    	let div0;
    	let t0;
    	let div1;
    	let i0;
    	let t1;
    	let i1;
    	let t2;
    	let i2;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div1 = element("div");
    			i0 = element("i");
    			t1 = space();
    			i1 = element("i");
    			t2 = space();
    			i2 = element("i");
    			attr_dev(div0, "class", "spinner-border spinner-loading text-danger svelte-5i2iyg");
    			add_location(div0, file$J, 33, 4, 670);
    			attr_dev(i0, "class", "fas fa-3x fa-video");
    			add_location(i0, file$J, 35, 8, 775);
    			attr_dev(i1, "class", "fas fa-3x fa-volume-up");
    			add_location(i1, file$J, 36, 8, 818);
    			attr_dev(i2, "class", "fas fa-3x fa-image");
    			add_location(i2, file$J, 37, 8, 865);
    			attr_dev(div1, "class", "medias-loading svelte-5i2iyg");
    			add_location(div1, file$J, 34, 4, 738);
    			attr_dev(div2, "class", "loading-container svelte-5i2iyg");
    			attr_dev(div2, "id", /*attachment*/ ctx[0]);
    			attr_dev(div2, "title", "Chargement ...");
    			add_location(div2, file$J, 30, 0, 583);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			append_dev(div1, i0);
    			append_dev(div1, t1);
    			append_dev(div1, i1);
    			append_dev(div1, t2);
    			append_dev(div1, i2);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*attachment*/ 1) {
    				attr_dev(div2, "id", /*attachment*/ ctx[0]);
    			}
    		},
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$M.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$M($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("LoadingAttachment", slots, []);
    	let { attachment } = $$props;
    	const writable_props = ["attachment"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<LoadingAttachment> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("attachment" in $$props) $$invalidate(0, attachment = $$props.attachment);
    	};

    	$$self.$capture_state = () => ({ attachment });

    	$$self.$inject_state = $$props => {
    		if ("attachment" in $$props) $$invalidate(0, attachment = $$props.attachment);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [attachment];
    }

    class LoadingAttachment extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$M, create_fragment$M, safe_not_equal, { attachment: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LoadingAttachment",
    			options,
    			id: create_fragment$M.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*attachment*/ ctx[0] === undefined && !("attachment" in props)) {
    			console.warn("<LoadingAttachment> was created without expected prop 'attachment'");
    		}
    	}

    	get attachment() {
    		throw new Error("<LoadingAttachment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set attachment(value) {
    		throw new Error("<LoadingAttachment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Attachments/ImageAttachment.svelte generated by Svelte v3.38.2 */
    const file$I = "src/components/Attachments/ImageAttachment.svelte";

    // (52:39) 
    function create_if_block_1$m(ctx) {
    	let div;
    	let div_data_media_key_value;
    	let div_id_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "data-media-key", div_data_media_key_value = /*media*/ ctx[1].key);
    			attr_dev(div, "id", div_id_value = "image-" + /*attachment*/ ctx[0]);
    			attr_dev(div, "class", "attachment-image svelte-3xdtod");
    			set_style(div, "background-image", dist$1.AttachmentHelpers.getImageUrl(/*media*/ ctx[1]));
    			add_location(div, file$I, 52, 4, 1346);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*click_handler*/ ctx[3], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*media*/ 2 && div_data_media_key_value !== (div_data_media_key_value = /*media*/ ctx[1].key)) {
    				attr_dev(div, "data-media-key", div_data_media_key_value);
    			}

    			if (dirty & /*attachment*/ 1 && div_id_value !== (div_id_value = "image-" + /*attachment*/ ctx[0])) {
    				attr_dev(div, "id", div_id_value);
    			}

    			if (dirty & /*media*/ 2) {
    				set_style(div, "background-image", dist$1.AttachmentHelpers.getImageUrl(/*media*/ ctx[1]));
    			}
    		},
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$m.name,
    		type: "if",
    		source: "(52:39) ",
    		ctx
    	});

    	return block;
    }

    // (50:0) {#if !media}
    function create_if_block$s(ctx) {
    	let loadingattachment;
    	let current;

    	loadingattachment = new LoadingAttachment({
    			props: { attachment: /*attachment*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(loadingattachment.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(loadingattachment, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const loadingattachment_changes = {};
    			if (dirty & /*attachment*/ 1) loadingattachment_changes.attachment = /*attachment*/ ctx[0];
    			loadingattachment.$set(loadingattachment_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loadingattachment.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loadingattachment.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loadingattachment, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$s.name,
    		type: "if",
    		source: "(50:0) {#if !media}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$L(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$s, create_if_block_1$m];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (!/*media*/ ctx[1]) return 0;
    		if (typeof /*media*/ ctx[1].id === "number") return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$2();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$L.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$L($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ImageAttachment", slots, []);
    	const dispatch = createEventDispatcher();
    	let { attachment } = $$props;
    	let media;
    	const mediaStore = writable({});

    	mediaStore.subscribe(value => {
    		if (!media || media.id !== value.id) $$invalidate(1, media = value);
    	});

    	async function loadMedia() {
    		if (!media || media.key !== attachment) {
    			const backendClient = await dist$1.getBackendClient();
    			const m = await backendClient.mediaService.getMedia(attachment);
    			mediaStore.set(m);
    		}
    	}

    	onMount(async () => {
    		await loadMedia();
    	});

    	beforeUpdate(async () => {
    		await loadMedia();
    	});

    	const writable_props = ["attachment"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ImageAttachment> was created with unknown prop '${key}'`);
    	});

    	const click_handler = event => {
    		dispatch("click", event);
    	};

    	$$self.$$set = $$props => {
    		if ("attachment" in $$props) $$invalidate(0, attachment = $$props.attachment);
    	};

    	$$self.$capture_state = () => ({
    		AttachmentHelpers: dist$1.AttachmentHelpers,
    		beforeUpdate,
    		onMount,
    		createEventDispatcher,
    		writable,
    		LoadingAttachment,
    		getBackendClient: dist$1.getBackendClient,
    		dispatch,
    		attachment,
    		media,
    		mediaStore,
    		loadMedia
    	});

    	$$self.$inject_state = $$props => {
    		if ("attachment" in $$props) $$invalidate(0, attachment = $$props.attachment);
    		if ("media" in $$props) $$invalidate(1, media = $$props.media);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [attachment, media, dispatch, click_handler];
    }

    class ImageAttachment extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$L, create_fragment$L, safe_not_equal, { attachment: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ImageAttachment",
    			options,
    			id: create_fragment$L.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*attachment*/ ctx[0] === undefined && !("attachment" in props)) {
    			console.warn("<ImageAttachment> was created without expected prop 'attachment'");
    		}
    	}

    	get attachment() {
    		throw new Error("<ImageAttachment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set attachment(value) {
    		throw new Error("<ImageAttachment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Attachments/VideoAttachment.svelte generated by Svelte v3.38.2 */
    const file$H = "src/components/Attachments/VideoAttachment.svelte";

    // (58:39) 
    function create_if_block_1$l(ctx) {
    	let video;
    	let track;
    	let t;
    	let video_id_value;
    	let video_data_media_key_value;
    	let video_src_value;
    	let video_type_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			video = element("video");
    			track = element("track");
    			t = text("\n        Your browser doesn't support video tag. Please update your browser.");
    			attr_dev(track, "kind", "captions");
    			add_location(track, file$H, 65, 8, 1814);
    			attr_dev(video, "id", video_id_value = `video-${/*media*/ ctx[1].key}`);
    			attr_dev(video, "data-media-key", video_data_media_key_value = /*media*/ ctx[1].key);
    			video.controls = true;
    			attr_dev(video, "class", "attachment-video svelte-1k25gly");
    			if (video.src !== (video_src_value = dist$1.AttachmentHelpers.getDownloadUrl(/*media*/ ctx[1]))) attr_dev(video, "src", video_src_value);
    			attr_dev(video, "type", video_type_value = /*media*/ ctx[1].mediaType);
    			add_location(video, file$H, 58, 4, 1539);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, video, anchor);
    			append_dev(video, track);
    			append_dev(video, t);

    			if (!mounted) {
    				dispose = listen_dev(video, "click", /*handleVideoClick*/ ctx[2], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*media*/ 2 && video_id_value !== (video_id_value = `video-${/*media*/ ctx[1].key}`)) {
    				attr_dev(video, "id", video_id_value);
    			}

    			if (dirty & /*media*/ 2 && video_data_media_key_value !== (video_data_media_key_value = /*media*/ ctx[1].key)) {
    				attr_dev(video, "data-media-key", video_data_media_key_value);
    			}

    			if (dirty & /*media*/ 2 && video.src !== (video_src_value = dist$1.AttachmentHelpers.getDownloadUrl(/*media*/ ctx[1]))) {
    				attr_dev(video, "src", video_src_value);
    			}

    			if (dirty & /*media*/ 2 && video_type_value !== (video_type_value = /*media*/ ctx[1].mediaType)) {
    				attr_dev(video, "type", video_type_value);
    			}
    		},
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(video);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$l.name,
    		type: "if",
    		source: "(58:39) ",
    		ctx
    	});

    	return block;
    }

    // (56:0) {#if !media || typeof media.id === 'undefined'}
    function create_if_block$r(ctx) {
    	let loadingattachment;
    	let current;

    	loadingattachment = new LoadingAttachment({
    			props: { attachment: /*attachment*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(loadingattachment.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(loadingattachment, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const loadingattachment_changes = {};
    			if (dirty & /*attachment*/ 1) loadingattachment_changes.attachment = /*attachment*/ ctx[0];
    			loadingattachment.$set(loadingattachment_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loadingattachment.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loadingattachment.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loadingattachment, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$r.name,
    		type: "if",
    		source: "(56:0) {#if !media || typeof media.id === 'undefined'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$K(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$r, create_if_block_1$l];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (!/*media*/ ctx[1] || typeof /*media*/ ctx[1].id === "undefined") return 0;
    		if (typeof /*media*/ ctx[1].id === "number") return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$2();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$K.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$K($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("VideoAttachment", slots, []);
    	let { attachment } = $$props;
    	let media;
    	const dispatch = createEventDispatcher();
    	const mediaStore = writable({});

    	mediaStore.subscribe(value => {
    		if (!media || media.id !== value.id) $$invalidate(1, media = value);
    	});

    	async function loadMedia() {
    		if (!media || media.key !== attachment) {
    			const backendClient = await dist$1.getBackendClient();
    			const m = await backendClient.mediaService.getMedia(attachment);
    			mediaStore.set(m);
    		}
    	}

    	onMount(async () => {
    		await loadMedia();
    	});

    	beforeUpdate(async () => {
    		if (!media) await loadMedia();
    	});

    	function handleVideoClick(event) {
    		try {
    			dispatch("click", event);
    		} catch(err) {
    			
    		} //do nothing

    		if (event.target && event.target.play) {
    			event.target.play();
    		}
    	}

    	const writable_props = ["attachment"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<VideoAttachment> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("attachment" in $$props) $$invalidate(0, attachment = $$props.attachment);
    	};

    	$$self.$capture_state = () => ({
    		AttachmentHelpers: dist$1.AttachmentHelpers,
    		writable,
    		getBackendClient: dist$1.getBackendClient,
    		beforeUpdate,
    		onMount,
    		LoadingAttachment,
    		createEventDispatcher,
    		attachment,
    		media,
    		dispatch,
    		mediaStore,
    		loadMedia,
    		handleVideoClick
    	});

    	$$self.$inject_state = $$props => {
    		if ("attachment" in $$props) $$invalidate(0, attachment = $$props.attachment);
    		if ("media" in $$props) $$invalidate(1, media = $$props.media);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [attachment, media, handleVideoClick];
    }

    class VideoAttachment extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$K, create_fragment$K, safe_not_equal, { attachment: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "VideoAttachment",
    			options,
    			id: create_fragment$K.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*attachment*/ ctx[0] === undefined && !("attachment" in props)) {
    			console.warn("<VideoAttachment> was created without expected prop 'attachment'");
    		}
    	}

    	get attachment() {
    		throw new Error("<VideoAttachment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set attachment(value) {
    		throw new Error("<VideoAttachment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Attachments/AudioAttachment.svelte generated by Svelte v3.38.2 */

    const { console: console_1$n } = globals;
    const file$G = "src/components/Attachments/AudioAttachment.svelte";

    // (53:39) 
    function create_if_block_1$k(ctx) {
    	let audio;
    	let track;
    	let t;
    	let audio_id_value;
    	let audio_data_media_key_value;
    	let audio_src_value;
    	let audio_type_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			audio = element("audio");
    			track = element("track");
    			t = text("\n        Your browser doesn't support audio tag. Please update your browser.");
    			attr_dev(track, "kind", "captions");
    			add_location(track, file$G, 60, 8, 1624);
    			attr_dev(audio, "id", audio_id_value = `video-${/*media*/ ctx[1].key}`);
    			attr_dev(audio, "data-media-key", audio_data_media_key_value = /*media*/ ctx[1].key);
    			audio.controls = true;
    			attr_dev(audio, "class", "postAudio svelte-1i5neu9");
    			if (audio.src !== (audio_src_value = dist$1.AttachmentHelpers.getDownloadUrl(/*media*/ ctx[1]))) attr_dev(audio, "src", audio_src_value);
    			attr_dev(audio, "type", audio_type_value = /*media*/ ctx[1].mediaType);
    			add_location(audio, file$G, 53, 4, 1356);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, audio, anchor);
    			append_dev(audio, track);
    			append_dev(audio, t);

    			if (!mounted) {
    				dispose = listen_dev(audio, "click", handleVideoClick, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*media*/ 2 && audio_id_value !== (audio_id_value = `video-${/*media*/ ctx[1].key}`)) {
    				attr_dev(audio, "id", audio_id_value);
    			}

    			if (dirty & /*media*/ 2 && audio_data_media_key_value !== (audio_data_media_key_value = /*media*/ ctx[1].key)) {
    				attr_dev(audio, "data-media-key", audio_data_media_key_value);
    			}

    			if (dirty & /*media*/ 2 && audio.src !== (audio_src_value = dist$1.AttachmentHelpers.getDownloadUrl(/*media*/ ctx[1]))) {
    				attr_dev(audio, "src", audio_src_value);
    			}

    			if (dirty & /*media*/ 2 && audio_type_value !== (audio_type_value = /*media*/ ctx[1].mediaType)) {
    				attr_dev(audio, "type", audio_type_value);
    			}
    		},
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(audio);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$k.name,
    		type: "if",
    		source: "(53:39) ",
    		ctx
    	});

    	return block;
    }

    // (51:0) {#if !media || typeof media.id === 'undefined'}
    function create_if_block$q(ctx) {
    	let loadingattachment;
    	let current;

    	loadingattachment = new LoadingAttachment({
    			props: { attachment: /*attachment*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(loadingattachment.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(loadingattachment, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const loadingattachment_changes = {};
    			if (dirty & /*attachment*/ 1) loadingattachment_changes.attachment = /*attachment*/ ctx[0];
    			loadingattachment.$set(loadingattachment_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loadingattachment.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loadingattachment.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loadingattachment, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$q.name,
    		type: "if",
    		source: "(51:0) {#if !media || typeof media.id === 'undefined'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$J(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$q, create_if_block_1$k];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (!/*media*/ ctx[1] || typeof /*media*/ ctx[1].id === "undefined") return 0;
    		if (typeof /*media*/ ctx[1].id === "number") return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$2();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$J.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function handleVideoClick(event) {
    	if (event.target && event.target.play) {
    		event.target.play();
    	}
    }

    function instance$J($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("AudioAttachment", slots, []);
    	let { attachment } = $$props;
    	let media;
    	console.log(media);
    	const mediaStore = writable({});

    	mediaStore.subscribe(value => {
    		if (!media || media.id !== value.id) $$invalidate(1, media = value);
    	});

    	async function loadMedia() {
    		if (!media || media.key !== attachment) {
    			const backendClient = await dist$1.getBackendClient();
    			const m = await backendClient.mediaService.getMedia(attachment);
    			console.log("getting media");
    			console.log(m);
    			mediaStore.set(m);
    		}
    	}

    	onMount(async () => {
    		await loadMedia();
    	});

    	beforeUpdate(async () => {
    		await loadMedia();
    	});

    	const writable_props = ["attachment"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$n.warn(`<AudioAttachment> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("attachment" in $$props) $$invalidate(0, attachment = $$props.attachment);
    	};

    	$$self.$capture_state = () => ({
    		AttachmentHelpers: dist$1.AttachmentHelpers,
    		writable,
    		getBackendClient: dist$1.getBackendClient,
    		beforeUpdate,
    		onMount,
    		LoadingAttachment,
    		attachment,
    		media,
    		mediaStore,
    		loadMedia,
    		handleVideoClick
    	});

    	$$self.$inject_state = $$props => {
    		if ("attachment" in $$props) $$invalidate(0, attachment = $$props.attachment);
    		if ("media" in $$props) $$invalidate(1, media = $$props.media);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [attachment, media];
    }

    class AudioAttachment extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$J, create_fragment$J, safe_not_equal, { attachment: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AudioAttachment",
    			options,
    			id: create_fragment$J.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*attachment*/ ctx[0] === undefined && !("attachment" in props)) {
    			console_1$n.warn("<AudioAttachment> was created without expected prop 'attachment'");
    		}
    	}

    	get attachment() {
    		throw new Error("<AudioAttachment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set attachment(value) {
    		throw new Error("<AudioAttachment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Attachments/DownloadAttachment.svelte generated by Svelte v3.38.2 */
    const file$F = "src/components/Attachments/DownloadAttachment.svelte";

    // (57:39) 
    function create_if_block_1$j(ctx) {
    	let a;
    	let div1;
    	let i;
    	let i_class_value;
    	let t0;
    	let div0;
    	let t1_value = /*media*/ ctx[1].label + "";
    	let t1;
    	let a_id_value;
    	let a_data_media_key_value;
    	let a_href_value;

    	const block = {
    		c: function create() {
    			a = element("a");
    			div1 = element("div");
    			i = element("i");
    			t0 = space();
    			div0 = element("div");
    			t1 = text(t1_value);
    			attr_dev(i, "class", i_class_value = "fas fa-2x " + /*icons*/ ctx[2][/*media*/ ctx[1].mediaType] + " svelte-1tka9ae");
    			add_location(i, file$F, 62, 12, 1677);
    			attr_dev(div0, "class", "label svelte-1tka9ae");
    			add_location(div0, file$F, 63, 12, 1740);
    			attr_dev(div1, "class", "attachment-download svelte-1tka9ae");
    			add_location(div1, file$F, 61, 8, 1631);
    			attr_dev(a, "id", a_id_value = "download-" + /*media*/ ctx[1].id);
    			attr_dev(a, "data-media-key", a_data_media_key_value = /*media*/ ctx[1].key);
    			attr_dev(a, "class", "attachment-download svelte-1tka9ae");
    			attr_dev(a, "href", a_href_value = dist$1.AttachmentHelpers.getDownloadUrl(/*media*/ ctx[1]));
    			attr_dev(a, "target", "_blank");
    			add_location(a, file$F, 57, 4, 1451);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, div1);
    			append_dev(div1, i);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			append_dev(div0, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*media*/ 2 && i_class_value !== (i_class_value = "fas fa-2x " + /*icons*/ ctx[2][/*media*/ ctx[1].mediaType] + " svelte-1tka9ae")) {
    				attr_dev(i, "class", i_class_value);
    			}

    			if (dirty & /*media*/ 2 && t1_value !== (t1_value = /*media*/ ctx[1].label + "")) set_data_dev(t1, t1_value);

    			if (dirty & /*media*/ 2 && a_id_value !== (a_id_value = "download-" + /*media*/ ctx[1].id)) {
    				attr_dev(a, "id", a_id_value);
    			}

    			if (dirty & /*media*/ 2 && a_data_media_key_value !== (a_data_media_key_value = /*media*/ ctx[1].key)) {
    				attr_dev(a, "data-media-key", a_data_media_key_value);
    			}

    			if (dirty & /*media*/ 2 && a_href_value !== (a_href_value = dist$1.AttachmentHelpers.getDownloadUrl(/*media*/ ctx[1]))) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$j.name,
    		type: "if",
    		source: "(57:39) ",
    		ctx
    	});

    	return block;
    }

    // (55:0) {#if !media || typeof media.id === 'undefined'}
    function create_if_block$p(ctx) {
    	let loadingattachment;
    	let current;

    	loadingattachment = new LoadingAttachment({
    			props: { attachment: /*attachment*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(loadingattachment.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(loadingattachment, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const loadingattachment_changes = {};
    			if (dirty & /*attachment*/ 1) loadingattachment_changes.attachment = /*attachment*/ ctx[0];
    			loadingattachment.$set(loadingattachment_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loadingattachment.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loadingattachment.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loadingattachment, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$p.name,
    		type: "if",
    		source: "(55:0) {#if !media || typeof media.id === 'undefined'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$I(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$p, create_if_block_1$j];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (!/*media*/ ctx[1] || typeof /*media*/ ctx[1].id === "undefined") return 0;
    		if (typeof /*media*/ ctx[1].id === "number") return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$2();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$I.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$I($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("DownloadAttachment", slots, []);
    	let { attachment } = $$props;
    	let media;
    	const mediaStore = writable({});

    	mediaStore.subscribe(value => {
    		if (!media || media.id !== value.id) $$invalidate(1, media = value);
    	});

    	async function loadMedia() {
    		if (!media || media.key !== attachment) {
    			const backendClient = await dist$1.getBackendClient();
    			const m = await backendClient.mediaService.getMedia(attachment);
    			mediaStore.set(m);
    		}
    	}

    	let icons = { "application/pdf": "fa-file-pdf" };

    	onMount(async () => {
    		await loadMedia();
    	});

    	beforeUpdate(async () => {
    		await loadMedia();
    	});

    	const writable_props = ["attachment"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DownloadAttachment> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("attachment" in $$props) $$invalidate(0, attachment = $$props.attachment);
    	};

    	$$self.$capture_state = () => ({
    		AttachmentHelpers: dist$1.AttachmentHelpers,
    		writable,
    		getBackendClient: dist$1.getBackendClient,
    		beforeUpdate,
    		onMount,
    		LoadingAttachment,
    		attachment,
    		media,
    		mediaStore,
    		loadMedia,
    		icons
    	});

    	$$self.$inject_state = $$props => {
    		if ("attachment" in $$props) $$invalidate(0, attachment = $$props.attachment);
    		if ("media" in $$props) $$invalidate(1, media = $$props.media);
    		if ("icons" in $$props) $$invalidate(2, icons = $$props.icons);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [attachment, media, icons];
    }

    class DownloadAttachment extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$I, create_fragment$I, safe_not_equal, { attachment: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DownloadAttachment",
    			options,
    			id: create_fragment$I.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*attachment*/ ctx[0] === undefined && !("attachment" in props)) {
    			console.warn("<DownloadAttachment> was created without expected prop 'attachment'");
    		}
    	}

    	get attachment() {
    		throw new Error("<DownloadAttachment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set attachment(value) {
    		throw new Error("<DownloadAttachment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    class ChannelContent {
        constructor() {
            this.posts = [];
        }
    }
    class ChannelsCache {
        hasChannel(channelKey) {
            return this.hasOwnProperty(channelKey);
        }
        addChannel(channel) {
            if (!this.hasOwnProperty(channel.key)) {
                const c = new ChannelContent();
                c.key = channel.key;
                c.channel = channel;
                this[channel.key] = c;
            }
        }
    }
    const channelsCache = new ChannelsCache();
    const observableChannelCache = writable(channelsCache);

    const EditableDocumentStore = writable(new Document$1());

    class Helpers {
        static async preloadContentPreview(content) {
            const contentElement = document.createElement('div');
            contentElement.innerHTML = content;
            const backendService = await dist$1.getBackendClient();
            const webThumbnails = contentElement.querySelectorAll('a[data-link=true]');
            const tempCache = globalFEService$1.getService('TempCache');
            for (const link of webThumbnails) {
                const URL = link.getAttribute('href');
                console.log('getting tw for ' + URL);
                if (!tempCache.get(URL)) {
                    const linkPreview = await backendService.utilsService.getWebsiteThumbnail(URL.trim());
                    if (linkPreview) {
                        const media = await backendService.mediaService.getMedia(linkPreview.mediaId);
                        const mediaUrl = dist$1.AttachmentHelpers.getDownloadUrl(media);
                        link.innerHTML = `
                                        <div class="link-preview">
                                            <img src="${mediaUrl}"><div><h6>${linkPreview.title}</h6><br><p>${linkPreview.description}</p></div>
                                        </div>
                                    `;
                        tempCache.put(link.getAttribute('href'), link.innerHTML);
                    }
                }
            }
        }
        static async displayDocument(documentKey) {
            if (documentKey) {
                if (documentKey === 'documents') {
                    const services = await dist$1.getBackendClient();
                    const newDocuments = await services.documentService.findDocument();
                    for (const doc of newDocuments) {
                        doc.author = await services.userService.getUser(doc.ownerId);
                    }
                    observableGenericDataStore.update(s => {
                        s.data = newDocuments;
                        return s;
                    });
                }
                else {
                    observableGenericDataStore.update(s => {
                        s.data = [];
                        return s;
                    });
                }
                DocumentStore.update((store) => {
                    store.key = documentKey;
                    return store;
                });
            }
        }
        static getAttachmentComponent(attachmentMediaType) {
            if (attachmentMediaType) {
                if (attachmentMediaType.indexOf('image') >= 0) {
                    return ImageAttachment;
                }
                else if (attachmentMediaType.indexOf('video') >= 0) {
                    return VideoAttachment;
                }
                else if (attachmentMediaType.indexOf('audio') >= 0) {
                    return AudioAttachment;
                }
            }
            return DownloadAttachment;
        }
        static subscribeToDocumentEvent(eventName, handler) {
            if (Helpers.documentEventsSubscribed.indexOf(eventName) < 0) {
                document.addEventListener(eventName, handler);
                Helpers.documentEventsSubscribed.push(eventName);
            }
        }
        static async getChannelContentAndSubscribe(channelKey) {
            if (channelKey) {
                console.log(`subscribing to ${channelKey} ##`);
                let channel;
                const backendClient = await dist$1.getBackendClient();
                if (!channelsCache.hasChannel(channelKey)) {
                    channel = await backendClient.channelsService.getChannel(channelKey);
                    channelsCache.addChannel(channel);
                }
                channel = channelsCache[channelKey].channel;
                if (channel.isReader) {
                    await backendClient.channelsService.subscribeToChannel(channel.key, async (mc) => {
                        console.log('receiving message from ' + channel.key);
                        if (mc.content) {
                            await Helpers.preloadContentPreview(mc.content);
                        }
                        if (Array.isArray(mc.attachments) && mc.attachments.length > 0) {
                            const attachmentsMetadata = [];
                            for (const a of mc.attachments) {
                                const m = await backendClient.mediaService.getMediaMetadata(a);
                                attachmentsMetadata.push(m);
                            }
                            mc.attachments = attachmentsMetadata;
                        }
                        mc.isNew = true;
                        observableChannelCache.update(occ => {
                            for (const p of occ[channelKey].posts) {
                                p.isNew = false;
                                if (typeof mc.parentPost === 'number' && p.id === mc.parentPost) {
                                    if (typeof p.answerCount !== 'number')
                                        p.answerCount = 0;
                                    p.answerCount++;
                                }
                            }
                            occ[channelKey].posts.push(mc);
                            occ[channelKey].posts.sort((p1, p2) => {
                                if (p1.id > p2.id)
                                    return -1;
                                if (p1.id < p2.id)
                                    return 1;
                                return 0;
                            });
                            return occ;
                        });
                    });
                    channelsCache[channelKey].posts = await backendClient.channelsService.getChannelPosts(channelKey);
                    for (const p of channelsCache[channelKey].posts) {
                        if (p.content) {
                            await Helpers.preloadContentPreview(p.content);
                        }
                        if (Array.isArray(p.attachments) && p.attachments.length > 0) {
                            const attachmentsMetadata = [];
                            for (const a of p.attachments) {
                                const m = await backendClient.mediaService.getMediaMetadata(a);
                                attachmentsMetadata.push(m);
                            }
                            p.attachments = attachmentsMetadata;
                        }
                    }
                }
                observableChannelCache.update(occ => {
                    return occ;
                });
            }
        }
        static getRows(containers) {
            const rows = [];
            if (containers) {
                const rowIndexes = containers.map(c => typeof c.properties.row === 'number' ? c.properties.row : 0).sort();
                const rowUniqueIndexes = [];
                for (const ri of rowIndexes) {
                    if (rowUniqueIndexes.indexOf(ri) < 0)
                        rowUniqueIndexes.push(ri);
                }
                for (const rowIndex of rowUniqueIndexes) {
                    const row = [];
                    for (const colContainer of containers.filter(c => {
                        if (rowIndex === 0)
                            return c.properties.row === rowIndex || typeof c.properties.row === 'undefined' || c.properties.row === null;
                        else
                            return c.properties.row === rowIndex;
                    })) {
                        row.push(colContainer);
                    }
                    row.sort((c1, c2) => {
                        if (c1.properties.col > c2.properties.col)
                            return 1;
                        if (c1.properties.col < c2.properties.col)
                            return -1;
                        return 0;
                    });
                    for (const c of row) {
                        if (!(typeof c.properties.row === 'number')) {
                            c.properties.row = rowIndex;
                        }
                        if ((!(typeof c.properties.col === 'number'))) {
                            if (typeof c.properties.order === 'number') {
                                c.properties.col = c.properties.order;
                            }
                        }
                        else {
                            c.properties.col = row.indexOf(c);
                        }
                    }
                    rows.push(row);
                }
            }
            return rows;
        }
        static getLastRowIndex(containers) {
            if (containers) {
                const rowIndexes = containers.map(c => typeof c.properties.row === 'number' ? c.properties.row : 0).sort();
                return Math.max(...rowIndexes);
            }
            return 0;
        }
        static updateEditableDocumentStore() {
            EditableDocumentStore.update(eds => {
                return eds;
            });
        }
        static getShortDayOfWeekLabel(day) {
            return Helpers.shortLabelsDayOfWeek[day.getDay()];
        }
        static getLongDayOfWeekLabel(day) {
            return Helpers.longLabelsDayOfWeek[day.getDay()];
        }
        static getLongLabelMonth(date) {
            return Helpers.longLabelsMonth[date.getMonth()];
        }
        static fromDateToString(d) {
            const date = d.getDate();
            const month = d.getMonth() + 1;
            const year = d.getFullYear();
            return [year, (month < 10 ? '0' + month : month), (date < 10 ? '0' + date : date)].join('-');
        }
        static fromTimeToString(d) {
            const hour = d.getHours();
            const minutes = d.getMinutes();
            return [hour < 10 ? '0' + hour : hour, minutes < 10 ? '0' + minutes : minutes].join(':');
        }
        static fromStringToDate(dateAsString, timeAsString) {
            const splittedDate = dateAsString.split('-');
            const splittedTime = timeAsString.split(':');
            return new Date(parseInt(splittedDate[0]), parseInt(splittedDate[1]) - 1, parseInt(splittedDate[2]), parseInt(splittedTime[0]), parseInt(splittedTime[1]));
        }
        static fromStringToTime(dateAsString) {
            const splitted = dateAsString.split(':');
            return new Date(parseInt(splitted[0]), parseInt(splitted[1]) - 1, parseInt(splitted[2]));
        }
        static getAllDaysBetween(startDate, endDate) {
            const newDays = [];
            newDays.push(startDate);
            while (newDays.length < endDate.getDate() - 1) {
                const nextDay = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate() + newDays.length);
                if (!newDays.find(d => d === nextDay.getTime()) && nextDay) {
                    newDays.push(nextDay);
                }
            }
            newDays.push(endDate);
            newDays.sort((d1, d2) => {
                if (d1.getTime() > d2.getTime())
                    return 1;
                if (d1.getTime() > d2.getTime())
                    return -1;
                return 0;
            });
            return newDays;
        }
        static getDefaultFields(typeName) {
            if (dist.InterfaceMetadata.hasOwnProperty(typeName)) {
                return dist.InterfaceMetadata[typeName].fields;
            }
            return [];
        }
        static isDescending(typeName) {
            if (dist.InterfaceMetadata.hasOwnProperty(typeName)) {
                return dist.InterfaceMetadata[typeName].isDescending ? true : false;
            }
            return false;
        }
        static getInterfaceLabel(dataType) {
            if (dist.InterfaceMetadata.hasOwnProperty(dataType)) {
                return dist.InterfaceMetadata[dataType].label;
            }
            return 'unknown';
        }
    }
    Helpers.styleOpeningLabel = '<style>';
    Helpers.styleClosingLabel = '</style>';
    Helpers.documentEventsSubscribed = [];
    Helpers.visibilityTooltips = {
        private: "Un document privé n'est accessible et visible que par ses lecteurs et les administrateurs",
        protected: "Un document protégé n'est accessible que par les utilisateurs valides et authentifiés",
        public: "Un document public est accessible par les utilisateurs et les non utilisateurs"
    };
    Helpers.shortLabelsDayOfWeek = ['Dim.', 'Lun.', 'Mar.', 'Mer.', 'Jeu.', 'Ven.', 'Sam.'];
    Helpers.longLabelsDayOfWeek = ['Dimanche', 'Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi'];
    Helpers.longLabelsMonth = ['Janvier', 'Février', 'Mars', 'Avril', 'Mai', 'Juin', 'Juillet', 'Août', 'Septembre', 'Octobre', 'Novembre', 'Décembre'];

    /* src/components/ContentDocumentContainer.svelte generated by Svelte v3.38.2 */
    const file$E = "src/components/ContentDocumentContainer.svelte";

    function get_each_context_2$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    function get_each_context$l(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[1] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    function get_each_context_5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    function get_each_context_3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[1] = list[i];
    	return child_ctx;
    }

    function get_each_context_4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    function get_each_context_8(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    function get_each_context_6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[1] = list[i];
    	return child_ctx;
    }

    function get_each_context_7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    // (66:0) {#if doc}
    function create_if_block$o(ctx) {
    	let div;
    	let div_class_value;
    	let div_style_value;
    	let current;
    	let if_block = /*doc*/ ctx[0] && /*doc*/ ctx[0].content && create_if_block_1$i(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", div_class_value = "container-content " + (/*doc*/ ctx[0].classes ? /*doc*/ ctx[0].classes : "") + " svelte-1ve5fao");
    			attr_dev(div, "style", div_style_value = /*doc*/ ctx[0].style ? /*doc*/ ctx[0].style : "");
    			add_location(div, file$E, 66, 4, 1409);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*doc*/ ctx[0] && /*doc*/ ctx[0].content) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*doc*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$i(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*doc*/ 1 && div_class_value !== (div_class_value = "container-content " + (/*doc*/ ctx[0].classes ? /*doc*/ ctx[0].classes : "") + " svelte-1ve5fao")) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (!current || dirty & /*doc*/ 1 && div_style_value !== (div_style_value = /*doc*/ ctx[0].style ? /*doc*/ ctx[0].style : "")) {
    				attr_dev(div, "style", div_style_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$o.name,
    		type: "if",
    		source: "(66:0) {#if doc}",
    		ctx
    	});

    	return block;
    }

    // (68:4) {#if doc && doc.content}
    function create_if_block_1$i(ctx) {
    	let t0;
    	let show_if_2 = Array.isArray(/*doc*/ ctx[0].content.headers) && /*doc*/ ctx[0].content.headers.length > 0;
    	let t1;
    	let main;
    	let show_if_1 = Array.isArray(/*doc*/ ctx[0].content.bodies);
    	let main_class_value;
    	let t2;
    	let show_if = Array.isArray(/*doc*/ ctx[0].content.footers) && /*doc*/ ctx[0].content.footers.length > 0;
    	let if_block3_anchor;
    	let current;
    	let if_block0 = typeof /*doc*/ ctx[0].content.globalStyle === "string" && create_if_block_8$2(ctx);
    	let if_block1 = show_if_2 && create_if_block_6$3(ctx);
    	let if_block2 = show_if_1 && create_if_block_4$6(ctx);
    	let if_block3 = show_if && create_if_block_2$c(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			main = element("main");
    			if (if_block2) if_block2.c();
    			t2 = space();
    			if (if_block3) if_block3.c();
    			if_block3_anchor = empty$2();

    			attr_dev(main, "class", main_class_value = "" + ((/*doc*/ ctx[0].content.layout && /*doc*/ ctx[0].content.layout.bodies && /*doc*/ ctx[0].content.layout.bodies.type === "grid"
    			? "container"
    			: "") + " document-section document-main" + " svelte-1ve5fao"));

    			add_location(main, file$E, 94, 8, 3010);
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, main, anchor);
    			if (if_block2) if_block2.m(main, null);
    			insert_dev(target, t2, anchor);
    			if (if_block3) if_block3.m(target, anchor);
    			insert_dev(target, if_block3_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (typeof /*doc*/ ctx[0].content.globalStyle === "string") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_8$2(ctx);
    					if_block0.c();
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty & /*doc*/ 1) show_if_2 = Array.isArray(/*doc*/ ctx[0].content.headers) && /*doc*/ ctx[0].content.headers.length > 0;

    			if (show_if_2) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*doc*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_6$3(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t1.parentNode, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*doc*/ 1) show_if_1 = Array.isArray(/*doc*/ ctx[0].content.bodies);

    			if (show_if_1) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*doc*/ 1) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_4$6(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(main, null);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*doc*/ 1 && main_class_value !== (main_class_value = "" + ((/*doc*/ ctx[0].content.layout && /*doc*/ ctx[0].content.layout.bodies && /*doc*/ ctx[0].content.layout.bodies.type === "grid"
    			? "container"
    			: "") + " document-section document-main" + " svelte-1ve5fao"))) {
    				attr_dev(main, "class", main_class_value);
    			}

    			if (dirty & /*doc*/ 1) show_if = Array.isArray(/*doc*/ ctx[0].content.footers) && /*doc*/ ctx[0].content.footers.length > 0;

    			if (show_if) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty & /*doc*/ 1) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_2$c(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(main);
    			if (if_block2) if_block2.d();
    			if (detaching) detach_dev(t2);
    			if (if_block3) if_block3.d(detaching);
    			if (detaching) detach_dev(if_block3_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$i.name,
    		type: "if",
    		source: "(68:4) {#if doc && doc.content}",
    		ctx
    	});

    	return block;
    }

    // (69:8) {#if typeof doc.content.globalStyle === "string"}
    function create_if_block_8$2(ctx) {
    	let html_tag;
    	let raw_value = Helpers.styleOpeningLabel + /*doc*/ ctx[0].content.globalStyle + Helpers.styleClosingLabel + "";
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_anchor = empty$2();
    			html_tag = new HtmlTag(html_anchor);
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(raw_value, target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*doc*/ 1 && raw_value !== (raw_value = Helpers.styleOpeningLabel + /*doc*/ ctx[0].content.globalStyle + Helpers.styleClosingLabel + "")) html_tag.p(raw_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8$2.name,
    		type: "if",
    		source: "(69:8) {#if typeof doc.content.globalStyle === \\\"string\\\"}",
    		ctx
    	});

    	return block;
    }

    // (72:8) {#if Array.isArray(doc.content.headers) && doc.content.headers.length > 0}
    function create_if_block_6$3(ctx) {
    	let header;
    	let current_block_type_index;
    	let if_block;
    	let header_class_value;
    	let current;
    	const if_block_creators = [create_if_block_7$3, create_else_block_2$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*doc*/ ctx[0].content.layout && /*doc*/ ctx[0].content.layout.headers && /*doc*/ ctx[0].content.layout.headers.type === "grid") return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			header = element("header");
    			if_block.c();

    			attr_dev(header, "class", header_class_value = "" + ((/*doc*/ ctx[0].content.layout && /*doc*/ ctx[0].content.layout.headers && /*doc*/ ctx[0].content.layout.headers.type === "grid"
    			? "container"
    			: "") + " document-section document-header" + " svelte-1ve5fao"));

    			add_location(header, file$E, 72, 12, 1799);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, header, anchor);
    			if_blocks[current_block_type_index].m(header, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(header, null);
    			}

    			if (!current || dirty & /*doc*/ 1 && header_class_value !== (header_class_value = "" + ((/*doc*/ ctx[0].content.layout && /*doc*/ ctx[0].content.layout.headers && /*doc*/ ctx[0].content.layout.headers.type === "grid"
    			? "container"
    			: "") + " document-section document-header" + " svelte-1ve5fao"))) {
    				attr_dev(header, "class", header_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(header);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$3.name,
    		type: "if",
    		source: "(72:8) {#if Array.isArray(doc.content.headers) && doc.content.headers.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (88:12) {:else}
    function create_else_block_2$1(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_8 = /*doc*/ ctx[0].content.headers;
    	validate_each_argument(each_value_8);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_8.length; i += 1) {
    		each_blocks[i] = create_each_block_8(get_each_context_8(ctx, each_value_8, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*globalContentContainerFactory, doc*/ 1) {
    				each_value_8 = /*doc*/ ctx[0].content.headers;
    				validate_each_argument(each_value_8);
    				let i;

    				for (i = 0; i < each_value_8.length; i += 1) {
    					const child_ctx = get_each_context_8(ctx, each_value_8, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_8(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_8.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_8.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$1.name,
    		type: "else",
    		source: "(88:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (76:12) {#if doc.content.layout &&             doc.content.layout.headers &&             doc.content.layout.headers.type === 'grid'}
    function create_if_block_7$3(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_6 = Helpers.getRows(/*doc*/ ctx[0].content.headers);
    	validate_each_argument(each_value_6);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_6.length; i += 1) {
    		each_blocks[i] = create_each_block_6(get_each_context_6(ctx, each_value_6, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*Helpers, doc, globalContentContainerFactory*/ 1) {
    				each_value_6 = Helpers.getRows(/*doc*/ ctx[0].content.headers);
    				validate_each_argument(each_value_6);
    				let i;

    				for (i = 0; i < each_value_6.length; i += 1) {
    					const child_ctx = get_each_context_6(ctx, each_value_6, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_6(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_6.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_6.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$3.name,
    		type: "if",
    		source: "(76:12) {#if doc.content.layout &&             doc.content.layout.headers &&             doc.content.layout.headers.type === 'grid'}",
    		ctx
    	});

    	return block;
    }

    // (89:16) {#each doc.content.headers as container}
    function create_each_block_8(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = globalContentContainerFactory.getComponent(/*container*/ ctx[4].type);

    	function switch_props(ctx) {
    		return {
    			props: {
    				properties: /*container*/ ctx[4].properties
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty & /*doc*/ 1) switch_instance_changes.properties = /*container*/ ctx[4].properties;

    			if (switch_value !== (switch_value = globalContentContainerFactory.getComponent(/*container*/ ctx[4].type))) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_8.name,
    		type: "each",
    		source: "(89:16) {#each doc.content.headers as container}",
    		ctx
    	});

    	return block;
    }

    // (81:24) {#each row as container}
    function create_each_block_7(ctx) {
    	let div;
    	let switch_instance;
    	let div_class_value;
    	let current;
    	var switch_value = globalContentContainerFactory.getComponent(/*container*/ ctx[4].type);

    	function switch_props(ctx) {
    		return {
    			props: {
    				properties: /*container*/ ctx[4].properties
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);

    			attr_dev(div, "class", div_class_value = "" + (null_to_empty(/*container*/ ctx[4].colSpan
    			? `col-${/*container*/ ctx[4].colSpan}`
    			: "col") + " svelte-1ve5fao"));

    			add_location(div, file$E, 81, 28, 2325);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty & /*doc*/ 1) switch_instance_changes.properties = /*container*/ ctx[4].properties;

    			if (switch_value !== (switch_value = globalContentContainerFactory.getComponent(/*container*/ ctx[4].type))) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div, null);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}

    			if (!current || dirty & /*doc*/ 1 && div_class_value !== (div_class_value = "" + (null_to_empty(/*container*/ ctx[4].colSpan
    			? `col-${/*container*/ ctx[4].colSpan}`
    			: "col") + " svelte-1ve5fao"))) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (switch_instance) destroy_component(switch_instance);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_7.name,
    		type: "each",
    		source: "(81:24) {#each row as container}",
    		ctx
    	});

    	return block;
    }

    // (79:16) {#each Helpers.getRows(doc.content.headers) as row}
    function create_each_block_6(ctx) {
    	let div;
    	let t;
    	let current;
    	let each_value_7 = /*row*/ ctx[1];
    	validate_each_argument(each_value_7);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_7.length; i += 1) {
    		each_blocks[i] = create_each_block_7(get_each_context_7(ctx, each_value_7, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			attr_dev(div, "class", "row");
    			add_location(div, file$E, 79, 20, 2230);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			append_dev(div, t);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*Helpers, doc, globalContentContainerFactory*/ 1) {
    				each_value_7 = /*row*/ ctx[1];
    				validate_each_argument(each_value_7);
    				let i;

    				for (i = 0; i < each_value_7.length; i += 1) {
    					const child_ctx = get_each_context_7(ctx, each_value_7, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_7(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, t);
    					}
    				}

    				group_outros();

    				for (i = each_value_7.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_7.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_6.name,
    		type: "each",
    		source: "(79:16) {#each Helpers.getRows(doc.content.headers) as row}",
    		ctx
    	});

    	return block;
    }

    // (98:12) {#if Array.isArray(doc.content.bodies)}
    function create_if_block_4$6(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_5$4, create_else_block_1$3];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*doc*/ ctx[0].content.layout && /*doc*/ ctx[0].content.layout.bodies && /*doc*/ ctx[0].content.layout.bodies.type === "grid") return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$6.name,
    		type: "if",
    		source: "(98:12) {#if Array.isArray(doc.content.bodies)}",
    		ctx
    	});

    	return block;
    }

    // (111:16) {:else}
    function create_else_block_1$3(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_5 = /*doc*/ ctx[0].content.bodies;
    	validate_each_argument(each_value_5);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_5.length; i += 1) {
    		each_blocks[i] = create_each_block_5(get_each_context_5(ctx, each_value_5, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*globalContentContainerFactory, doc*/ 1) {
    				each_value_5 = /*doc*/ ctx[0].content.bodies;
    				validate_each_argument(each_value_5);
    				let i;

    				for (i = 0; i < each_value_5.length; i += 1) {
    					const child_ctx = get_each_context_5(ctx, each_value_5, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_5(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_5.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_5.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$3.name,
    		type: "else",
    		source: "(111:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (99:16) {#if doc.content.layout &&                      doc.content.layout.bodies &&                      doc.content.layout.bodies.type === 'grid'}
    function create_if_block_5$4(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_3 = Helpers.getRows(/*doc*/ ctx[0].content.bodies);
    	validate_each_argument(each_value_3);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*Helpers, doc, globalContentContainerFactory*/ 1) {
    				each_value_3 = Helpers.getRows(/*doc*/ ctx[0].content.bodies);
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3(ctx, each_value_3, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_3(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_3.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_3.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$4.name,
    		type: "if",
    		source: "(99:16) {#if doc.content.layout &&                      doc.content.layout.bodies &&                      doc.content.layout.bodies.type === 'grid'}",
    		ctx
    	});

    	return block;
    }

    // (112:20) {#each doc.content.bodies as container}
    function create_each_block_5(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = globalContentContainerFactory.getComponent(/*container*/ ctx[4].type);

    	function switch_props(ctx) {
    		return {
    			props: {
    				properties: /*container*/ ctx[4].properties
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty & /*doc*/ 1) switch_instance_changes.properties = /*container*/ ctx[4].properties;

    			if (switch_value !== (switch_value = globalContentContainerFactory.getComponent(/*container*/ ctx[4].type))) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_5.name,
    		type: "each",
    		source: "(112:20) {#each doc.content.bodies as container}",
    		ctx
    	});

    	return block;
    }

    // (104:28) {#each row as container}
    function create_each_block_4(ctx) {
    	let div;
    	let switch_instance;
    	let div_class_value;
    	let current;
    	var switch_value = globalContentContainerFactory.getComponent(/*container*/ ctx[4].type);

    	function switch_props(ctx) {
    		return {
    			props: {
    				properties: /*container*/ ctx[4].properties
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);

    			attr_dev(div, "class", div_class_value = "" + (null_to_empty(/*container*/ ctx[4].colSpan
    			? `col-${/*container*/ ctx[4].colSpan}`
    			: "col") + " svelte-1ve5fao"));

    			add_location(div, file$E, 104, 32, 3617);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty & /*doc*/ 1) switch_instance_changes.properties = /*container*/ ctx[4].properties;

    			if (switch_value !== (switch_value = globalContentContainerFactory.getComponent(/*container*/ ctx[4].type))) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div, null);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}

    			if (!current || dirty & /*doc*/ 1 && div_class_value !== (div_class_value = "" + (null_to_empty(/*container*/ ctx[4].colSpan
    			? `col-${/*container*/ ctx[4].colSpan}`
    			: "col") + " svelte-1ve5fao"))) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (switch_instance) destroy_component(switch_instance);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_4.name,
    		type: "each",
    		source: "(104:28) {#each row as container}",
    		ctx
    	});

    	return block;
    }

    // (102:20) {#each Helpers.getRows(doc.content.bodies) as row}
    function create_each_block_3(ctx) {
    	let div;
    	let t;
    	let current;
    	let each_value_4 = /*row*/ ctx[1];
    	validate_each_argument(each_value_4);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_4.length; i += 1) {
    		each_blocks[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			attr_dev(div, "class", "row");
    			add_location(div, file$E, 102, 24, 3514);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			append_dev(div, t);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*Helpers, doc, globalContentContainerFactory*/ 1) {
    				each_value_4 = /*row*/ ctx[1];
    				validate_each_argument(each_value_4);
    				let i;

    				for (i = 0; i < each_value_4.length; i += 1) {
    					const child_ctx = get_each_context_4(ctx, each_value_4, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_4(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, t);
    					}
    				}

    				group_outros();

    				for (i = each_value_4.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_4.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3.name,
    		type: "each",
    		source: "(102:20) {#each Helpers.getRows(doc.content.bodies) as row}",
    		ctx
    	});

    	return block;
    }

    // (118:8) {#if Array.isArray(doc.content.footers) && doc.content.footers.length > 0}
    function create_if_block_2$c(ctx) {
    	let footer;
    	let current_block_type_index;
    	let if_block;
    	let footer_class_value;
    	let current;
    	const if_block_creators = [create_if_block_3$8, create_else_block$9];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*doc*/ ctx[0].content.layout && /*doc*/ ctx[0].content.layout.footers && /*doc*/ ctx[0].content.layout.footers.type === "grid") return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_2(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			footer = element("footer");
    			if_block.c();

    			attr_dev(footer, "class", footer_class_value = "" + ((/*doc*/ ctx[0].content.layout && /*doc*/ ctx[0].content.layout.footers && /*doc*/ ctx[0].content.layout.footers.type === "grid"
    			? "container"
    			: "") + " document-section document-footer" + " svelte-1ve5fao"));

    			add_location(footer, file$E, 118, 12, 4426);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, footer, anchor);
    			if_blocks[current_block_type_index].m(footer, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(footer, null);
    			}

    			if (!current || dirty & /*doc*/ 1 && footer_class_value !== (footer_class_value = "" + ((/*doc*/ ctx[0].content.layout && /*doc*/ ctx[0].content.layout.footers && /*doc*/ ctx[0].content.layout.footers.type === "grid"
    			? "container"
    			: "") + " document-section document-footer" + " svelte-1ve5fao"))) {
    				attr_dev(footer, "class", footer_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(footer);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$c.name,
    		type: "if",
    		source: "(118:8) {#if Array.isArray(doc.content.footers) && doc.content.footers.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (134:12) {:else}
    function create_else_block$9(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_2 = /*doc*/ ctx[0].content.footers;
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2$2(get_each_context_2$2(ctx, each_value_2, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*globalContentContainerFactory, doc*/ 1) {
    				each_value_2 = /*doc*/ ctx[0].content.footers;
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$2(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_2$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_2.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_2.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$9.name,
    		type: "else",
    		source: "(134:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (122:12) {#if doc.content.layout &&             doc.content.layout.footers &&             doc.content.layout.footers.type === 'grid'}
    function create_if_block_3$8(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = Helpers.getRows(/*doc*/ ctx[0].content.footers);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$l(get_each_context$l(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*Helpers, doc, globalContentContainerFactory*/ 1) {
    				each_value = Helpers.getRows(/*doc*/ ctx[0].content.footers);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$l(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$l(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$8.name,
    		type: "if",
    		source: "(122:12) {#if doc.content.layout &&             doc.content.layout.footers &&             doc.content.layout.footers.type === 'grid'}",
    		ctx
    	});

    	return block;
    }

    // (135:16) {#each doc.content.footers as container}
    function create_each_block_2$2(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = globalContentContainerFactory.getComponent(/*container*/ ctx[4].type);

    	function switch_props(ctx) {
    		return {
    			props: {
    				properties: /*container*/ ctx[4].properties
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty & /*doc*/ 1) switch_instance_changes.properties = /*container*/ ctx[4].properties;

    			if (switch_value !== (switch_value = globalContentContainerFactory.getComponent(/*container*/ ctx[4].type))) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$2.name,
    		type: "each",
    		source: "(135:16) {#each doc.content.footers as container}",
    		ctx
    	});

    	return block;
    }

    // (127:24) {#each row as container}
    function create_each_block_1$4(ctx) {
    	let div;
    	let switch_instance;
    	let div_class_value;
    	let current;
    	var switch_value = globalContentContainerFactory.getComponent(/*container*/ ctx[4].type);

    	function switch_props(ctx) {
    		return {
    			props: {
    				properties: /*container*/ ctx[4].properties
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);

    			attr_dev(div, "class", div_class_value = "" + (null_to_empty(/*container*/ ctx[4].colSpan
    			? `col-${/*container*/ ctx[4].colSpan}`
    			: "col") + " svelte-1ve5fao"));

    			add_location(div, file$E, 127, 28, 4952);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty & /*doc*/ 1) switch_instance_changes.properties = /*container*/ ctx[4].properties;

    			if (switch_value !== (switch_value = globalContentContainerFactory.getComponent(/*container*/ ctx[4].type))) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div, null);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}

    			if (!current || dirty & /*doc*/ 1 && div_class_value !== (div_class_value = "" + (null_to_empty(/*container*/ ctx[4].colSpan
    			? `col-${/*container*/ ctx[4].colSpan}`
    			: "col") + " svelte-1ve5fao"))) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (switch_instance) destroy_component(switch_instance);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$4.name,
    		type: "each",
    		source: "(127:24) {#each row as container}",
    		ctx
    	});

    	return block;
    }

    // (125:16) {#each Helpers.getRows(doc.content.footers) as row}
    function create_each_block$l(ctx) {
    	let div;
    	let t;
    	let current;
    	let each_value_1 = /*row*/ ctx[1];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$4(get_each_context_1$4(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			attr_dev(div, "class", "row");
    			add_location(div, file$E, 125, 20, 4857);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			append_dev(div, t);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*Helpers, doc, globalContentContainerFactory*/ 1) {
    				each_value_1 = /*row*/ ctx[1];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$4(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$4(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, t);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$l.name,
    		type: "each",
    		source: "(125:16) {#each Helpers.getRows(doc.content.footers) as row}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$H(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*doc*/ ctx[0] && create_if_block$o(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$2();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*doc*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*doc*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$o(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$H.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$H($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ContentDocumentContainer", slots, []);
    	let { doc } = $$props;
    	const writable_props = ["doc"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ContentDocumentContainer> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("doc" in $$props) $$invalidate(0, doc = $$props.doc);
    	};

    	$$self.$capture_state = () => ({
    		globalContentContainerFactory,
    		getBackendClient: dist$1.getBackendClient,
    		beforeUpdate,
    		onMount,
    		Helpers,
    		doc
    	});

    	$$self.$inject_state = $$props => {
    		if ("doc" in $$props) $$invalidate(0, doc = $$props.doc);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [doc];
    }

    class ContentDocumentContainer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$H, create_fragment$H, safe_not_equal, { doc: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ContentDocumentContainer",
    			options,
    			id: create_fragment$H.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*doc*/ ctx[0] === undefined && !("doc" in props)) {
    			console.warn("<ContentDocumentContainer> was created without expected prop 'doc'");
    		}
    	}

    	get doc() {
    		throw new Error("<ContentDocumentContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set doc(value) {
    		throw new Error("<ContentDocumentContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/ContentTextContainer.svelte generated by Svelte v3.38.2 */
    const file$D = "src/components/ContentTextContainer.svelte";

    // (23:4) {#if properties.globalStyle}
    function create_if_block_1$h(ctx) {
    	let html_tag;
    	let raw_value = Helpers.styleOpeningLabel + /*properties*/ ctx[0].innerStyle + Helpers.styleClosingLabel + "";
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_anchor = empty$2();
    			html_tag = new HtmlTag(html_anchor);
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(raw_value, target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*properties*/ 1 && raw_value !== (raw_value = Helpers.styleOpeningLabel + /*properties*/ ctx[0].innerStyle + Helpers.styleClosingLabel + "")) html_tag.p(raw_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$h.name,
    		type: "if",
    		source: "(23:4) {#if properties.globalStyle}",
    		ctx
    	});

    	return block;
    }

    // (26:4) {#if properties.content}
    function create_if_block$n(ctx) {
    	let html_tag;
    	let raw_value = /*properties*/ ctx[0].content + "";
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_anchor = empty$2();
    			html_tag = new HtmlTag(html_anchor);
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(raw_value, target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*properties*/ 1 && raw_value !== (raw_value = /*properties*/ ctx[0].content + "")) html_tag.p(raw_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$n.name,
    		type: "if",
    		source: "(26:4) {#if properties.content}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$G(ctx) {
    	let div;
    	let t;
    	let div_class_value;
    	let div_style_value;
    	let if_block0 = /*properties*/ ctx[0].globalStyle && create_if_block_1$h(ctx);
    	let if_block1 = /*properties*/ ctx[0].content && create_if_block$n(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();

    			attr_dev(div, "class", div_class_value = "default-style-text-container " + (/*properties*/ ctx[0].classes
    			? /*properties*/ ctx[0].classes
    			: "") + " svelte-1dtqluv");

    			attr_dev(div, "style", div_style_value = /*properties*/ ctx[0].style
    			? /*properties*/ ctx[0].style
    			: "");

    			add_location(div, file$D, 20, 0, 421);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t);
    			if (if_block1) if_block1.m(div, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*properties*/ ctx[0].globalStyle) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_1$h(ctx);
    					if_block0.c();
    					if_block0.m(div, t);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*properties*/ ctx[0].content) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$n(ctx);
    					if_block1.c();
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty & /*properties*/ 1 && div_class_value !== (div_class_value = "default-style-text-container " + (/*properties*/ ctx[0].classes
    			? /*properties*/ ctx[0].classes
    			: "") + " svelte-1dtqluv")) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (dirty & /*properties*/ 1 && div_style_value !== (div_style_value = /*properties*/ ctx[0].style
    			? /*properties*/ ctx[0].style
    			: "")) {
    				attr_dev(div, "style", div_style_value);
    			}
    		},
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$G.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$G($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ContentTextContainer", slots, []);
    	let { properties } = $$props;
    	const writable_props = ["properties"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ContentTextContainer> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("properties" in $$props) $$invalidate(0, properties = $$props.properties);
    	};

    	$$self.$capture_state = () => ({ Helpers, properties });

    	$$self.$inject_state = $$props => {
    		if ("properties" in $$props) $$invalidate(0, properties = $$props.properties);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [properties];
    }

    class ContentTextContainer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$G, create_fragment$G, safe_not_equal, { properties: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ContentTextContainer",
    			options,
    			id: create_fragment$G.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*properties*/ ctx[0] === undefined && !("properties" in props)) {
    			console.warn("<ContentTextContainer> was created without expected prop 'properties'");
    		}
    	}

    	get properties() {
    		throw new Error("<ContentTextContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set properties(value) {
    		throw new Error("<ContentTextContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    let t = {};

    const exec = (command, value = null) => {
      document.execCommand(command, false, value);
    };

    const getTagsRecursive = (element, tags) => {
      tags = tags || (element && element.tagName ? [element.tagName] : []);

      if (element && element.parentNode) {
        element = element.parentNode;
      } else {
        return tags;
      }

      const tag = element.tagName;
      if (element.style && element.getAttribute) {
        [element.style.textAlign || element.getAttribute('align'), element.style.color || tag === 'FONT' && 'forecolor', element.style.backgroundColor && 'backcolor']
          .filter((item) => item)
          .forEach((item) => tags.push(item));
      }

      if (tag === 'DIV') {
        return tags;
      }

      tags.push(tag);

      return getTagsRecursive(element, tags).filter((_tag) => _tag != null);
    };

    const saveRange = (editor) => {
      const documentSelection = document.getSelection();

      t.range = null;

      if (documentSelection.rangeCount) {
        let savedRange = t.range = documentSelection.getRangeAt(0);
        let range = document.createRange();
        let rangeStart;
        range.selectNodeContents(editor);
        range.setEnd(savedRange.startContainer, savedRange.startOffset);
        rangeStart = (range + '').length;
        t.metaRange = {
          start: rangeStart,
          end: rangeStart + (savedRange + '').length
        };
      }
    };
    const restoreRange = (editor) => {
      let metaRange = t.metaRange;
      let savedRange = t.range;
      let documentSelection = document.getSelection();
      let range;

      if (!savedRange) {
        return;
      }

      if (metaRange && metaRange.start !== metaRange.end) { // Algorithm from http://jsfiddle.net/WeWy7/3/
        let charIndex = 0,
            nodeStack = [editor],
            node,
            foundStart = false,
            stop = false;

        range = document.createRange();

        while (!stop && (node = nodeStack.pop())) {
          if (node.nodeType === 3) {
            let nextCharIndex = charIndex + node.length;
            if (!foundStart && metaRange.start >= charIndex && metaRange.start <= nextCharIndex) {
              range.setStart(node, metaRange.start - charIndex);
              foundStart = true;
            }
            if (foundStart && metaRange.end >= charIndex && metaRange.end <= nextCharIndex) {
              range.setEnd(node, metaRange.end - charIndex);
              stop = true;
            }
            charIndex = nextCharIndex;
          } else {
            let cn = node.childNodes;
            let i = cn.length;

            while (i > 0) {
              i -= 1;
              nodeStack.push(cn[i]);
            }
          }
        }
      }

      documentSelection.removeAllRanges();
      documentSelection.addRange(range || savedRange);
    };

    const cleanHtml = (input) => {
      const html = input.match(/<!--StartFragment-->(.*?)<!--EndFragment-->/);
      let output = html && html[1] || input;
      output = output
        .replace(/\r?\n|\r/g, ' ')
        .replace(/<!--(.*?)-->/g, '')
        .replace(new RegExp('<(/)*(meta|link|span|\\?xml:|st1:|o:|font|w:sdt)(.*?)>', 'gi'), '')
        .replace(/<!\[if !supportLists\]>(.*?)<!\[endif\]>/gi, '')
        .replace(/style="[^"]*"/gi, '')
        .replace(/style='[^']*'/gi, '')
        .replace(/&nbsp;/gi, ' ')
        .replace(/>(\s+)</g, '><')
        .replace(/class="[^"]*"/gi, '')
        .replace(/class='[^']*'/gi, '')
        .replace(/<[^/].*?>/g, i => i.split(/[ >]/g)[0] + '>')
        .trim();

        output = removeBadTags(output);
        return output;
    };

    const unwrap = (wrapper) => {
    	const docFrag = document.createDocumentFragment();
    	while (wrapper.firstChild) {
    		const child = wrapper.removeChild(wrapper.firstChild);
    		docFrag.appendChild(child);
    	}

    	// replace wrapper with document fragment
    	wrapper.parentNode.replaceChild(docFrag, wrapper);
    };

    const removeBlockTagsRecursive = (elements, tagsToRemove) => {
      Array.from(elements).forEach((item) => {
        if (tagsToRemove.some((tag) => tag === item.tagName.toLowerCase())) {
          if (item.children.length) {
            removeBlockTagsRecursive(item.children, tagsToRemove);
          }
          unwrap(item);
        }
      });
    };

    const getActionBtns = (actions) => {
      return Object.keys(actions).map((action) => actions[action]);
    };

    const getNewActionObj = (actions, userActions = []) => {
        if (userActions && userActions.length) {
          const newActions = {};
          userActions.forEach((action) => {
            if (typeof action === 'string') {
              newActions[action] = Object.assign({}, actions[action]);
            } else if (actions[action.name]) {
              newActions[action.name] = Object.assign(actions[action.name], action);
            } else {
              newActions[action.name] = Object.assign({}, action);
            }
          });

          return newActions;
        } else {
          return actions;
        }
    };

    const removeBadTags = (html) => {
      ['style', 'script', 'applet', 'embed', 'noframes', 'noscript'].forEach((badTag) => {
        html = html.replace(new RegExp(`<${badTag}.*?${badTag}(.*?)>`, 'gi'), '');
      });

      return html;
    };

    const isEditorClick = (target, editorWrapper) => {
      if (target === editorWrapper) {
        return true;
      }
      if (target.parentElement) {
        return isEditorClick(target.parentElement, editorWrapper);
      }
      return false;
    };

    const linkSvg =
    	'<svg viewBox="0 0 72 72" width="17px" height="100%"><path d="M31.1 48.9l-6.7 6.7c-.8.8-1.6.9-2.1.9s-1.4-.1-2.1-.9L15 50.4c-1.1-1.1-1.1-3.1 0-4.2l6.1-6.1.2-.2 6.5-6.5c-1.2-.6-2.5-.9-3.8-.9-2.3 0-4.6.9-6.3 2.6L11 41.8c-3.5 3.5-3.5 9.2 0 12.7l5.2 5.2c1.7 1.7 4 2.6 6.3 2.6s4.6-.9 6.3-2.6l6.7-6.7c2.5-2.6 3.1-6.7 1.5-10l-5.9 5.9zM38.7 22.5l6.7-6.7c.8-.8 1.6-.9 2.1-.9s1.4.1 2.1.9l5.2 5.2c1.1 1.1 1.1 3.1 0 4.2l-6.1 6.1-.2.2L42 38c1.2.6 2.5.9 3.8.9 2.3 0 4.6-.9 6.3-2.6l6.7-6.7c3.5-3.5 3.5-9.2 0-12.7l-5.2-5.2c-1.7-1.7-4-2.6-6.3-2.6s-4.6.9-6.3 2.6l-6.7 6.7c-2.7 2.7-3.3 6.9-1.7 10.2l6.1-6.1c0 .1 0 .1 0 0z"></path><path d="M44.2 30.5c.2-.2.4-.6.4-.9 0-.3-.1-.6-.4-.9l-2.3-2.3c-.3-.2-.6-.4-.9-.4-.3 0-.6.1-.9.4L25.9 40.6c-.2.2-.4.6-.4.9 0 .3.1.6.4.9l2.3 2.3c.2.2.6.4.9.4.3 0 .6-.1.9-.4l14.2-14.2zM49.9 55.4h-8.5v-5h8.5v-8.9h5.2v8.9h8.5v5h-8.5v8.9h-5.2v-8.9z"></path></svg>';
    const unlinkSvg =
    	'<svg viewBox="0 0 72 72" width="17px" height="100%"><path d="M30.9 49.1l-6.7 6.7c-.8.8-1.6.9-2.1.9s-1.4-.1-2.1-.9l-5.2-5.2c-1.1-1.1-1.1-3.1 0-4.2l6.1-6.1.2-.2 6.5-6.5c-1.2-.6-2.5-.9-3.8-.9-2.3 0-4.6.9-6.3 2.6L10.8 42c-3.5 3.5-3.5 9.2 0 12.7l5.2 5.2c1.7 1.7 4 2.6 6.3 2.6s4.6-.9 6.3-2.6l6.7-6.7C38 50.5 38.6 46.3 37 43l-6.1 6.1zM38.5 22.7l6.7-6.7c.8-.8 1.6-.9 2.1-.9s1.4.1 2.1.9l5.2 5.2c1.1 1.1 1.1 3.1 0 4.2l-6.1 6.1-.2.2-6.5 6.5c1.2.6 2.5.9 3.8.9 2.3 0 4.6-.9 6.3-2.6l6.7-6.7c3.5-3.5 3.5-9.2 0-12.7l-5.2-5.2c-1.7-1.7-4-2.6-6.3-2.6s-4.6.9-6.3 2.6l-6.7 6.7c-2.7 2.7-3.3 6.9-1.7 10.2l6.1-6.1z"></path><path d="M44.1 30.7c.2-.2.4-.6.4-.9 0-.3-.1-.6-.4-.9l-2.3-2.3c-.2-.2-.6-.4-.9-.4-.3 0-.6.1-.9.4L25.8 40.8c-.2.2-.4.6-.4.9 0 .3.1.6.4.9l2.3 2.3c.2.2.6.4.9.4.3 0 .6-.1.9-.4l14.2-14.2zM41.3 55.8v-5h22.2v5H41.3z"></path></svg>';

    var defaultActions = {
    	viewHtml: {
    		icon:
    			'<svg viewBox="0 0 72 72" width="17px" height="100%"><path fill="none" stroke="currentColor" stroke-width="8" stroke-miterlimit="10" d="M26.9 17.9L9 36.2 26.9 54M45 54l17.9-18.3L45 17.9"></path></svg>',
    		title: "View HTML",
    		result: function() {
    			let refs = get_store_value(this.references);
    			let actionObj = get_store_value(this.state).actionObj;
    			let helper = get_store_value(this.helper);

    			helper.showEditor = !helper.showEditor;
    			refs.editor.style.display = helper.showEditor ? "block" : "none";
    			refs.raw.style.display = helper.showEditor ? "none" : "block";
    			if (helper.showEditor) {
    				refs.editor.innerHTML = refs.raw.value;
    			} else {
    				refs.raw.value = refs.editor.innerHTML;
    			}
    			setTimeout(() => {
    				Object.keys(actionObj).forEach(
    					action => (actionObj[action].disabled = !helper.showEditor)
    				);
    				actionObj.viewHtml.disabled = false;
    				actionObj.viewHtml.active = !helper.showEditor;

    				this.state.update(state => {
    					state.actionBtns = getActionBtns(actionObj);
    					state.actionObj = actionObj;
    					return state;
    				});
    			});
    		}
    	},
    	undo: {
    		icon:
    			'<svg viewBox="0 0 72 72" width="17px" height="100%"><path d="M61.2 51.2c0-5.1-2.1-9.7-5.4-13.1-3.3-3.3-8-5.4-13.1-5.4H26.1v-12L10.8 36l15.3 15.3V39.1h16.7c3.3 0 6.4 1.3 8.5 3.5 2.2 2.2 3.5 5.2 3.5 8.5h6.4z"></path></svg>',
    		title: "Undo",
    		result: () => exec("undo")
    	},
    	redo: {
    		icon:
    			'<svg viewBox="0 0 72 72" width="17px" height="100%"><path d="M10.8 51.2c0-5.1 2.1-9.7 5.4-13.1 3.3-3.3 8-5.4 13.1-5.4H46v-12L61.3 36 45.9 51.3V39.1H29.3c-3.3 0-6.4 1.3-8.5 3.5-2.2 2.2-3.5 5.2-3.5 8.5h-6.5z"></path></svg>',
    		title: "Redo",
    		result: () => exec("redo")
    	},
    	b: {
    		icon: "<b>B</b>",
    		title: "Bold",
    		result: () => exec("bold")
    	},
    	i: {
    		icon: "<i>I</i>",
    		title: "Italic",
    		result: () => exec("italic")
    	},
    	u: {
    		icon: "<u>U</u>",
    		title: "Underline",
    		result: () => exec("underline")
    	},
    	strike: {
    		icon: "<strike>S</strike>",
    		title: "Strike-through",
    		result: () => exec("strikeThrough")
    	},
    	sup: {
    		icon: "A<sup>2</sup>",
    		title: "Superscript",
    		result: () => exec("superscript")
    	},
    	sub: {
    		icon: "A<sub>2</sub>",
    		title: "Subscript",
    		result: () => exec("subscript")
    	},
    	h1: {
    		icon: "<b>H<sub>1</sub></b>",
    		title: "Heading 1",
    		result: () => exec("formatBlock", "<H1>")
    	},
    	h2: {
    		icon: "<b>H<sub>2</sub></b>",
    		title: "Heading 2",
    		result: () => exec("formatBlock", "<H2>")
    	},
    	p: {
    		icon: "&#182;",
    		title: "Paragraph",
    		result: () => exec("formatBlock", "<P>")
    	},
    	blockquote: {
    		icon: "&#8220; &#8221;",
    		title: "Quote",
    		result: () => exec("formatBlock", "<BLOCKQUOTE>")
    	},
    	ol: {
    		icon:
    			'<svg viewBox="0 0 72 72" width="17px" height="100%"><path d="M27 14h36v8H27zM27 50h36v8H27zM27 32h36v8H27zM11.8 15.8V22h1.8v-7.8h-1.5l-2.1 1 .3 1.3zM12.1 38.5l.7-.6c1.1-1 2.1-2.1 2.1-3.4 0-1.4-1-2.4-2.7-2.4-1.1 0-2 .4-2.6.8l.5 1.3c.4-.3 1-.6 1.7-.6.9 0 1.3.5 1.3 1.1 0 .9-.9 1.8-2.6 3.3l-1 .9V40H15v-1.5h-2.9zM13.3 53.9c1-.4 1.4-1 1.4-1.8 0-1.1-.9-1.9-2.6-1.9-1 0-1.9.3-2.4.6l.4 1.3c.3-.2 1-.5 1.6-.5.8 0 1.2.3 1.2.8 0 .7-.8.9-1.4.9h-.7v1.3h.7c.8 0 1.6.3 1.6 1.1 0 .6-.5 1-1.4 1-.7 0-1.5-.3-1.8-.5l-.4 1.4c.5.3 1.3.6 2.3.6 2 0 3.2-1 3.2-2.4 0-1.1-.8-1.8-1.7-1.9z"></path></svg>',
    		title: "Ordered List",
    		result: () => exec("insertOrderedList")
    	},
    	ul: {
    		icon:
    			'<svg viewBox="0 0 72 72" width="17px" height="100%"><path d="M27 14h36v8H27zM27 50h36v8H27zM9 50h9v8H9zM9 32h9v8H9zM9 14h9v8H9zM27 32h36v8H27z"></path></svg>',
    		title: "Unordered List",
    		result: () => exec("insertUnorderedList")
    	},
    	hr: {
    		icon: "&#8213;",
    		title: "Horizontal Line",
    		result: () => exec("insertHorizontalRule")
    	},
    	left: {
    		icon:
    			'<svg viewBox="0 0 72 72" width="17px" height="100%"><path d="M9 14h54v8H9zM9 50h54v8H9zM9 32h36v8H9z"></path></svg>',
    		title: "Justify left",
    		result: () => exec("justifyLeft")
    	},
    	right: {
    		icon:
    			'<svg viewBox="0 0 72 72" width="17px" height="100%"><path d="M9 14h54v8H9zM9 50h54v8H9zM27 32h36v8H27z"></path></svg>',
    		title: "Justify right",
    		result: () => exec("justifyRight")
    	},
    	center: {
    		icon:
    			'<svg viewBox="0 0 72 72" width="17px" height="100%"><path d="M9 14h54v8H9zM9 50h54v8H9zM18 32h36v8H18z"></path></svg>',
    		title: "Justify center",
    		result: () => exec("justifyCenter")
    	},
    	justify: {
    		icon:
    			'<svg viewBox="0 0 72 72" width="17px" height="100%"><path d="M9 14h54v8H9zM9 50h54v8H9zM9 32h54v8H9z"></path></svg>',
    		title: "Justify full",
    		result: () => exec("justifyFull")
    	},
    	a: {
    		icon: linkSvg,
    		title: "Insert link",
    		result: function() {
    			const actionObj = get_store_value(this.state).actionObj;
    			const refs = get_store_value(this.references);

    			if (actionObj.a.active) {
    				const selection = window.getSelection();
    				const range = document.createRange();
    				range.selectNodeContents(document.getSelection().focusNode);
    				selection.removeAllRanges();
    				selection.addRange(range);
    				exec("unlink");
    				actionObj.a.title = "Insert link";
    				actionObj.a.icon = linkSvg;
    				this.state.update(state => {
    					state.actionBtn = getActionBtns(actionObj);
    					state.actionObj = actionObj;
    					return state;
    				});
    			} else {
    				saveRange(refs.editor);
    				refs.modal.$set({
    					show: true,
    					event: "linkUrl",
    					title: "Insert link",
    					label: "Url"
    				});
    				if (!get_store_value(this.helper).link) {
    					this.helper.update(state => {
    						state.link = true;
    						return state;
    					});
    					refs.modal.$on("linkUrl", event => {
    						restoreRange(refs.editor);
    						exec("createLink", event.detail);
    						actionObj.a.title = "Unlink";
    						actionObj.a.icon = unlinkSvg;

    						this.state.update(state => {
    							state.actionBtn = getActionBtns(actionObj);
    							state.actionObj = actionObj;
    							return state;
    						});
    					});
    				}
    			}
    		}
    	},
    	image: {
    		icon:
    			'<svg viewBox="0 0 72 72" width="17px" height="100%"><path d="M64 17v38H8V17h56m8-8H0v54h72V9z"></path><path d="M17.5 22C15 22 13 24 13 26.5s2 4.5 4.5 4.5 4.5-2 4.5-4.5-2-4.5-4.5-4.5zM16 50h27L29.5 32zM36 36.2l8.9-8.5L60.2 50H45.9S35.6 35.9 36 36.2z"></path></svg>',
    		title: "Image",
    		result: function() {
    			const refs = get_store_value(this.references);
    			saveRange(refs.editor);
    			refs.modal.$set({
    				show: true,
    				event: "imageUrl",
    				title: "Insert image",
    				label: "Url"
    			});
    			if (!get_store_value(this.helper).image) {
    				this.helper.update(state => {
    					state.image = true;
    					return state;
    				});
    				refs.modal.$on("imageUrl", event => {
    					restoreRange(refs.editor);
    					exec("insertImage", event.detail);
    				});
    			}
    		}
    	},
    	forecolor: {
    		icon:
    			'<svg viewBox="0 0 72 72" width="17px" height="100%"><path d="M32 15h7.8L56 57.1h-7.9l-4-11.1H27.4l-4 11.1h-7.6L32 15zm-2.5 25.4h12.9L36 22.3h-.2l-6.3 18.1z"></path></svg>',
    		title: "Text color",
    		colorPicker: true,
    		result: function() {
    			showColorPicker.call(this, "foreColor");
    		}
    	},
    	backcolor: {
    		icon:
    			'<svg viewBox="0 0 72 72" width="17px" height="100%"><path d="M36.5 22.3l-6.3 18.1H43l-6.3-18.1z"></path><path d="M9 8.9v54.2h54.1V8.9H9zm39.9 48.2L45 46H28.2l-3.9 11.1h-7.6L32.8 15h7.8l16.2 42.1h-7.9z"></path></svg>',
    		title: "Background color",
    		colorPicker: true,
    		result: function() {
    			showColorPicker.call(this, "backColor");
    		}
    	},
    	removeFormat: {
    		icon:
    			'<svg viewBox="0 0 72 72" width="17px" height="100%"><path d="M58.2 54.6L52 48.5l3.6-3.6 6.1 6.1 6.4-6.4 3.8 3.8-6.4 6.4 6.1 6.1-3.6 3.6-6.1-6.1-6.4 6.4-3.7-3.8 6.4-6.4zM21.7 52.1H50V57H21.7zM18.8 15.2h34.1v6.4H39.5v24.2h-7.4V21.5H18.8v-6.3z"></path></svg>',
    		title: "Remove format",
    		result: function() {
    			const refs = get_store_value(this.references);
    			const selection = window.getSelection();
    			if (!selection.toString().length) {
    				removeBlockTagsRecursive(
    					refs.editor.children,
    					this.removeFormatTags
    				);
    				const range = document.createRange();
    				range.selectNodeContents(refs.editor);
    				selection.removeAllRanges();
    				selection.addRange(range);
    			}
    			exec("removeFormat");
    			selection.removeAllRanges();
    		}
    	}
    };

    const showColorPicker = function(cmd) {
    	const refs = get_store_value(this.references);
    	saveRange(refs.editor);
    	console.log(refs.colorPicker);
    	refs.colorPicker.$set({show: true, event: cmd});
    	if (!get_store_value(this.helper)[cmd]) {
    		this.helper.update(state => {
    			state[cmd] = true;
    			return state;
    		});
    		refs.colorPicker.$on(cmd, event => {
    			let item = event.detail;
    			if (item.modal) {
    				this.modal.$set({
    					show: true,
    					event: "colorHref",
    					title: "Text color",
    					label:
    						cmd === "foreColor" ? "Text color" : "Background color"
    				});
    				const command = cmd;
    				if (!get_store_value(this.helper)[`${command}Modal`]) {
    					get_store_value(this.helper)[`${command}Modal`] = true;
    					this.modal.$on("colorHref", event => {
    						let color = event.detail;
    						restoreRange(refs.editor);
    						exec(command, color);
    					});
    				}
    			} else {
    				restoreRange(refs.editor);
    				exec(cmd, item.color);
    			}
    		});
    	}
    };

    /* ../../node_modules/cl-editor/src/helpers/EditorModal.svelte generated by Svelte v3.38.2 */

    const { console: console_1$m } = globals;
    const file$C = "../../node_modules/cl-editor/src/helpers/EditorModal.svelte";

    // (12:12) {#if error}
    function create_if_block$m(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Required";
    			attr_dev(span, "class", "msg-error svelte-42yfje");
    			add_location(span, file$C, 12, 12, 600);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$m.name,
    		type: "if",
    		source: "(12:12) {#if error}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$F(ctx) {
    	let div3;
    	let div0;
    	let t0;
    	let div2;
    	let div1;
    	let span0;
    	let t1;
    	let t2;
    	let form;
    	let label_1;
    	let input;
    	let t3;
    	let span2;
    	let span1;
    	let t4;
    	let t5;
    	let t6;
    	let button0;
    	let t8;
    	let button1;
    	let mounted;
    	let dispose;
    	let if_block = /*error*/ ctx[2] && create_if_block$m(ctx);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div2 = element("div");
    			div1 = element("div");
    			span0 = element("span");
    			t1 = text(/*title*/ ctx[3]);
    			t2 = space();
    			form = element("form");
    			label_1 = element("label");
    			input = element("input");
    			t3 = space();
    			span2 = element("span");
    			span1 = element("span");
    			t4 = text(/*label*/ ctx[4]);
    			t5 = space();
    			if (if_block) if_block.c();
    			t6 = space();
    			button0 = element("button");
    			button0.textContent = "Confirm";
    			t8 = space();
    			button1 = element("button");
    			button1.textContent = "Cancel";
    			attr_dev(div0, "class", "cl-editor-overlay svelte-42yfje");
    			add_location(div0, file$C, 2, 2, 102);
    			attr_dev(span0, "class", "modal-title svelte-42yfje");
    			add_location(span0, file$C, 5, 6, 226);
    			attr_dev(input, "type", "text");
    			attr_dev(input, "name", "text");
    			attr_dev(input, "class", "svelte-42yfje");
    			add_location(input, file$C, 8, 10, 398);
    			attr_dev(span1, "class", "svelte-42yfje");
    			add_location(span1, file$C, 10, 12, 543);
    			attr_dev(span2, "class", "input-info svelte-42yfje");
    			add_location(span2, file$C, 9, 10, 505);
    			attr_dev(label_1, "class", "modal-label svelte-42yfje");
    			toggle_class(label_1, "input-error", /*error*/ ctx[2]);
    			add_location(label_1, file$C, 7, 8, 334);
    			attr_dev(button0, "class", "modal-button modal-submit svelte-42yfje");
    			attr_dev(button0, "type", "submit");
    			add_location(button0, file$C, 16, 8, 701);
    			attr_dev(button1, "class", "modal-button modal-reset svelte-42yfje");
    			attr_dev(button1, "type", "reset");
    			add_location(button1, file$C, 17, 8, 782);
    			add_location(form, file$C, 6, 6, 273);
    			attr_dev(div1, "class", "modal-box svelte-42yfje");
    			add_location(div1, file$C, 4, 4, 196);
    			attr_dev(div2, "class", "cl-editor-modal svelte-42yfje");
    			add_location(div2, file$C, 3, 2, 162);
    			set_style(div3, "display", /*show*/ ctx[0] ? "block" : "none");
    			add_location(div3, file$C, 1, 0, 51);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			append_dev(div3, t0);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			append_dev(div1, span0);
    			append_dev(span0, t1);
    			append_dev(div1, t2);
    			append_dev(div1, form);
    			append_dev(form, label_1);
    			append_dev(label_1, input);
    			/*input_binding*/ ctx[10](input);
    			set_input_value(input, /*text*/ ctx[1]);
    			append_dev(label_1, t3);
    			append_dev(label_1, span2);
    			append_dev(span2, span1);
    			append_dev(span1, t4);
    			append_dev(span2, t5);
    			if (if_block) if_block.m(span2, null);
    			append_dev(form, t6);
    			append_dev(form, button0);
    			append_dev(form, t8);
    			append_dev(form, button1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(div0, "click", /*cancel*/ ctx[7], false, false, false),
    					listen_dev(input, "keyup", /*hideError*/ ctx[8], false, false, false),
    					listen_dev(input, "input", /*input_input_handler*/ ctx[11]),
    					listen_dev(button1, "click", /*cancel*/ ctx[7], false, false, false),
    					listen_dev(form, "submit", prevent_default(/*submit_handler*/ ctx[12]), false, true, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*title*/ 8) set_data_dev(t1, /*title*/ ctx[3]);

    			if (dirty & /*text*/ 2 && input.value !== /*text*/ ctx[1]) {
    				set_input_value(input, /*text*/ ctx[1]);
    			}

    			if (dirty & /*label*/ 16) set_data_dev(t4, /*label*/ ctx[4]);

    			if (/*error*/ ctx[2]) {
    				if (if_block) ; else {
    					if_block = create_if_block$m(ctx);
    					if_block.c();
    					if_block.m(span2, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*error*/ 4) {
    				toggle_class(label_1, "input-error", /*error*/ ctx[2]);
    			}

    			if (dirty & /*show*/ 1) {
    				set_style(div3, "display", /*show*/ ctx[0] ? "block" : "none");
    			}
    		},
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			/*input_binding*/ ctx[10](null);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$F($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("EditorModal", slots, []);
    	let dispatcher = new createEventDispatcher();
    	let { show = false } = $$props;
    	let { text = "" } = $$props;
    	let { event = "" } = $$props;
    	let { title = "" } = $$props;
    	let { label = "" } = $$props;
    	let { error = false } = $$props;
    	let refs = {};

    	function confirm() {
    		if (text) {
    			console.log("dispatcher", text, event);
    			dispatcher(event, text);
    			cancel();
    		} else {
    			$$invalidate(2, error = true);
    			refs.text.focus();
    		}
    	}

    	function cancel() {
    		$$invalidate(0, show = false);
    		$$invalidate(1, text = "");
    		$$invalidate(2, error = false);
    	}

    	function hideError() {
    		$$invalidate(2, error = false);
    	}

    	const writable_props = ["show", "text", "event", "title", "label", "error"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$m.warn(`<EditorModal> was created with unknown prop '${key}'`);
    	});

    	function input_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			refs.text = $$value;
    			$$invalidate(5, refs);
    		});
    	}

    	function input_input_handler() {
    		text = this.value;
    		$$invalidate(1, text);
    	}

    	const submit_handler = event => confirm();

    	$$self.$$set = $$props => {
    		if ("show" in $$props) $$invalidate(0, show = $$props.show);
    		if ("text" in $$props) $$invalidate(1, text = $$props.text);
    		if ("event" in $$props) $$invalidate(9, event = $$props.event);
    		if ("title" in $$props) $$invalidate(3, title = $$props.title);
    		if ("label" in $$props) $$invalidate(4, label = $$props.label);
    		if ("error" in $$props) $$invalidate(2, error = $$props.error);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		createEventDispatcher,
    		dispatcher,
    		show,
    		text,
    		event,
    		title,
    		label,
    		error,
    		refs,
    		confirm,
    		cancel,
    		hideError
    	});

    	$$self.$inject_state = $$props => {
    		if ("dispatcher" in $$props) dispatcher = $$props.dispatcher;
    		if ("show" in $$props) $$invalidate(0, show = $$props.show);
    		if ("text" in $$props) $$invalidate(1, text = $$props.text);
    		if ("event" in $$props) $$invalidate(9, event = $$props.event);
    		if ("title" in $$props) $$invalidate(3, title = $$props.title);
    		if ("label" in $$props) $$invalidate(4, label = $$props.label);
    		if ("error" in $$props) $$invalidate(2, error = $$props.error);
    		if ("refs" in $$props) $$invalidate(5, refs = $$props.refs);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*show, refs*/ 33) {
    			{
    				if (show) {
    					setTimeout(() => {
    						refs.text.focus();
    					});
    				}
    			}
    		}
    	};

    	return [
    		show,
    		text,
    		error,
    		title,
    		label,
    		refs,
    		confirm,
    		cancel,
    		hideError,
    		event,
    		input_binding,
    		input_input_handler,
    		submit_handler
    	];
    }

    class EditorModal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$F, create_fragment$F, safe_not_equal, {
    			show: 0,
    			text: 1,
    			event: 9,
    			title: 3,
    			label: 4,
    			error: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EditorModal",
    			options,
    			id: create_fragment$F.name
    		});
    	}

    	get show() {
    		return this.$$.ctx[0];
    	}

    	set show(show) {
    		this.$set({ show });
    		flush();
    	}

    	get text() {
    		return this.$$.ctx[1];
    	}

    	set text(text) {
    		this.$set({ text });
    		flush();
    	}

    	get event() {
    		return this.$$.ctx[9];
    	}

    	set event(event) {
    		this.$set({ event });
    		flush();
    	}

    	get title() {
    		return this.$$.ctx[3];
    	}

    	set title(title) {
    		this.$set({ title });
    		flush();
    	}

    	get label() {
    		return this.$$.ctx[4];
    	}

    	set label(label) {
    		this.$set({ label });
    		flush();
    	}

    	get error() {
    		return this.$$.ctx[2];
    	}

    	set error(error) {
    		this.$set({ error });
    		flush();
    	}
    }

    /* ../../node_modules/cl-editor/src/helpers/EditorColorPicker.svelte generated by Svelte v3.38.2 */
    const file$B = "../../node_modules/cl-editor/src/helpers/EditorColorPicker.svelte";

    function get_each_context$k(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	return child_ctx;
    }

    // (4:4) {#each btns as btn}
    function create_each_block$k(ctx) {
    	let button;
    	let t_value = (/*btn*/ ctx[9].text || "") + "";
    	let t;
    	let mounted;
    	let dispose;

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[5](/*btn*/ ctx[9], ...args);
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "class", "color-picker-btn svelte-njq4pk");
    			set_style(button, "background-color", /*btn*/ ctx[9].color);
    			add_location(button, file$B, 4, 4, 176);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*btns*/ 2 && t_value !== (t_value = (/*btn*/ ctx[9].text || "") + "")) set_data_dev(t, t_value);

    			if (dirty & /*btns*/ 2) {
    				set_style(button, "background-color", /*btn*/ ctx[9].color);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$k.name,
    		type: "each",
    		source: "(4:4) {#each btns as btn}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$E(ctx) {
    	let div2;
    	let div0;
    	let t;
    	let div1;
    	let mounted;
    	let dispose;
    	let each_value = /*btns*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$k(get_each_context$k(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			t = space();
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "class", "color-picker-overlay svelte-njq4pk");
    			add_location(div0, file$B, 1, 2, 51);
    			attr_dev(div1, "class", "color-picker-wrapper svelte-njq4pk");
    			add_location(div1, file$B, 2, 2, 113);
    			set_style(div2, "display", /*show*/ ctx[0] ? "block" : "none");
    			add_location(div2, file$B, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div2, t);
    			append_dev(div2, div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			if (!mounted) {
    				dispose = listen_dev(div0, "click", /*close*/ ctx[2], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*btns, selectColor*/ 10) {
    				each_value = /*btns*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$k(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$k(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div1, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*show*/ 1) {
    				set_style(div2, "display", /*show*/ ctx[0] ? "block" : "none");
    			}
    		},
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$E($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("EditorColorPicker", slots, []);
    	const dispatcher = new createEventDispatcher();

    	const colors = [
    		"ffffff",
    		"000000",
    		"eeece1",
    		"1f497d",
    		"4f81bd",
    		"c0504d",
    		"9bbb59",
    		"8064a2",
    		"4bacc6",
    		"f79646",
    		"ffff00",
    		"f2f2f2",
    		"7f7f7f",
    		"ddd9c3",
    		"c6d9f0",
    		"dbe5f1",
    		"f2dcdb",
    		"ebf1dd",
    		"e5e0ec",
    		"dbeef3",
    		"fdeada",
    		"fff2ca",
    		"d8d8d8",
    		"595959",
    		"c4bd97",
    		"8db3e2",
    		"b8cce4",
    		"e5b9b7",
    		"d7e3bc",
    		"ccc1d9",
    		"b7dde8",
    		"fbd5b5",
    		"ffe694",
    		"bfbfbf",
    		"3f3f3f",
    		"938953",
    		"548dd4",
    		"95b3d7",
    		"d99694",
    		"c3d69b",
    		"b2a2c7",
    		"b7dde8",
    		"fac08f",
    		"f2c314",
    		"a5a5a5",
    		"262626",
    		"494429",
    		"17365d",
    		"366092",
    		"953734",
    		"76923c",
    		"5f497a",
    		"92cddc",
    		"e36c09",
    		"c09100",
    		"7f7f7f",
    		"0c0c0c",
    		"1d1b10",
    		"0f243e",
    		"244061",
    		"632423",
    		"4f6128",
    		"3f3151",
    		"31859b",
    		"974806",
    		"7f6000"
    	];

    	const getBtns = () => {
    		const btns = colors.map(color => ({ color: `#${color}` }));
    		btns.push({ text: "#", modal: true });
    		return btns;
    	};

    	let { show = false } = $$props;
    	let { btns = [] } = $$props;
    	let { event = "" } = $$props;

    	onMount(() => {
    		$$invalidate(1, btns = getBtns());
    	});

    	function close() {
    		$$invalidate(0, show = false);
    	}

    	function selectColor(btn) {
    		dispatcher(event, btn);
    		close();
    	}

    	const writable_props = ["show", "btns", "event"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<EditorColorPicker> was created with unknown prop '${key}'`);
    	});

    	const click_handler = (btn, event) => selectColor(btn);

    	$$self.$$set = $$props => {
    		if ("show" in $$props) $$invalidate(0, show = $$props.show);
    		if ("btns" in $$props) $$invalidate(1, btns = $$props.btns);
    		if ("event" in $$props) $$invalidate(4, event = $$props.event);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		createEventDispatcher,
    		dispatcher,
    		colors,
    		getBtns,
    		show,
    		btns,
    		event,
    		close,
    		selectColor
    	});

    	$$self.$inject_state = $$props => {
    		if ("show" in $$props) $$invalidate(0, show = $$props.show);
    		if ("btns" in $$props) $$invalidate(1, btns = $$props.btns);
    		if ("event" in $$props) $$invalidate(4, event = $$props.event);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [show, btns, close, selectColor, event, click_handler];
    }

    class EditorColorPicker extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$E, create_fragment$E, safe_not_equal, { show: 0, btns: 1, event: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EditorColorPicker",
    			options,
    			id: create_fragment$E.name
    		});
    	}

    	get show() {
    		throw new Error("<EditorColorPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set show(value) {
    		throw new Error("<EditorColorPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get btns() {
    		throw new Error("<EditorColorPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set btns(value) {
    		throw new Error("<EditorColorPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get event() {
    		throw new Error("<EditorColorPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set event(value) {
    		throw new Error("<EditorColorPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const state = (function(name) {
      let state = {
        actionBtns: [],
        actionObj: {}
      };

      const { subscribe, set, update } = writable(state);

      return {
        name,
        set,
        update,
        subscribe
      }
    });

    const createStateStore = state;

    /* ../../node_modules/cl-editor/src/Editor.svelte generated by Svelte v3.38.2 */

    const { Object: Object_1 } = globals;
    const file$A = "../../node_modules/cl-editor/src/Editor.svelte";

    function get_each_context$j(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[37] = list[i];
    	return child_ctx;
    }

    // (8:4) {#each $state.actionBtns as action}
    function create_each_block$j(ctx) {
    	let button;
    	let html_tag;
    	let raw_value = /*action*/ ctx[37].icon + "";
    	let t;
    	let button_class_value;
    	let button_title_value;
    	let button_disabled_value;
    	let mounted;
    	let dispose;

    	function click_handler_1(...args) {
    		return /*click_handler_1*/ ctx[23](/*action*/ ctx[37], ...args);
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = space();
    			html_tag = new HtmlTag(t);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "class", button_class_value = "cl-button " + (/*action*/ ctx[37].active ? "active" : "") + " svelte-1a534py");
    			attr_dev(button, "title", button_title_value = /*action*/ ctx[37].title);
    			button.disabled = button_disabled_value = /*action*/ ctx[37].disabled;
    			add_location(button, file$A, 8, 6, 302);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			html_tag.m(raw_value, button);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler_1, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*$state*/ 4 && raw_value !== (raw_value = /*action*/ ctx[37].icon + "")) html_tag.p(raw_value);

    			if (dirty[0] & /*$state*/ 4 && button_class_value !== (button_class_value = "cl-button " + (/*action*/ ctx[37].active ? "active" : "") + " svelte-1a534py")) {
    				attr_dev(button, "class", button_class_value);
    			}

    			if (dirty[0] & /*$state*/ 4 && button_title_value !== (button_title_value = /*action*/ ctx[37].title)) {
    				attr_dev(button, "title", button_title_value);
    			}

    			if (dirty[0] & /*$state*/ 4 && button_disabled_value !== (button_disabled_value = /*action*/ ctx[37].disabled)) {
    				prop_dev(button, "disabled", button_disabled_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$j.name,
    		type: "each",
    		source: "(8:4) {#each $state.actionBtns as action}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$D(ctx) {
    	let div2;
    	let div0;
    	let t0;
    	let div1;
    	let t1;
    	let textarea;
    	let t2;
    	let editormodal;
    	let t3;
    	let editorcolorpicker;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*$state*/ ctx[2].actionBtns;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$j(get_each_context$j(ctx, each_value, i));
    	}

    	let editormodal_props = {};
    	editormodal = new EditorModal({ props: editormodal_props, $$inline: true });
    	/*editormodal_binding*/ ctx[30](editormodal);
    	let editorcolorpicker_props = {};

    	editorcolorpicker = new EditorColorPicker({
    			props: editorcolorpicker_props,
    			$$inline: true
    		});

    	/*editorcolorpicker_binding*/ ctx[31](editorcolorpicker);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t0 = space();
    			div1 = element("div");
    			t1 = space();
    			textarea = element("textarea");
    			t2 = space();
    			create_component(editormodal.$$.fragment);
    			t3 = space();
    			create_component(editorcolorpicker.$$.fragment);
    			attr_dev(div0, "class", "cl-actionbar svelte-1a534py");
    			add_location(div0, file$A, 6, 2, 229);
    			attr_dev(div1, "id", /*contentId*/ ctx[1]);
    			attr_dev(div1, "class", "cl-content svelte-1a534py");
    			set_style(div1, "height", /*height*/ ctx[0]);
    			attr_dev(div1, "contenteditable", "true");
    			add_location(div1, file$A, 17, 2, 568);
    			attr_dev(textarea, "class", "cl-textarea svelte-1a534py");
    			set_style(textarea, "max-height", /*height*/ ctx[0]);
    			set_style(textarea, "min-height", /*height*/ ctx[0]);
    			add_location(textarea, file$A, 28, 2, 911);
    			attr_dev(div2, "class", "cl svelte-1a534py");
    			add_location(div2, file$A, 5, 0, 172);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div0, null);
    			}

    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			/*div1_binding*/ ctx[24](div1);
    			append_dev(div2, t1);
    			append_dev(div2, textarea);
    			/*textarea_binding*/ ctx[29](textarea);
    			append_dev(div2, t2);
    			mount_component(editormodal, div2, null);
    			append_dev(div2, t3);
    			mount_component(editorcolorpicker, div2, null);
    			/*div2_binding*/ ctx[32](div2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(window, "click", /*click_handler*/ ctx[22], false, false, false),
    					listen_dev(div1, "input", /*input_handler*/ ctx[25], false, false, false),
    					listen_dev(div1, "mouseup", /*mouseup_handler*/ ctx[26], false, false, false),
    					listen_dev(div1, "keyup", /*keyup_handler*/ ctx[27], false, false, false),
    					listen_dev(div1, "paste", /*paste_handler*/ ctx[28], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$state, _btnClicked*/ 132) {
    				each_value = /*$state*/ ctx[2].actionBtns;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$j(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$j(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div0, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (!current || dirty[0] & /*contentId*/ 2) {
    				attr_dev(div1, "id", /*contentId*/ ctx[1]);
    			}

    			if (!current || dirty[0] & /*height*/ 1) {
    				set_style(div1, "height", /*height*/ ctx[0]);
    			}

    			if (!current || dirty[0] & /*height*/ 1) {
    				set_style(textarea, "max-height", /*height*/ ctx[0]);
    			}

    			if (!current || dirty[0] & /*height*/ 1) {
    				set_style(textarea, "min-height", /*height*/ ctx[0]);
    			}

    			const editormodal_changes = {};
    			editormodal.$set(editormodal_changes);
    			const editorcolorpicker_changes = {};
    			editorcolorpicker.$set(editorcolorpicker_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(editormodal.$$.fragment, local);
    			transition_in(editorcolorpicker.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(editormodal.$$.fragment, local);
    			transition_out(editorcolorpicker.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_each(each_blocks, detaching);
    			/*div1_binding*/ ctx[24](null);
    			/*textarea_binding*/ ctx[29](null);
    			/*editormodal_binding*/ ctx[30](null);
    			destroy_component(editormodal);
    			/*editorcolorpicker_binding*/ ctx[31](null);
    			destroy_component(editorcolorpicker);
    			/*div2_binding*/ ctx[32](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const editors = [];

    function instance$D($$self, $$props, $$invalidate) {
    	let $state;
    	let $references;
    	let $helper;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Editor", slots, []);
    	let dispatcher = new createEventDispatcher();
    	let { actions = [] } = $$props;
    	let { height = "300px" } = $$props;
    	let { html = "" } = $$props;
    	let { contentId = "" } = $$props;
    	let { removeFormatTags = ["h1", "h2", "blockquote"] } = $$props;

    	let helper = writable({
    		foreColor: false,
    		backColor: false,
    		foreColorModal: false,
    		backColorModal: false,
    		image: false,
    		link: false,
    		showEditor: true,
    		blurActive: false
    	});

    	validate_store(helper, "helper");
    	component_subscribe($$self, helper, value => $$invalidate(33, $helper = value));
    	editors.push({});
    	let contextKey = "editor_" + editors.length;
    	let state = createStateStore(contextKey);
    	validate_store(state, "state");
    	component_subscribe($$self, state, value => $$invalidate(2, $state = value));
    	let references = writable({});
    	validate_store(references, "references");
    	component_subscribe($$self, references, value => $$invalidate(3, $references = value));
    	set_store_value(state, $state.actionObj = getNewActionObj(defaultActions, actions), $state);

    	let context = {
    		exec: exec$1,
    		getHtml,
    		getText,
    		setHtml,
    		saveRange: saveRange$1,
    		restoreRange: restoreRange$1,
    		helper,
    		references,
    		state,
    		removeFormatTags
    	};

    	setContext(contextKey, context);

    	onMount(() => {
    		set_store_value(state, $state.actionBtns = getActionBtns($state.actionObj), $state);
    		setHtml(html);
    	});

    	function _btnClicked(action) {
    		$references.editor.focus();
    		saveRange$1($references.editor);
    		restoreRange$1($references.editor);
    		action.result.call(context);
    		_handleButtonStatus();
    	}

    	function _handleButtonStatus(clearBtns) {
    		const tags = clearBtns
    		? []
    		: getTagsRecursive(document.getSelection().focusNode);

    		Object.keys($state.actionObj).forEach(action => set_store_value(state, $state.actionObj[action].active = false, $state));
    		tags.forEach(tag => ($state.actionObj[tag.toLowerCase()] || {}).active = true);
    		set_store_value(state, $state.actionBtns = getActionBtns($state.actionObj), $state);
    		state.set($state);
    	}

    	function _onPaste(event) {
    		event.preventDefault();

    		exec$1("insertHTML", event.clipboardData.getData("text/html")
    		? cleanHtml(event.clipboardData.getData("text/html"))
    		: event.clipboardData.getData("text"));
    	}

    	function _onChange(event) {
    		dispatcher("change", event);
    	}

    	function _documentClick(event) {
    		if (!isEditorClick(event.target, $references.editorWrapper) && $helper.blurActive) {
    			dispatcher("blur", event);
    		}

    		set_store_value(helper, $helper.blurActive = true, $helper);
    	}

    	function exec$1(cmd, value) {
    		exec(cmd, value);
    	}

    	

    	function getHtml(sanitize) {
    		return sanitize
    		? removeBadTags($references.editor.innerHTML)
    		: $references.editor.innerHTML;
    	}

    	function getText() {
    		return $references.editor.innerText;
    	}

    	function setHtml(html, sanitize) {
    		const htmlData = sanitize ? removeBadTags(html) : html || "";
    		set_store_value(references, $references.editor.innerHTML = htmlData, $references);
    		set_store_value(references, $references.raw.value = htmlData, $references);
    	}

    	function saveRange$1() {
    		saveRange($references.editor);
    	}

    	function restoreRange$1() {
    		restoreRange($references.editor);
    	}

    	const refs = $references;
    	const writable_props = ["actions", "height", "html", "contentId", "removeFormatTags"];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Editor> was created with unknown prop '${key}'`);
    	});

    	const click_handler = event => _documentClick(event);
    	const click_handler_1 = (action, event) => _btnClicked(action);

    	function div1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$references.editor = $$value;
    			references.set($references);
    		});
    	}

    	const input_handler = event => _onChange(event.target.innerHTML);
    	const mouseup_handler = () => _handleButtonStatus();
    	const keyup_handler = () => _handleButtonStatus();
    	const paste_handler = event => _onPaste(event);

    	function textarea_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$references.raw = $$value;
    			references.set($references);
    		});
    	}

    	function editormodal_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$references.modal = $$value;
    			references.set($references);
    		});
    	}

    	function editorcolorpicker_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$references.colorPicker = $$value;
    			references.set($references);
    		});
    	}

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$references.editorWrapper = $$value;
    			references.set($references);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("actions" in $$props) $$invalidate(12, actions = $$props.actions);
    		if ("height" in $$props) $$invalidate(0, height = $$props.height);
    		if ("html" in $$props) $$invalidate(13, html = $$props.html);
    		if ("contentId" in $$props) $$invalidate(1, contentId = $$props.contentId);
    		if ("removeFormatTags" in $$props) $$invalidate(14, removeFormatTags = $$props.removeFormatTags);
    	};

    	$$self.$capture_state = () => ({
    		editors,
    		getTagsRecursive,
    		_saveRange: saveRange,
    		_restoreRange: restoreRange,
    		_exec: exec,
    		cleanHtml,
    		getActionBtns,
    		getNewActionObj,
    		removeBadTags,
    		isEditorClick,
    		defaultActions,
    		EditorModal,
    		EditorColorPicker,
    		onMount,
    		createEventDispatcher,
    		setContext,
    		getContext,
    		createStateStore,
    		writable,
    		dispatcher,
    		actions,
    		height,
    		html,
    		contentId,
    		removeFormatTags,
    		helper,
    		contextKey,
    		state,
    		references,
    		context,
    		_btnClicked,
    		_handleButtonStatus,
    		_onPaste,
    		_onChange,
    		_documentClick,
    		exec: exec$1,
    		getHtml,
    		getText,
    		setHtml,
    		saveRange: saveRange$1,
    		restoreRange: restoreRange$1,
    		refs,
    		$state,
    		$references,
    		$helper
    	});

    	$$self.$inject_state = $$props => {
    		if ("dispatcher" in $$props) dispatcher = $$props.dispatcher;
    		if ("actions" in $$props) $$invalidate(12, actions = $$props.actions);
    		if ("height" in $$props) $$invalidate(0, height = $$props.height);
    		if ("html" in $$props) $$invalidate(13, html = $$props.html);
    		if ("contentId" in $$props) $$invalidate(1, contentId = $$props.contentId);
    		if ("removeFormatTags" in $$props) $$invalidate(14, removeFormatTags = $$props.removeFormatTags);
    		if ("helper" in $$props) $$invalidate(4, helper = $$props.helper);
    		if ("contextKey" in $$props) contextKey = $$props.contextKey;
    		if ("state" in $$props) $$invalidate(5, state = $$props.state);
    		if ("references" in $$props) $$invalidate(6, references = $$props.references);
    		if ("context" in $$props) context = $$props.context;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		height,
    		contentId,
    		$state,
    		$references,
    		helper,
    		state,
    		references,
    		_btnClicked,
    		_handleButtonStatus,
    		_onPaste,
    		_onChange,
    		_documentClick,
    		actions,
    		html,
    		removeFormatTags,
    		exec$1,
    		getHtml,
    		getText,
    		setHtml,
    		saveRange$1,
    		restoreRange$1,
    		refs,
    		click_handler,
    		click_handler_1,
    		div1_binding,
    		input_handler,
    		mouseup_handler,
    		keyup_handler,
    		paste_handler,
    		textarea_binding,
    		editormodal_binding,
    		editorcolorpicker_binding,
    		div2_binding
    	];
    }

    class Editor extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$D,
    			create_fragment$D,
    			safe_not_equal,
    			{
    				actions: 12,
    				height: 0,
    				html: 13,
    				contentId: 1,
    				removeFormatTags: 14,
    				exec: 15,
    				getHtml: 16,
    				getText: 17,
    				setHtml: 18,
    				saveRange: 19,
    				restoreRange: 20,
    				refs: 21
    			},
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Editor",
    			options,
    			id: create_fragment$D.name
    		});
    	}

    	get actions() {
    		return this.$$.ctx[12];
    	}

    	set actions(actions) {
    		this.$set({ actions });
    		flush();
    	}

    	get height() {
    		return this.$$.ctx[0];
    	}

    	set height(height) {
    		this.$set({ height });
    		flush();
    	}

    	get html() {
    		return this.$$.ctx[13];
    	}

    	set html(html) {
    		this.$set({ html });
    		flush();
    	}

    	get contentId() {
    		return this.$$.ctx[1];
    	}

    	set contentId(contentId) {
    		this.$set({ contentId });
    		flush();
    	}

    	get removeFormatTags() {
    		return this.$$.ctx[14];
    	}

    	set removeFormatTags(removeFormatTags) {
    		this.$set({ removeFormatTags });
    		flush();
    	}

    	get exec() {
    		return this.$$.ctx[15];
    	}

    	set exec(value) {
    		throw new Error("<Editor>: Cannot set read-only property 'exec'");
    	}

    	get getHtml() {
    		return this.$$.ctx[16];
    	}

    	set getHtml(value) {
    		throw new Error("<Editor>: Cannot set read-only property 'getHtml'");
    	}

    	get getText() {
    		return this.$$.ctx[17];
    	}

    	set getText(value) {
    		throw new Error("<Editor>: Cannot set read-only property 'getText'");
    	}

    	get setHtml() {
    		return this.$$.ctx[18];
    	}

    	set setHtml(value) {
    		throw new Error("<Editor>: Cannot set read-only property 'setHtml'");
    	}

    	get saveRange() {
    		return this.$$.ctx[19];
    	}

    	set saveRange(value) {
    		throw new Error("<Editor>: Cannot set read-only property 'saveRange'");
    	}

    	get restoreRange() {
    		return this.$$.ctx[20];
    	}

    	set restoreRange(value) {
    		throw new Error("<Editor>: Cannot set read-only property 'restoreRange'");
    	}

    	get refs() {
    		return this.$$.ctx[21];
    	}

    	set refs(value) {
    		throw new Error("<Editor>: Cannot set read-only property 'refs'");
    	}
    }

    const ComponentEditorStore = writable('');

    function deepFreeze(obj) {
        if (obj instanceof Map) {
            obj.clear = obj.delete = obj.set = function () {
                throw new Error('map is read-only');
            };
        } else if (obj instanceof Set) {
            obj.add = obj.clear = obj.delete = function () {
                throw new Error('set is read-only');
            };
        }

        // Freeze self
        Object.freeze(obj);

        Object.getOwnPropertyNames(obj).forEach(function (name) {
            var prop = obj[name];

            // Freeze prop if it is an object
            if (typeof prop == 'object' && !Object.isFrozen(prop)) {
                deepFreeze(prop);
            }
        });

        return obj;
    }

    var deepFreezeEs6 = deepFreeze;
    var _default = deepFreeze;
    deepFreezeEs6.default = _default;

    /** @implements CallbackResponse */
    class Response {
      /**
       * @param {CompiledMode} mode
       */
      constructor(mode) {
        // eslint-disable-next-line no-undefined
        if (mode.data === undefined) mode.data = {};

        this.data = mode.data;
        this.isMatchIgnored = false;
      }

      ignoreMatch() {
        this.isMatchIgnored = true;
      }
    }

    /**
     * @param {string} value
     * @returns {string}
     */
    function escapeHTML(value) {
      return value
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#x27;');
    }

    /**
     * performs a shallow merge of multiple objects into one
     *
     * @template T
     * @param {T} original
     * @param {Record<string,any>[]} objects
     * @returns {T} a single new object
     */
    function inherit(original, ...objects) {
      /** @type Record<string,any> */
      const result = Object.create(null);

      for (const key in original) {
        result[key] = original[key];
      }
      objects.forEach(function(obj) {
        for (const key in obj) {
          result[key] = obj[key];
        }
      });
      return /** @type {T} */ (result);
    }

    /**
     * @typedef {object} Renderer
     * @property {(text: string) => void} addText
     * @property {(node: Node) => void} openNode
     * @property {(node: Node) => void} closeNode
     * @property {() => string} value
     */

    /** @typedef {{kind?: string, sublanguage?: boolean}} Node */
    /** @typedef {{walk: (r: Renderer) => void}} Tree */
    /** */

    const SPAN_CLOSE = '</span>';

    /**
     * Determines if a node needs to be wrapped in <span>
     *
     * @param {Node} node */
    const emitsWrappingTags = (node) => {
      return !!node.kind;
    };

    /** @type {Renderer} */
    class HTMLRenderer {
      /**
       * Creates a new HTMLRenderer
       *
       * @param {Tree} parseTree - the parse tree (must support `walk` API)
       * @param {{classPrefix: string}} options
       */
      constructor(parseTree, options) {
        this.buffer = "";
        this.classPrefix = options.classPrefix;
        parseTree.walk(this);
      }

      /**
       * Adds texts to the output stream
       *
       * @param {string} text */
      addText(text) {
        this.buffer += escapeHTML(text);
      }

      /**
       * Adds a node open to the output stream (if needed)
       *
       * @param {Node} node */
      openNode(node) {
        if (!emitsWrappingTags(node)) return;

        let className = node.kind;
        if (!node.sublanguage) {
          className = `${this.classPrefix}${className}`;
        }
        this.span(className);
      }

      /**
       * Adds a node close to the output stream (if needed)
       *
       * @param {Node} node */
      closeNode(node) {
        if (!emitsWrappingTags(node)) return;

        this.buffer += SPAN_CLOSE;
      }

      /**
       * returns the accumulated buffer
      */
      value() {
        return this.buffer;
      }

      // helpers

      /**
       * Builds a span element
       *
       * @param {string} className */
      span(className) {
        this.buffer += `<span class="${className}">`;
      }
    }

    /** @typedef {{kind?: string, sublanguage?: boolean, children: Node[]} | string} Node */
    /** @typedef {{kind?: string, sublanguage?: boolean, children: Node[]} } DataNode */
    /**  */

    class TokenTree {
      constructor() {
        /** @type DataNode */
        this.rootNode = { children: [] };
        this.stack = [this.rootNode];
      }

      get top() {
        return this.stack[this.stack.length - 1];
      }

      get root() { return this.rootNode; }

      /** @param {Node} node */
      add(node) {
        this.top.children.push(node);
      }

      /** @param {string} kind */
      openNode(kind) {
        /** @type Node */
        const node = { kind, children: [] };
        this.add(node);
        this.stack.push(node);
      }

      closeNode() {
        if (this.stack.length > 1) {
          return this.stack.pop();
        }
        // eslint-disable-next-line no-undefined
        return undefined;
      }

      closeAllNodes() {
        while (this.closeNode());
      }

      toJSON() {
        return JSON.stringify(this.rootNode, null, 4);
      }

      /**
       * @typedef { import("./html_renderer").Renderer } Renderer
       * @param {Renderer} builder
       */
      walk(builder) {
        // this does not
        return this.constructor._walk(builder, this.rootNode);
        // this works
        // return TokenTree._walk(builder, this.rootNode);
      }

      /**
       * @param {Renderer} builder
       * @param {Node} node
       */
      static _walk(builder, node) {
        if (typeof node === "string") {
          builder.addText(node);
        } else if (node.children) {
          builder.openNode(node);
          node.children.forEach((child) => this._walk(builder, child));
          builder.closeNode(node);
        }
        return builder;
      }

      /**
       * @param {Node} node
       */
      static _collapse(node) {
        if (typeof node === "string") return;
        if (!node.children) return;

        if (node.children.every(el => typeof el === "string")) {
          // node.text = node.children.join("");
          // delete node.children;
          node.children = [node.children.join("")];
        } else {
          node.children.forEach((child) => {
            TokenTree._collapse(child);
          });
        }
      }
    }

    /**
      Currently this is all private API, but this is the minimal API necessary
      that an Emitter must implement to fully support the parser.

      Minimal interface:

      - addKeyword(text, kind)
      - addText(text)
      - addSublanguage(emitter, subLanguageName)
      - finalize()
      - openNode(kind)
      - closeNode()
      - closeAllNodes()
      - toHTML()

    */

    /**
     * @implements {Emitter}
     */
    class TokenTreeEmitter extends TokenTree {
      /**
       * @param {*} options
       */
      constructor(options) {
        super();
        this.options = options;
      }

      /**
       * @param {string} text
       * @param {string} kind
       */
      addKeyword(text, kind) {
        if (text === "") { return; }

        this.openNode(kind);
        this.addText(text);
        this.closeNode();
      }

      /**
       * @param {string} text
       */
      addText(text) {
        if (text === "") { return; }

        this.add(text);
      }

      /**
       * @param {Emitter & {root: DataNode}} emitter
       * @param {string} name
       */
      addSublanguage(emitter, name) {
        /** @type DataNode */
        const node = emitter.root;
        node.kind = name;
        node.sublanguage = true;
        this.add(node);
      }

      toHTML() {
        const renderer = new HTMLRenderer(this, this.options);
        return renderer.value();
      }

      finalize() {
        return true;
      }
    }

    /**
     * @param {string} value
     * @returns {RegExp}
     * */
    function escape(value) {
      return new RegExp(value.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&'), 'm');
    }

    /**
     * @param {RegExp | string } re
     * @returns {string}
     */
    function source$1(re) {
      if (!re) return null;
      if (typeof re === "string") return re;

      return re.source;
    }

    /**
     * @param {...(RegExp | string) } args
     * @returns {string}
     */
    function concat$1(...args) {
      const joined = args.map((x) => source$1(x)).join("");
      return joined;
    }

    /**
     * Any of the passed expresssions may match
     *
     * Creates a huge this | this | that | that match
     * @param {(RegExp | string)[] } args
     * @returns {string}
     */
    function either(...args) {
      const joined = '(' + args.map((x) => source$1(x)).join("|") + ")";
      return joined;
    }

    /**
     * @param {RegExp} re
     * @returns {number}
     */
    function countMatchGroups(re) {
      return (new RegExp(re.toString() + '|')).exec('').length - 1;
    }

    /**
     * Does lexeme start with a regular expression match at the beginning
     * @param {RegExp} re
     * @param {string} lexeme
     */
    function startsWith(re, lexeme) {
      const match = re && re.exec(lexeme);
      return match && match.index === 0;
    }

    // BACKREF_RE matches an open parenthesis or backreference. To avoid
    // an incorrect parse, it additionally matches the following:
    // - [...] elements, where the meaning of parentheses and escapes change
    // - other escape sequences, so we do not misparse escape sequences as
    //   interesting elements
    // - non-matching or lookahead parentheses, which do not capture. These
    //   follow the '(' with a '?'.
    const BACKREF_RE = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;

    // join logically computes regexps.join(separator), but fixes the
    // backreferences so they continue to match.
    // it also places each individual regular expression into it's own
    // match group, keeping track of the sequencing of those match groups
    // is currently an exercise for the caller. :-)
    /**
     * @param {(string | RegExp)[]} regexps
     * @param {string} separator
     * @returns {string}
     */
    function join(regexps, separator = "|") {
      let numCaptures = 0;

      return regexps.map((regex) => {
        numCaptures += 1;
        const offset = numCaptures;
        let re = source$1(regex);
        let out = '';

        while (re.length > 0) {
          const match = BACKREF_RE.exec(re);
          if (!match) {
            out += re;
            break;
          }
          out += re.substring(0, match.index);
          re = re.substring(match.index + match[0].length);
          if (match[0][0] === '\\' && match[1]) {
            // Adjust the backreference.
            out += '\\' + String(Number(match[1]) + offset);
          } else {
            out += match[0];
            if (match[0] === '(') {
              numCaptures++;
            }
          }
        }
        return out;
      }).map(re => `(${re})`).join(separator);
    }

    // Common regexps
    const MATCH_NOTHING_RE = /\b\B/;
    const IDENT_RE = '[a-zA-Z]\\w*';
    const UNDERSCORE_IDENT_RE = '[a-zA-Z_]\\w*';
    const NUMBER_RE = '\\b\\d+(\\.\\d+)?';
    const C_NUMBER_RE = '(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)'; // 0x..., 0..., decimal, float
    const BINARY_NUMBER_RE = '\\b(0b[01]+)'; // 0b...
    const RE_STARTERS_RE = '!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~';

    /**
    * @param { Partial<Mode> & {binary?: string | RegExp} } opts
    */
    const SHEBANG = (opts = {}) => {
      const beginShebang = /^#![ ]*\//;
      if (opts.binary) {
        opts.begin = concat$1(
          beginShebang,
          /.*\b/,
          opts.binary,
          /\b.*/);
      }
      return inherit({
        className: 'meta',
        begin: beginShebang,
        end: /$/,
        relevance: 0,
        /** @type {ModeCallback} */
        "on:begin": (m, resp) => {
          if (m.index !== 0) resp.ignoreMatch();
        }
      }, opts);
    };

    // Common modes
    const BACKSLASH_ESCAPE = {
      begin: '\\\\[\\s\\S]', relevance: 0
    };
    const APOS_STRING_MODE = {
      className: 'string',
      begin: '\'',
      end: '\'',
      illegal: '\\n',
      contains: [BACKSLASH_ESCAPE]
    };
    const QUOTE_STRING_MODE = {
      className: 'string',
      begin: '"',
      end: '"',
      illegal: '\\n',
      contains: [BACKSLASH_ESCAPE]
    };
    const PHRASAL_WORDS_MODE = {
      begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
    };
    /**
     * Creates a comment mode
     *
     * @param {string | RegExp} begin
     * @param {string | RegExp} end
     * @param {Mode | {}} [modeOptions]
     * @returns {Partial<Mode>}
     */
    const COMMENT = function(begin, end, modeOptions = {}) {
      const mode = inherit(
        {
          className: 'comment',
          begin,
          end,
          contains: []
        },
        modeOptions
      );
      mode.contains.push(PHRASAL_WORDS_MODE);
      mode.contains.push({
        className: 'doctag',
        begin: '(?:TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):',
        relevance: 0
      });
      return mode;
    };
    const C_LINE_COMMENT_MODE = COMMENT('//', '$');
    const C_BLOCK_COMMENT_MODE = COMMENT('/\\*', '\\*/');
    const HASH_COMMENT_MODE = COMMENT('#', '$');
    const NUMBER_MODE = {
      className: 'number',
      begin: NUMBER_RE,
      relevance: 0
    };
    const C_NUMBER_MODE = {
      className: 'number',
      begin: C_NUMBER_RE,
      relevance: 0
    };
    const BINARY_NUMBER_MODE = {
      className: 'number',
      begin: BINARY_NUMBER_RE,
      relevance: 0
    };
    const CSS_NUMBER_MODE = {
      className: 'number',
      begin: NUMBER_RE + '(' +
        '%|em|ex|ch|rem' +
        '|vw|vh|vmin|vmax' +
        '|cm|mm|in|pt|pc|px' +
        '|deg|grad|rad|turn' +
        '|s|ms' +
        '|Hz|kHz' +
        '|dpi|dpcm|dppx' +
        ')?',
      relevance: 0
    };
    const REGEXP_MODE = {
      // this outer rule makes sure we actually have a WHOLE regex and not simply
      // an expression such as:
      //
      //     3 / something
      //
      // (which will then blow up when regex's `illegal` sees the newline)
      begin: /(?=\/[^/\n]*\/)/,
      contains: [{
        className: 'regexp',
        begin: /\//,
        end: /\/[gimuy]*/,
        illegal: /\n/,
        contains: [
          BACKSLASH_ESCAPE,
          {
            begin: /\[/,
            end: /\]/,
            relevance: 0,
            contains: [BACKSLASH_ESCAPE]
          }
        ]
      }]
    };
    const TITLE_MODE = {
      className: 'title',
      begin: IDENT_RE,
      relevance: 0
    };
    const UNDERSCORE_TITLE_MODE = {
      className: 'title',
      begin: UNDERSCORE_IDENT_RE,
      relevance: 0
    };
    const METHOD_GUARD = {
      // excludes method names from keyword processing
      begin: '\\.\\s*' + UNDERSCORE_IDENT_RE,
      relevance: 0
    };

    /**
     * Adds end same as begin mechanics to a mode
     *
     * Your mode must include at least a single () match group as that first match
     * group is what is used for comparison
     * @param {Partial<Mode>} mode
     */
    const END_SAME_AS_BEGIN = function(mode) {
      return Object.assign(mode,
        {
          /** @type {ModeCallback} */
          'on:begin': (m, resp) => { resp.data._beginMatch = m[1]; },
          /** @type {ModeCallback} */
          'on:end': (m, resp) => { if (resp.data._beginMatch !== m[1]) resp.ignoreMatch(); }
        });
    };

    var MODES$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        MATCH_NOTHING_RE: MATCH_NOTHING_RE,
        IDENT_RE: IDENT_RE,
        UNDERSCORE_IDENT_RE: UNDERSCORE_IDENT_RE,
        NUMBER_RE: NUMBER_RE,
        C_NUMBER_RE: C_NUMBER_RE,
        BINARY_NUMBER_RE: BINARY_NUMBER_RE,
        RE_STARTERS_RE: RE_STARTERS_RE,
        SHEBANG: SHEBANG,
        BACKSLASH_ESCAPE: BACKSLASH_ESCAPE,
        APOS_STRING_MODE: APOS_STRING_MODE,
        QUOTE_STRING_MODE: QUOTE_STRING_MODE,
        PHRASAL_WORDS_MODE: PHRASAL_WORDS_MODE,
        COMMENT: COMMENT,
        C_LINE_COMMENT_MODE: C_LINE_COMMENT_MODE,
        C_BLOCK_COMMENT_MODE: C_BLOCK_COMMENT_MODE,
        HASH_COMMENT_MODE: HASH_COMMENT_MODE,
        NUMBER_MODE: NUMBER_MODE,
        C_NUMBER_MODE: C_NUMBER_MODE,
        BINARY_NUMBER_MODE: BINARY_NUMBER_MODE,
        CSS_NUMBER_MODE: CSS_NUMBER_MODE,
        REGEXP_MODE: REGEXP_MODE,
        TITLE_MODE: TITLE_MODE,
        UNDERSCORE_TITLE_MODE: UNDERSCORE_TITLE_MODE,
        METHOD_GUARD: METHOD_GUARD,
        END_SAME_AS_BEGIN: END_SAME_AS_BEGIN
    });

    // Grammar extensions / plugins
    // See: https://github.com/highlightjs/highlight.js/issues/2833

    // Grammar extensions allow "syntactic sugar" to be added to the grammar modes
    // without requiring any underlying changes to the compiler internals.

    // `compileMatch` being the perfect small example of now allowing a grammar
    // author to write `match` when they desire to match a single expression rather
    // than being forced to use `begin`.  The extension then just moves `match` into
    // `begin` when it runs.  Ie, no features have been added, but we've just made
    // the experience of writing (and reading grammars) a little bit nicer.

    // ------

    // TODO: We need negative look-behind support to do this properly
    /**
     * Skip a match if it has a preceding dot
     *
     * This is used for `beginKeywords` to prevent matching expressions such as
     * `bob.keyword.do()`. The mode compiler automatically wires this up as a
     * special _internal_ 'on:begin' callback for modes with `beginKeywords`
     * @param {RegExpMatchArray} match
     * @param {CallbackResponse} response
     */
    function skipIfhasPrecedingDot(match, response) {
      const before = match.input[match.index - 1];
      if (before === ".") {
        response.ignoreMatch();
      }
    }


    /**
     * `beginKeywords` syntactic sugar
     * @type {CompilerExt}
     */
    function beginKeywords(mode, parent) {
      if (!parent) return;
      if (!mode.beginKeywords) return;

      // for languages with keywords that include non-word characters checking for
      // a word boundary is not sufficient, so instead we check for a word boundary
      // or whitespace - this does no harm in any case since our keyword engine
      // doesn't allow spaces in keywords anyways and we still check for the boundary
      // first
      mode.begin = '\\b(' + mode.beginKeywords.split(' ').join('|') + ')(?!\\.)(?=\\b|\\s)';
      mode.__beforeBegin = skipIfhasPrecedingDot;
      mode.keywords = mode.keywords || mode.beginKeywords;
      delete mode.beginKeywords;

      // prevents double relevance, the keywords themselves provide
      // relevance, the mode doesn't need to double it
      // eslint-disable-next-line no-undefined
      if (mode.relevance === undefined) mode.relevance = 0;
    }

    /**
     * Allow `illegal` to contain an array of illegal values
     * @type {CompilerExt}
     */
    function compileIllegal(mode, _parent) {
      if (!Array.isArray(mode.illegal)) return;

      mode.illegal = either(...mode.illegal);
    }

    /**
     * `match` to match a single expression for readability
     * @type {CompilerExt}
     */
    function compileMatch(mode, _parent) {
      if (!mode.match) return;
      if (mode.begin || mode.end) throw new Error("begin & end are not supported with match");

      mode.begin = mode.match;
      delete mode.match;
    }

    /**
     * provides the default 1 relevance to all modes
     * @type {CompilerExt}
     */
    function compileRelevance(mode, _parent) {
      // eslint-disable-next-line no-undefined
      if (mode.relevance === undefined) mode.relevance = 1;
    }

    // keywords that should have no default relevance value
    const COMMON_KEYWORDS = [
      'of',
      'and',
      'for',
      'in',
      'not',
      'or',
      'if',
      'then',
      'parent', // common variable name
      'list', // common variable name
      'value' // common variable name
    ];

    const DEFAULT_KEYWORD_CLASSNAME = "keyword";

    /**
     * Given raw keywords from a language definition, compile them.
     *
     * @param {string | Record<string,string|string[]> | Array<string>} rawKeywords
     * @param {boolean} caseInsensitive
     */
    function compileKeywords(rawKeywords, caseInsensitive, className = DEFAULT_KEYWORD_CLASSNAME) {
      /** @type KeywordDict */
      const compiledKeywords = {};

      // input can be a string of keywords, an array of keywords, or a object with
      // named keys representing className (which can then point to a string or array)
      if (typeof rawKeywords === 'string') {
        compileList(className, rawKeywords.split(" "));
      } else if (Array.isArray(rawKeywords)) {
        compileList(className, rawKeywords);
      } else {
        Object.keys(rawKeywords).forEach(function(className) {
          // collapse all our objects back into the parent object
          Object.assign(
            compiledKeywords,
            compileKeywords(rawKeywords[className], caseInsensitive, className)
          );
        });
      }
      return compiledKeywords;

      // ---

      /**
       * Compiles an individual list of keywords
       *
       * Ex: "for if when while|5"
       *
       * @param {string} className
       * @param {Array<string>} keywordList
       */
      function compileList(className, keywordList) {
        if (caseInsensitive) {
          keywordList = keywordList.map(x => x.toLowerCase());
        }
        keywordList.forEach(function(keyword) {
          const pair = keyword.split('|');
          compiledKeywords[pair[0]] = [className, scoreForKeyword(pair[0], pair[1])];
        });
      }
    }

    /**
     * Returns the proper score for a given keyword
     *
     * Also takes into account comment keywords, which will be scored 0 UNLESS
     * another score has been manually assigned.
     * @param {string} keyword
     * @param {string} [providedScore]
     */
    function scoreForKeyword(keyword, providedScore) {
      // manual scores always win over common keywords
      // so you can force a score of 1 if you really insist
      if (providedScore) {
        return Number(providedScore);
      }

      return commonKeyword(keyword) ? 0 : 1;
    }

    /**
     * Determines if a given keyword is common or not
     *
     * @param {string} keyword */
    function commonKeyword(keyword) {
      return COMMON_KEYWORDS.includes(keyword.toLowerCase());
    }

    // compilation

    /**
     * Compiles a language definition result
     *
     * Given the raw result of a language definition (Language), compiles this so
     * that it is ready for highlighting code.
     * @param {Language} language
     * @param {{plugins: HLJSPlugin[]}} opts
     * @returns {CompiledLanguage}
     */
    function compileLanguage(language, { plugins }) {
      /**
       * Builds a regex with the case sensativility of the current language
       *
       * @param {RegExp | string} value
       * @param {boolean} [global]
       */
      function langRe(value, global) {
        return new RegExp(
          source$1(value),
          'm' + (language.case_insensitive ? 'i' : '') + (global ? 'g' : '')
        );
      }

      /**
        Stores multiple regular expressions and allows you to quickly search for
        them all in a string simultaneously - returning the first match.  It does
        this by creating a huge (a|b|c) regex - each individual item wrapped with ()
        and joined by `|` - using match groups to track position.  When a match is
        found checking which position in the array has content allows us to figure
        out which of the original regexes / match groups triggered the match.

        The match object itself (the result of `Regex.exec`) is returned but also
        enhanced by merging in any meta-data that was registered with the regex.
        This is how we keep track of which mode matched, and what type of rule
        (`illegal`, `begin`, end, etc).
      */
      class MultiRegex {
        constructor() {
          this.matchIndexes = {};
          // @ts-ignore
          this.regexes = [];
          this.matchAt = 1;
          this.position = 0;
        }

        // @ts-ignore
        addRule(re, opts) {
          opts.position = this.position++;
          // @ts-ignore
          this.matchIndexes[this.matchAt] = opts;
          this.regexes.push([opts, re]);
          this.matchAt += countMatchGroups(re) + 1;
        }

        compile() {
          if (this.regexes.length === 0) {
            // avoids the need to check length every time exec is called
            // @ts-ignore
            this.exec = () => null;
          }
          const terminators = this.regexes.map(el => el[1]);
          this.matcherRe = langRe(join(terminators), true);
          this.lastIndex = 0;
        }

        /** @param {string} s */
        exec(s) {
          this.matcherRe.lastIndex = this.lastIndex;
          const match = this.matcherRe.exec(s);
          if (!match) { return null; }

          // eslint-disable-next-line no-undefined
          const i = match.findIndex((el, i) => i > 0 && el !== undefined);
          // @ts-ignore
          const matchData = this.matchIndexes[i];
          // trim off any earlier non-relevant match groups (ie, the other regex
          // match groups that make up the multi-matcher)
          match.splice(0, i);

          return Object.assign(match, matchData);
        }
      }

      /*
        Created to solve the key deficiently with MultiRegex - there is no way to
        test for multiple matches at a single location.  Why would we need to do
        that?  In the future a more dynamic engine will allow certain matches to be
        ignored.  An example: if we matched say the 3rd regex in a large group but
        decided to ignore it - we'd need to started testing again at the 4th
        regex... but MultiRegex itself gives us no real way to do that.

        So what this class creates MultiRegexs on the fly for whatever search
        position they are needed.

        NOTE: These additional MultiRegex objects are created dynamically.  For most
        grammars most of the time we will never actually need anything more than the
        first MultiRegex - so this shouldn't have too much overhead.

        Say this is our search group, and we match regex3, but wish to ignore it.

          regex1 | regex2 | regex3 | regex4 | regex5    ' ie, startAt = 0

        What we need is a new MultiRegex that only includes the remaining
        possibilities:

          regex4 | regex5                               ' ie, startAt = 3

        This class wraps all that complexity up in a simple API... `startAt` decides
        where in the array of expressions to start doing the matching. It
        auto-increments, so if a match is found at position 2, then startAt will be
        set to 3.  If the end is reached startAt will return to 0.

        MOST of the time the parser will be setting startAt manually to 0.
      */
      class ResumableMultiRegex {
        constructor() {
          // @ts-ignore
          this.rules = [];
          // @ts-ignore
          this.multiRegexes = [];
          this.count = 0;

          this.lastIndex = 0;
          this.regexIndex = 0;
        }

        // @ts-ignore
        getMatcher(index) {
          if (this.multiRegexes[index]) return this.multiRegexes[index];

          const matcher = new MultiRegex();
          this.rules.slice(index).forEach(([re, opts]) => matcher.addRule(re, opts));
          matcher.compile();
          this.multiRegexes[index] = matcher;
          return matcher;
        }

        resumingScanAtSamePosition() {
          return this.regexIndex !== 0;
        }

        considerAll() {
          this.regexIndex = 0;
        }

        // @ts-ignore
        addRule(re, opts) {
          this.rules.push([re, opts]);
          if (opts.type === "begin") this.count++;
        }

        /** @param {string} s */
        exec(s) {
          const m = this.getMatcher(this.regexIndex);
          m.lastIndex = this.lastIndex;
          let result = m.exec(s);

          // The following is because we have no easy way to say "resume scanning at the
          // existing position but also skip the current rule ONLY". What happens is
          // all prior rules are also skipped which can result in matching the wrong
          // thing. Example of matching "booger":

          // our matcher is [string, "booger", number]
          //
          // ....booger....

          // if "booger" is ignored then we'd really need a regex to scan from the
          // SAME position for only: [string, number] but ignoring "booger" (if it
          // was the first match), a simple resume would scan ahead who knows how
          // far looking only for "number", ignoring potential string matches (or
          // future "booger" matches that might be valid.)

          // So what we do: We execute two matchers, one resuming at the same
          // position, but the second full matcher starting at the position after:

          //     /--- resume first regex match here (for [number])
          //     |/---- full match here for [string, "booger", number]
          //     vv
          // ....booger....

          // Which ever results in a match first is then used. So this 3-4 step
          // process essentially allows us to say "match at this position, excluding
          // a prior rule that was ignored".
          //
          // 1. Match "booger" first, ignore. Also proves that [string] does non match.
          // 2. Resume matching for [number]
          // 3. Match at index + 1 for [string, "booger", number]
          // 4. If #2 and #3 result in matches, which came first?
          if (this.resumingScanAtSamePosition()) {
            if (result && result.index === this.lastIndex) ; else { // use the second matcher result
              const m2 = this.getMatcher(0);
              m2.lastIndex = this.lastIndex + 1;
              result = m2.exec(s);
            }
          }

          if (result) {
            this.regexIndex += result.position + 1;
            if (this.regexIndex === this.count) {
              // wrap-around to considering all matches again
              this.considerAll();
            }
          }

          return result;
        }
      }

      /**
       * Given a mode, builds a huge ResumableMultiRegex that can be used to walk
       * the content and find matches.
       *
       * @param {CompiledMode} mode
       * @returns {ResumableMultiRegex}
       */
      function buildModeRegex(mode) {
        const mm = new ResumableMultiRegex();

        mode.contains.forEach(term => mm.addRule(term.begin, { rule: term, type: "begin" }));

        if (mode.terminatorEnd) {
          mm.addRule(mode.terminatorEnd, { type: "end" });
        }
        if (mode.illegal) {
          mm.addRule(mode.illegal, { type: "illegal" });
        }

        return mm;
      }

      /** skip vs abort vs ignore
       *
       * @skip   - The mode is still entered and exited normally (and contains rules apply),
       *           but all content is held and added to the parent buffer rather than being
       *           output when the mode ends.  Mostly used with `sublanguage` to build up
       *           a single large buffer than can be parsed by sublanguage.
       *
       *             - The mode begin ands ends normally.
       *             - Content matched is added to the parent mode buffer.
       *             - The parser cursor is moved forward normally.
       *
       * @abort  - A hack placeholder until we have ignore.  Aborts the mode (as if it
       *           never matched) but DOES NOT continue to match subsequent `contains`
       *           modes.  Abort is bad/suboptimal because it can result in modes
       *           farther down not getting applied because an earlier rule eats the
       *           content but then aborts.
       *
       *             - The mode does not begin.
       *             - Content matched by `begin` is added to the mode buffer.
       *             - The parser cursor is moved forward accordingly.
       *
       * @ignore - Ignores the mode (as if it never matched) and continues to match any
       *           subsequent `contains` modes.  Ignore isn't technically possible with
       *           the current parser implementation.
       *
       *             - The mode does not begin.
       *             - Content matched by `begin` is ignored.
       *             - The parser cursor is not moved forward.
       */

      /**
       * Compiles an individual mode
       *
       * This can raise an error if the mode contains certain detectable known logic
       * issues.
       * @param {Mode} mode
       * @param {CompiledMode | null} [parent]
       * @returns {CompiledMode | never}
       */
      function compileMode(mode, parent) {
        const cmode = /** @type CompiledMode */ (mode);
        if (mode.isCompiled) return cmode;

        [
          // do this early so compiler extensions generally don't have to worry about
          // the distinction between match/begin
          compileMatch
        ].forEach(ext => ext(mode, parent));

        language.compilerExtensions.forEach(ext => ext(mode, parent));

        // __beforeBegin is considered private API, internal use only
        mode.__beforeBegin = null;

        [
          beginKeywords,
          // do this later so compiler extensions that come earlier have access to the
          // raw array if they wanted to perhaps manipulate it, etc.
          compileIllegal,
          // default to 1 relevance if not specified
          compileRelevance
        ].forEach(ext => ext(mode, parent));

        mode.isCompiled = true;

        let keywordPattern = null;
        if (typeof mode.keywords === "object") {
          keywordPattern = mode.keywords.$pattern;
          delete mode.keywords.$pattern;
        }

        if (mode.keywords) {
          mode.keywords = compileKeywords(mode.keywords, language.case_insensitive);
        }

        // both are not allowed
        if (mode.lexemes && keywordPattern) {
          throw new Error("ERR: Prefer `keywords.$pattern` to `mode.lexemes`, BOTH are not allowed. (see mode reference) ");
        }

        // `mode.lexemes` was the old standard before we added and now recommend
        // using `keywords.$pattern` to pass the keyword pattern
        keywordPattern = keywordPattern || mode.lexemes || /\w+/;
        cmode.keywordPatternRe = langRe(keywordPattern, true);

        if (parent) {
          if (!mode.begin) mode.begin = /\B|\b/;
          cmode.beginRe = langRe(mode.begin);
          if (mode.endSameAsBegin) mode.end = mode.begin;
          if (!mode.end && !mode.endsWithParent) mode.end = /\B|\b/;
          if (mode.end) cmode.endRe = langRe(mode.end);
          cmode.terminatorEnd = source$1(mode.end) || '';
          if (mode.endsWithParent && parent.terminatorEnd) {
            cmode.terminatorEnd += (mode.end ? '|' : '') + parent.terminatorEnd;
          }
        }
        if (mode.illegal) cmode.illegalRe = langRe(/** @type {RegExp | string} */ (mode.illegal));
        if (!mode.contains) mode.contains = [];

        mode.contains = [].concat(...mode.contains.map(function(c) {
          return expandOrCloneMode(c === 'self' ? mode : c);
        }));
        mode.contains.forEach(function(c) { compileMode(/** @type Mode */ (c), cmode); });

        if (mode.starts) {
          compileMode(mode.starts, parent);
        }

        cmode.matcher = buildModeRegex(cmode);
        return cmode;
      }

      if (!language.compilerExtensions) language.compilerExtensions = [];

      // self is not valid at the top-level
      if (language.contains && language.contains.includes('self')) {
        throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
      }

      // we need a null object, which inherit will guarantee
      language.classNameAliases = inherit(language.classNameAliases || {});

      return compileMode(/** @type Mode */ (language));
    }

    /**
     * Determines if a mode has a dependency on it's parent or not
     *
     * If a mode does have a parent dependency then often we need to clone it if
     * it's used in multiple places so that each copy points to the correct parent,
     * where-as modes without a parent can often safely be re-used at the bottom of
     * a mode chain.
     *
     * @param {Mode | null} mode
     * @returns {boolean} - is there a dependency on the parent?
     * */
    function dependencyOnParent(mode) {
      if (!mode) return false;

      return mode.endsWithParent || dependencyOnParent(mode.starts);
    }

    /**
     * Expands a mode or clones it if necessary
     *
     * This is necessary for modes with parental dependenceis (see notes on
     * `dependencyOnParent`) and for nodes that have `variants` - which must then be
     * exploded into their own individual modes at compile time.
     *
     * @param {Mode} mode
     * @returns {Mode | Mode[]}
     * */
    function expandOrCloneMode(mode) {
      if (mode.variants && !mode.cachedVariants) {
        mode.cachedVariants = mode.variants.map(function(variant) {
          return inherit(mode, { variants: null }, variant);
        });
      }

      // EXPAND
      // if we have variants then essentially "replace" the mode with the variants
      // this happens in compileMode, where this function is called from
      if (mode.cachedVariants) {
        return mode.cachedVariants;
      }

      // CLONE
      // if we have dependencies on parents then we need a unique
      // instance of ourselves, so we can be reused with many
      // different parents without issue
      if (dependencyOnParent(mode)) {
        return inherit(mode, { starts: mode.starts ? inherit(mode.starts) : null });
      }

      if (Object.isFrozen(mode)) {
        return inherit(mode);
      }

      // no special dependency issues, just return ourselves
      return mode;
    }

    var version = "10.7.3";

    // @ts-nocheck

    function hasValueOrEmptyAttribute(value) {
      return Boolean(value || value === "");
    }

    function BuildVuePlugin(hljs) {
      const Component = {
        props: ["language", "code", "autodetect"],
        data: function() {
          return {
            detectedLanguage: "",
            unknownLanguage: false
          };
        },
        computed: {
          className() {
            if (this.unknownLanguage) return "";

            return "hljs " + this.detectedLanguage;
          },
          highlighted() {
            // no idea what language to use, return raw code
            if (!this.autoDetect && !hljs.getLanguage(this.language)) {
              console.warn(`The language "${this.language}" you specified could not be found.`);
              this.unknownLanguage = true;
              return escapeHTML(this.code);
            }

            let result = {};
            if (this.autoDetect) {
              result = hljs.highlightAuto(this.code);
              this.detectedLanguage = result.language;
            } else {
              result = hljs.highlight(this.language, this.code, this.ignoreIllegals);
              this.detectedLanguage = this.language;
            }
            return result.value;
          },
          autoDetect() {
            return !this.language || hasValueOrEmptyAttribute(this.autodetect);
          },
          ignoreIllegals() {
            return true;
          }
        },
        // this avoids needing to use a whole Vue compilation pipeline just
        // to build Highlight.js
        render(createElement) {
          return createElement("pre", {}, [
            createElement("code", {
              class: this.className,
              domProps: { innerHTML: this.highlighted }
            })
          ]);
        }
        // template: `<pre><code :class="className" v-html="highlighted"></code></pre>`
      };

      const VuePlugin = {
        install(Vue) {
          Vue.component('highlightjs', Component);
        }
      };

      return { Component, VuePlugin };
    }

    /* plugin itself */

    /** @type {HLJSPlugin} */
    const mergeHTMLPlugin = {
      "after:highlightElement": ({ el, result, text }) => {
        const originalStream = nodeStream(el);
        if (!originalStream.length) return;

        const resultNode = document.createElement('div');
        resultNode.innerHTML = result.value;
        result.value = mergeStreams(originalStream, nodeStream(resultNode), text);
      }
    };

    /* Stream merging support functions */

    /**
     * @typedef Event
     * @property {'start'|'stop'} event
     * @property {number} offset
     * @property {Node} node
     */

    /**
     * @param {Node} node
     */
    function tag(node) {
      return node.nodeName.toLowerCase();
    }

    /**
     * @param {Node} node
     */
    function nodeStream(node) {
      /** @type Event[] */
      const result = [];
      (function _nodeStream(node, offset) {
        for (let child = node.firstChild; child; child = child.nextSibling) {
          if (child.nodeType === 3) {
            offset += child.nodeValue.length;
          } else if (child.nodeType === 1) {
            result.push({
              event: 'start',
              offset: offset,
              node: child
            });
            offset = _nodeStream(child, offset);
            // Prevent void elements from having an end tag that would actually
            // double them in the output. There are more void elements in HTML
            // but we list only those realistically expected in code display.
            if (!tag(child).match(/br|hr|img|input/)) {
              result.push({
                event: 'stop',
                offset: offset,
                node: child
              });
            }
          }
        }
        return offset;
      })(node, 0);
      return result;
    }

    /**
     * @param {any} original - the original stream
     * @param {any} highlighted - stream of the highlighted source
     * @param {string} value - the original source itself
     */
    function mergeStreams(original, highlighted, value) {
      let processed = 0;
      let result = '';
      const nodeStack = [];

      function selectStream() {
        if (!original.length || !highlighted.length) {
          return original.length ? original : highlighted;
        }
        if (original[0].offset !== highlighted[0].offset) {
          return (original[0].offset < highlighted[0].offset) ? original : highlighted;
        }

        /*
        To avoid starting the stream just before it should stop the order is
        ensured that original always starts first and closes last:

        if (event1 == 'start' && event2 == 'start')
          return original;
        if (event1 == 'start' && event2 == 'stop')
          return highlighted;
        if (event1 == 'stop' && event2 == 'start')
          return original;
        if (event1 == 'stop' && event2 == 'stop')
          return highlighted;

        ... which is collapsed to:
        */
        return highlighted[0].event === 'start' ? original : highlighted;
      }

      /**
       * @param {Node} node
       */
      function open(node) {
        /** @param {Attr} attr */
        function attributeString(attr) {
          return ' ' + attr.nodeName + '="' + escapeHTML(attr.value) + '"';
        }
        // @ts-ignore
        result += '<' + tag(node) + [].map.call(node.attributes, attributeString).join('') + '>';
      }

      /**
       * @param {Node} node
       */
      function close(node) {
        result += '</' + tag(node) + '>';
      }

      /**
       * @param {Event} event
       */
      function render(event) {
        (event.event === 'start' ? open : close)(event.node);
      }

      while (original.length || highlighted.length) {
        let stream = selectStream();
        result += escapeHTML(value.substring(processed, stream[0].offset));
        processed = stream[0].offset;
        if (stream === original) {
          /*
          On any opening or closing tag of the original markup we first close
          the entire highlighted node stack, then render the original tag along
          with all the following original tags at the same offset and then
          reopen all the tags on the highlighted stack.
          */
          nodeStack.reverse().forEach(close);
          do {
            render(stream.splice(0, 1)[0]);
            stream = selectStream();
          } while (stream === original && stream.length && stream[0].offset === processed);
          nodeStack.reverse().forEach(open);
        } else {
          if (stream[0].event === 'start') {
            nodeStack.push(stream[0].node);
          } else {
            nodeStack.pop();
          }
          render(stream.splice(0, 1)[0]);
        }
      }
      return result + escapeHTML(value.substr(processed));
    }

    /*

    For the reasoning behind this please see:
    https://github.com/highlightjs/highlight.js/issues/2880#issuecomment-747275419

    */

    /**
     * @type {Record<string, boolean>}
     */
    const seenDeprecations = {};

    /**
     * @param {string} message
     */
    const error = (message) => {
      console.error(message);
    };

    /**
     * @param {string} message
     * @param {any} args
     */
    const warn = (message, ...args) => {
      console.log(`WARN: ${message}`, ...args);
    };

    /**
     * @param {string} version
     * @param {string} message
     */
    const deprecated = (version, message) => {
      if (seenDeprecations[`${version}/${message}`]) return;

      console.log(`Deprecated as of ${version}. ${message}`);
      seenDeprecations[`${version}/${message}`] = true;
    };

    /*
    Syntax highlighting with language autodetection.
    https://highlightjs.org/
    */

    const escape$1 = escapeHTML;
    const inherit$1 = inherit;
    const NO_MATCH = Symbol("nomatch");

    /**
     * @param {any} hljs - object that is extended (legacy)
     * @returns {HLJSApi}
     */
    const HLJS = function(hljs) {
      // Global internal variables used within the highlight.js library.
      /** @type {Record<string, Language>} */
      const languages = Object.create(null);
      /** @type {Record<string, string>} */
      const aliases = Object.create(null);
      /** @type {HLJSPlugin[]} */
      const plugins = [];

      // safe/production mode - swallows more errors, tries to keep running
      // even if a single syntax or parse hits a fatal error
      let SAFE_MODE = true;
      const fixMarkupRe = /(^(<[^>]+>|\t|)+|\n)/gm;
      const LANGUAGE_NOT_FOUND = "Could not find the language '{}', did you forget to load/include a language module?";
      /** @type {Language} */
      const PLAINTEXT_LANGUAGE = { disableAutodetect: true, name: 'Plain text', contains: [] };

      // Global options used when within external APIs. This is modified when
      // calling the `hljs.configure` function.
      /** @type HLJSOptions */
      let options = {
        noHighlightRe: /^(no-?highlight)$/i,
        languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
        classPrefix: 'hljs-',
        tabReplace: null,
        useBR: false,
        languages: null,
        // beta configuration options, subject to change, welcome to discuss
        // https://github.com/highlightjs/highlight.js/issues/1086
        __emitter: TokenTreeEmitter
      };

      /* Utility functions */

      /**
       * Tests a language name to see if highlighting should be skipped
       * @param {string} languageName
       */
      function shouldNotHighlight(languageName) {
        return options.noHighlightRe.test(languageName);
      }

      /**
       * @param {HighlightedHTMLElement} block - the HTML element to determine language for
       */
      function blockLanguage(block) {
        let classes = block.className + ' ';

        classes += block.parentNode ? block.parentNode.className : '';

        // language-* takes precedence over non-prefixed class names.
        const match = options.languageDetectRe.exec(classes);
        if (match) {
          const language = getLanguage(match[1]);
          if (!language) {
            warn(LANGUAGE_NOT_FOUND.replace("{}", match[1]));
            warn("Falling back to no-highlight mode for this block.", block);
          }
          return language ? match[1] : 'no-highlight';
        }

        return classes
          .split(/\s+/)
          .find((_class) => shouldNotHighlight(_class) || getLanguage(_class));
      }

      /**
       * Core highlighting function.
       *
       * OLD API
       * highlight(lang, code, ignoreIllegals, continuation)
       *
       * NEW API
       * highlight(code, {lang, ignoreIllegals})
       *
       * @param {string} codeOrlanguageName - the language to use for highlighting
       * @param {string | HighlightOptions} optionsOrCode - the code to highlight
       * @param {boolean} [ignoreIllegals] - whether to ignore illegal matches, default is to bail
       * @param {CompiledMode} [continuation] - current continuation mode, if any
       *
       * @returns {HighlightResult} Result - an object that represents the result
       * @property {string} language - the language name
       * @property {number} relevance - the relevance score
       * @property {string} value - the highlighted HTML code
       * @property {string} code - the original raw code
       * @property {CompiledMode} top - top of the current mode stack
       * @property {boolean} illegal - indicates whether any illegal matches were found
      */
      function highlight(codeOrlanguageName, optionsOrCode, ignoreIllegals, continuation) {
        let code = "";
        let languageName = "";
        if (typeof optionsOrCode === "object") {
          code = codeOrlanguageName;
          ignoreIllegals = optionsOrCode.ignoreIllegals;
          languageName = optionsOrCode.language;
          // continuation not supported at all via the new API
          // eslint-disable-next-line no-undefined
          continuation = undefined;
        } else {
          // old API
          deprecated("10.7.0", "highlight(lang, code, ...args) has been deprecated.");
          deprecated("10.7.0", "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277");
          languageName = codeOrlanguageName;
          code = optionsOrCode;
        }

        /** @type {BeforeHighlightContext} */
        const context = {
          code,
          language: languageName
        };
        // the plugin can change the desired language or the code to be highlighted
        // just be changing the object it was passed
        fire("before:highlight", context);

        // a before plugin can usurp the result completely by providing it's own
        // in which case we don't even need to call highlight
        const result = context.result
          ? context.result
          : _highlight(context.language, context.code, ignoreIllegals, continuation);

        result.code = context.code;
        // the plugin can change anything in result to suite it
        fire("after:highlight", result);

        return result;
      }

      /**
       * private highlight that's used internally and does not fire callbacks
       *
       * @param {string} languageName - the language to use for highlighting
       * @param {string} codeToHighlight - the code to highlight
       * @param {boolean?} [ignoreIllegals] - whether to ignore illegal matches, default is to bail
       * @param {CompiledMode?} [continuation] - current continuation mode, if any
       * @returns {HighlightResult} - result of the highlight operation
      */
      function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {
        /**
         * Return keyword data if a match is a keyword
         * @param {CompiledMode} mode - current mode
         * @param {RegExpMatchArray} match - regexp match data
         * @returns {KeywordData | false}
         */
        function keywordData(mode, match) {
          const matchText = language.case_insensitive ? match[0].toLowerCase() : match[0];
          return Object.prototype.hasOwnProperty.call(mode.keywords, matchText) && mode.keywords[matchText];
        }

        function processKeywords() {
          if (!top.keywords) {
            emitter.addText(modeBuffer);
            return;
          }

          let lastIndex = 0;
          top.keywordPatternRe.lastIndex = 0;
          let match = top.keywordPatternRe.exec(modeBuffer);
          let buf = "";

          while (match) {
            buf += modeBuffer.substring(lastIndex, match.index);
            const data = keywordData(top, match);
            if (data) {
              const [kind, keywordRelevance] = data;
              emitter.addText(buf);
              buf = "";

              relevance += keywordRelevance;
              if (kind.startsWith("_")) {
                // _ implied for relevance only, do not highlight
                // by applying a class name
                buf += match[0];
              } else {
                const cssClass = language.classNameAliases[kind] || kind;
                emitter.addKeyword(match[0], cssClass);
              }
            } else {
              buf += match[0];
            }
            lastIndex = top.keywordPatternRe.lastIndex;
            match = top.keywordPatternRe.exec(modeBuffer);
          }
          buf += modeBuffer.substr(lastIndex);
          emitter.addText(buf);
        }

        function processSubLanguage() {
          if (modeBuffer === "") return;
          /** @type HighlightResult */
          let result = null;

          if (typeof top.subLanguage === 'string') {
            if (!languages[top.subLanguage]) {
              emitter.addText(modeBuffer);
              return;
            }
            result = _highlight(top.subLanguage, modeBuffer, true, continuations[top.subLanguage]);
            continuations[top.subLanguage] = /** @type {CompiledMode} */ (result.top);
          } else {
            result = highlightAuto(modeBuffer, top.subLanguage.length ? top.subLanguage : null);
          }

          // Counting embedded language score towards the host language may be disabled
          // with zeroing the containing mode relevance. Use case in point is Markdown that
          // allows XML everywhere and makes every XML snippet to have a much larger Markdown
          // score.
          if (top.relevance > 0) {
            relevance += result.relevance;
          }
          emitter.addSublanguage(result.emitter, result.language);
        }

        function processBuffer() {
          if (top.subLanguage != null) {
            processSubLanguage();
          } else {
            processKeywords();
          }
          modeBuffer = '';
        }

        /**
         * @param {Mode} mode - new mode to start
         */
        function startNewMode(mode) {
          if (mode.className) {
            emitter.openNode(language.classNameAliases[mode.className] || mode.className);
          }
          top = Object.create(mode, { parent: { value: top } });
          return top;
        }

        /**
         * @param {CompiledMode } mode - the mode to potentially end
         * @param {RegExpMatchArray} match - the latest match
         * @param {string} matchPlusRemainder - match plus remainder of content
         * @returns {CompiledMode | void} - the next mode, or if void continue on in current mode
         */
        function endOfMode(mode, match, matchPlusRemainder) {
          let matched = startsWith(mode.endRe, matchPlusRemainder);

          if (matched) {
            if (mode["on:end"]) {
              const resp = new Response(mode);
              mode["on:end"](match, resp);
              if (resp.isMatchIgnored) matched = false;
            }

            if (matched) {
              while (mode.endsParent && mode.parent) {
                mode = mode.parent;
              }
              return mode;
            }
          }
          // even if on:end fires an `ignore` it's still possible
          // that we might trigger the end node because of a parent mode
          if (mode.endsWithParent) {
            return endOfMode(mode.parent, match, matchPlusRemainder);
          }
        }

        /**
         * Handle matching but then ignoring a sequence of text
         *
         * @param {string} lexeme - string containing full match text
         */
        function doIgnore(lexeme) {
          if (top.matcher.regexIndex === 0) {
            // no more regexs to potentially match here, so we move the cursor forward one
            // space
            modeBuffer += lexeme[0];
            return 1;
          } else {
            // no need to move the cursor, we still have additional regexes to try and
            // match at this very spot
            resumeScanAtSamePosition = true;
            return 0;
          }
        }

        /**
         * Handle the start of a new potential mode match
         *
         * @param {EnhancedMatch} match - the current match
         * @returns {number} how far to advance the parse cursor
         */
        function doBeginMatch(match) {
          const lexeme = match[0];
          const newMode = match.rule;

          const resp = new Response(newMode);
          // first internal before callbacks, then the public ones
          const beforeCallbacks = [newMode.__beforeBegin, newMode["on:begin"]];
          for (const cb of beforeCallbacks) {
            if (!cb) continue;
            cb(match, resp);
            if (resp.isMatchIgnored) return doIgnore(lexeme);
          }

          if (newMode && newMode.endSameAsBegin) {
            newMode.endRe = escape(lexeme);
          }

          if (newMode.skip) {
            modeBuffer += lexeme;
          } else {
            if (newMode.excludeBegin) {
              modeBuffer += lexeme;
            }
            processBuffer();
            if (!newMode.returnBegin && !newMode.excludeBegin) {
              modeBuffer = lexeme;
            }
          }
          startNewMode(newMode);
          // if (mode["after:begin"]) {
          //   let resp = new Response(mode);
          //   mode["after:begin"](match, resp);
          // }
          return newMode.returnBegin ? 0 : lexeme.length;
        }

        /**
         * Handle the potential end of mode
         *
         * @param {RegExpMatchArray} match - the current match
         */
        function doEndMatch(match) {
          const lexeme = match[0];
          const matchPlusRemainder = codeToHighlight.substr(match.index);

          const endMode = endOfMode(top, match, matchPlusRemainder);
          if (!endMode) { return NO_MATCH; }

          const origin = top;
          if (origin.skip) {
            modeBuffer += lexeme;
          } else {
            if (!(origin.returnEnd || origin.excludeEnd)) {
              modeBuffer += lexeme;
            }
            processBuffer();
            if (origin.excludeEnd) {
              modeBuffer = lexeme;
            }
          }
          do {
            if (top.className) {
              emitter.closeNode();
            }
            if (!top.skip && !top.subLanguage) {
              relevance += top.relevance;
            }
            top = top.parent;
          } while (top !== endMode.parent);
          if (endMode.starts) {
            if (endMode.endSameAsBegin) {
              endMode.starts.endRe = endMode.endRe;
            }
            startNewMode(endMode.starts);
          }
          return origin.returnEnd ? 0 : lexeme.length;
        }

        function processContinuations() {
          const list = [];
          for (let current = top; current !== language; current = current.parent) {
            if (current.className) {
              list.unshift(current.className);
            }
          }
          list.forEach(item => emitter.openNode(item));
        }

        /** @type {{type?: MatchType, index?: number, rule?: Mode}}} */
        let lastMatch = {};

        /**
         *  Process an individual match
         *
         * @param {string} textBeforeMatch - text preceeding the match (since the last match)
         * @param {EnhancedMatch} [match] - the match itself
         */
        function processLexeme(textBeforeMatch, match) {
          const lexeme = match && match[0];

          // add non-matched text to the current mode buffer
          modeBuffer += textBeforeMatch;

          if (lexeme == null) {
            processBuffer();
            return 0;
          }

          // we've found a 0 width match and we're stuck, so we need to advance
          // this happens when we have badly behaved rules that have optional matchers to the degree that
          // sometimes they can end up matching nothing at all
          // Ref: https://github.com/highlightjs/highlight.js/issues/2140
          if (lastMatch.type === "begin" && match.type === "end" && lastMatch.index === match.index && lexeme === "") {
            // spit the "skipped" character that our regex choked on back into the output sequence
            modeBuffer += codeToHighlight.slice(match.index, match.index + 1);
            if (!SAFE_MODE) {
              /** @type {AnnotatedError} */
              const err = new Error('0 width match regex');
              err.languageName = languageName;
              err.badRule = lastMatch.rule;
              throw err;
            }
            return 1;
          }
          lastMatch = match;

          if (match.type === "begin") {
            return doBeginMatch(match);
          } else if (match.type === "illegal" && !ignoreIllegals) {
            // illegal match, we do not continue processing
            /** @type {AnnotatedError} */
            const err = new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top.className || '<unnamed>') + '"');
            err.mode = top;
            throw err;
          } else if (match.type === "end") {
            const processed = doEndMatch(match);
            if (processed !== NO_MATCH) {
              return processed;
            }
          }

          // edge case for when illegal matches $ (end of line) which is technically
          // a 0 width match but not a begin/end match so it's not caught by the
          // first handler (when ignoreIllegals is true)
          if (match.type === "illegal" && lexeme === "") {
            // advance so we aren't stuck in an infinite loop
            return 1;
          }

          // infinite loops are BAD, this is a last ditch catch all. if we have a
          // decent number of iterations yet our index (cursor position in our
          // parsing) still 3x behind our index then something is very wrong
          // so we bail
          if (iterations > 100000 && iterations > match.index * 3) {
            const err = new Error('potential infinite loop, way more iterations than matches');
            throw err;
          }

          /*
          Why might be find ourselves here?  Only one occasion now.  An end match that was
          triggered but could not be completed.  When might this happen?  When an `endSameasBegin`
          rule sets the end rule to a specific match.  Since the overall mode termination rule that's
          being used to scan the text isn't recompiled that means that any match that LOOKS like
          the end (but is not, because it is not an exact match to the beginning) will
          end up here.  A definite end match, but when `doEndMatch` tries to "reapply"
          the end rule and fails to match, we wind up here, and just silently ignore the end.

          This causes no real harm other than stopping a few times too many.
          */

          modeBuffer += lexeme;
          return lexeme.length;
        }

        const language = getLanguage(languageName);
        if (!language) {
          error(LANGUAGE_NOT_FOUND.replace("{}", languageName));
          throw new Error('Unknown language: "' + languageName + '"');
        }

        const md = compileLanguage(language, { plugins });
        let result = '';
        /** @type {CompiledMode} */
        let top = continuation || md;
        /** @type Record<string,CompiledMode> */
        const continuations = {}; // keep continuations for sub-languages
        const emitter = new options.__emitter(options);
        processContinuations();
        let modeBuffer = '';
        let relevance = 0;
        let index = 0;
        let iterations = 0;
        let resumeScanAtSamePosition = false;

        try {
          top.matcher.considerAll();

          for (;;) {
            iterations++;
            if (resumeScanAtSamePosition) {
              // only regexes not matched previously will now be
              // considered for a potential match
              resumeScanAtSamePosition = false;
            } else {
              top.matcher.considerAll();
            }
            top.matcher.lastIndex = index;

            const match = top.matcher.exec(codeToHighlight);
            // console.log("match", match[0], match.rule && match.rule.begin)

            if (!match) break;

            const beforeMatch = codeToHighlight.substring(index, match.index);
            const processedCount = processLexeme(beforeMatch, match);
            index = match.index + processedCount;
          }
          processLexeme(codeToHighlight.substr(index));
          emitter.closeAllNodes();
          emitter.finalize();
          result = emitter.toHTML();

          return {
            // avoid possible breakage with v10 clients expecting
            // this to always be an integer
            relevance: Math.floor(relevance),
            value: result,
            language: languageName,
            illegal: false,
            emitter: emitter,
            top: top
          };
        } catch (err) {
          if (err.message && err.message.includes('Illegal')) {
            return {
              illegal: true,
              illegalBy: {
                msg: err.message,
                context: codeToHighlight.slice(index - 100, index + 100),
                mode: err.mode
              },
              sofar: result,
              relevance: 0,
              value: escape$1(codeToHighlight),
              emitter: emitter
            };
          } else if (SAFE_MODE) {
            return {
              illegal: false,
              relevance: 0,
              value: escape$1(codeToHighlight),
              emitter: emitter,
              language: languageName,
              top: top,
              errorRaised: err
            };
          } else {
            throw err;
          }
        }
      }

      /**
       * returns a valid highlight result, without actually doing any actual work,
       * auto highlight starts with this and it's possible for small snippets that
       * auto-detection may not find a better match
       * @param {string} code
       * @returns {HighlightResult}
       */
      function justTextHighlightResult(code) {
        const result = {
          relevance: 0,
          emitter: new options.__emitter(options),
          value: escape$1(code),
          illegal: false,
          top: PLAINTEXT_LANGUAGE
        };
        result.emitter.addText(code);
        return result;
      }

      /**
      Highlighting with language detection. Accepts a string with the code to
      highlight. Returns an object with the following properties:

      - language (detected language)
      - relevance (int)
      - value (an HTML string with highlighting markup)
      - second_best (object with the same structure for second-best heuristically
        detected language, may be absent)

        @param {string} code
        @param {Array<string>} [languageSubset]
        @returns {AutoHighlightResult}
      */
      function highlightAuto(code, languageSubset) {
        languageSubset = languageSubset || options.languages || Object.keys(languages);
        const plaintext = justTextHighlightResult(code);

        const results = languageSubset.filter(getLanguage).filter(autoDetection).map(name =>
          _highlight(name, code, false)
        );
        results.unshift(plaintext); // plaintext is always an option

        const sorted = results.sort((a, b) => {
          // sort base on relevance
          if (a.relevance !== b.relevance) return b.relevance - a.relevance;

          // always award the tie to the base language
          // ie if C++ and Arduino are tied, it's more likely to be C++
          if (a.language && b.language) {
            if (getLanguage(a.language).supersetOf === b.language) {
              return 1;
            } else if (getLanguage(b.language).supersetOf === a.language) {
              return -1;
            }
          }

          // otherwise say they are equal, which has the effect of sorting on
          // relevance while preserving the original ordering - which is how ties
          // have historically been settled, ie the language that comes first always
          // wins in the case of a tie
          return 0;
        });

        const [best, secondBest] = sorted;

        /** @type {AutoHighlightResult} */
        const result = best;
        result.second_best = secondBest;

        return result;
      }

      /**
      Post-processing of the highlighted markup:

      - replace TABs with something more useful
      - replace real line-breaks with '<br>' for non-pre containers

        @param {string} html
        @returns {string}
      */
      function fixMarkup(html) {
        if (!(options.tabReplace || options.useBR)) {
          return html;
        }

        return html.replace(fixMarkupRe, match => {
          if (match === '\n') {
            return options.useBR ? '<br>' : match;
          } else if (options.tabReplace) {
            return match.replace(/\t/g, options.tabReplace);
          }
          return match;
        });
      }

      /**
       * Builds new class name for block given the language name
       *
       * @param {HTMLElement} element
       * @param {string} [currentLang]
       * @param {string} [resultLang]
       */
      function updateClassName(element, currentLang, resultLang) {
        const language = currentLang ? aliases[currentLang] : resultLang;

        element.classList.add("hljs");
        if (language) element.classList.add(language);
      }

      /** @type {HLJSPlugin} */
      const brPlugin = {
        "before:highlightElement": ({ el }) => {
          if (options.useBR) {
            el.innerHTML = el.innerHTML.replace(/\n/g, '').replace(/<br[ /]*>/g, '\n');
          }
        },
        "after:highlightElement": ({ result }) => {
          if (options.useBR) {
            result.value = result.value.replace(/\n/g, "<br>");
          }
        }
      };

      const TAB_REPLACE_RE = /^(<[^>]+>|\t)+/gm;
      /** @type {HLJSPlugin} */
      const tabReplacePlugin = {
        "after:highlightElement": ({ result }) => {
          if (options.tabReplace) {
            result.value = result.value.replace(TAB_REPLACE_RE, (m) =>
              m.replace(/\t/g, options.tabReplace)
            );
          }
        }
      };

      /**
       * Applies highlighting to a DOM node containing code. Accepts a DOM node and
       * two optional parameters for fixMarkup.
       *
       * @param {HighlightedHTMLElement} element - the HTML element to highlight
      */
      function highlightElement(element) {
        /** @type HTMLElement */
        let node = null;
        const language = blockLanguage(element);

        if (shouldNotHighlight(language)) return;

        // support for v10 API
        fire("before:highlightElement",
          { el: element, language: language });

        node = element;
        const text = node.textContent;
        const result = language ? highlight(text, { language, ignoreIllegals: true }) : highlightAuto(text);

        // support for v10 API
        fire("after:highlightElement", { el: element, result, text });

        element.innerHTML = result.value;
        updateClassName(element, language, result.language);
        element.result = {
          language: result.language,
          // TODO: remove with version 11.0
          re: result.relevance,
          relavance: result.relevance
        };
        if (result.second_best) {
          element.second_best = {
            language: result.second_best.language,
            // TODO: remove with version 11.0
            re: result.second_best.relevance,
            relavance: result.second_best.relevance
          };
        }
      }

      /**
       * Updates highlight.js global options with the passed options
       *
       * @param {Partial<HLJSOptions>} userOptions
       */
      function configure(userOptions) {
        if (userOptions.useBR) {
          deprecated("10.3.0", "'useBR' will be removed entirely in v11.0");
          deprecated("10.3.0", "Please see https://github.com/highlightjs/highlight.js/issues/2559");
        }
        options = inherit$1(options, userOptions);
      }

      /**
       * Highlights to all <pre><code> blocks on a page
       *
       * @type {Function & {called?: boolean}}
       */
      // TODO: remove v12, deprecated
      const initHighlighting = () => {
        if (initHighlighting.called) return;
        initHighlighting.called = true;

        deprecated("10.6.0", "initHighlighting() is deprecated.  Use highlightAll() instead.");

        const blocks = document.querySelectorAll('pre code');
        blocks.forEach(highlightElement);
      };

      // Higlights all when DOMContentLoaded fires
      // TODO: remove v12, deprecated
      function initHighlightingOnLoad() {
        deprecated("10.6.0", "initHighlightingOnLoad() is deprecated.  Use highlightAll() instead.");
        wantsHighlight = true;
      }

      let wantsHighlight = false;

      /**
       * auto-highlights all pre>code elements on the page
       */
      function highlightAll() {
        // if we are called too early in the loading process
        if (document.readyState === "loading") {
          wantsHighlight = true;
          return;
        }

        const blocks = document.querySelectorAll('pre code');
        blocks.forEach(highlightElement);
      }

      function boot() {
        // if a highlight was requested before DOM was loaded, do now
        if (wantsHighlight) highlightAll();
      }

      // make sure we are in the browser environment
      if (typeof window !== 'undefined' && window.addEventListener) {
        window.addEventListener('DOMContentLoaded', boot, false);
      }

      /**
       * Register a language grammar module
       *
       * @param {string} languageName
       * @param {LanguageFn} languageDefinition
       */
      function registerLanguage(languageName, languageDefinition) {
        let lang = null;
        try {
          lang = languageDefinition(hljs);
        } catch (error$1) {
          error("Language definition for '{}' could not be registered.".replace("{}", languageName));
          // hard or soft error
          if (!SAFE_MODE) { throw error$1; } else { error(error$1); }
          // languages that have serious errors are replaced with essentially a
          // "plaintext" stand-in so that the code blocks will still get normal
          // css classes applied to them - and one bad language won't break the
          // entire highlighter
          lang = PLAINTEXT_LANGUAGE;
        }
        // give it a temporary name if it doesn't have one in the meta-data
        if (!lang.name) lang.name = languageName;
        languages[languageName] = lang;
        lang.rawDefinition = languageDefinition.bind(null, hljs);

        if (lang.aliases) {
          registerAliases(lang.aliases, { languageName });
        }
      }

      /**
       * Remove a language grammar module
       *
       * @param {string} languageName
       */
      function unregisterLanguage(languageName) {
        delete languages[languageName];
        for (const alias of Object.keys(aliases)) {
          if (aliases[alias] === languageName) {
            delete aliases[alias];
          }
        }
      }

      /**
       * @returns {string[]} List of language internal names
       */
      function listLanguages() {
        return Object.keys(languages);
      }

      /**
        intended usage: When one language truly requires another

        Unlike `getLanguage`, this will throw when the requested language
        is not available.

        @param {string} name - name of the language to fetch/require
        @returns {Language | never}
      */
      function requireLanguage(name) {
        deprecated("10.4.0", "requireLanguage will be removed entirely in v11.");
        deprecated("10.4.0", "Please see https://github.com/highlightjs/highlight.js/pull/2844");

        const lang = getLanguage(name);
        if (lang) { return lang; }

        const err = new Error('The \'{}\' language is required, but not loaded.'.replace('{}', name));
        throw err;
      }

      /**
       * @param {string} name - name of the language to retrieve
       * @returns {Language | undefined}
       */
      function getLanguage(name) {
        name = (name || '').toLowerCase();
        return languages[name] || languages[aliases[name]];
      }

      /**
       *
       * @param {string|string[]} aliasList - single alias or list of aliases
       * @param {{languageName: string}} opts
       */
      function registerAliases(aliasList, { languageName }) {
        if (typeof aliasList === 'string') {
          aliasList = [aliasList];
        }
        aliasList.forEach(alias => { aliases[alias.toLowerCase()] = languageName; });
      }

      /**
       * Determines if a given language has auto-detection enabled
       * @param {string} name - name of the language
       */
      function autoDetection(name) {
        const lang = getLanguage(name);
        return lang && !lang.disableAutodetect;
      }

      /**
       * Upgrades the old highlightBlock plugins to the new
       * highlightElement API
       * @param {HLJSPlugin} plugin
       */
      function upgradePluginAPI(plugin) {
        // TODO: remove with v12
        if (plugin["before:highlightBlock"] && !plugin["before:highlightElement"]) {
          plugin["before:highlightElement"] = (data) => {
            plugin["before:highlightBlock"](
              Object.assign({ block: data.el }, data)
            );
          };
        }
        if (plugin["after:highlightBlock"] && !plugin["after:highlightElement"]) {
          plugin["after:highlightElement"] = (data) => {
            plugin["after:highlightBlock"](
              Object.assign({ block: data.el }, data)
            );
          };
        }
      }

      /**
       * @param {HLJSPlugin} plugin
       */
      function addPlugin(plugin) {
        upgradePluginAPI(plugin);
        plugins.push(plugin);
      }

      /**
       *
       * @param {PluginEvent} event
       * @param {any} args
       */
      function fire(event, args) {
        const cb = event;
        plugins.forEach(function(plugin) {
          if (plugin[cb]) {
            plugin[cb](args);
          }
        });
      }

      /**
      Note: fixMarkup is deprecated and will be removed entirely in v11

      @param {string} arg
      @returns {string}
      */
      function deprecateFixMarkup(arg) {
        deprecated("10.2.0", "fixMarkup will be removed entirely in v11.0");
        deprecated("10.2.0", "Please see https://github.com/highlightjs/highlight.js/issues/2534");

        return fixMarkup(arg);
      }

      /**
       *
       * @param {HighlightedHTMLElement} el
       */
      function deprecateHighlightBlock(el) {
        deprecated("10.7.0", "highlightBlock will be removed entirely in v12.0");
        deprecated("10.7.0", "Please use highlightElement now.");

        return highlightElement(el);
      }

      /* Interface definition */
      Object.assign(hljs, {
        highlight,
        highlightAuto,
        highlightAll,
        fixMarkup: deprecateFixMarkup,
        highlightElement,
        // TODO: Remove with v12 API
        highlightBlock: deprecateHighlightBlock,
        configure,
        initHighlighting,
        initHighlightingOnLoad,
        registerLanguage,
        unregisterLanguage,
        listLanguages,
        getLanguage,
        registerAliases,
        requireLanguage,
        autoDetection,
        inherit: inherit$1,
        addPlugin,
        // plugins for frameworks
        vuePlugin: BuildVuePlugin(hljs).VuePlugin
      });

      hljs.debugMode = function() { SAFE_MODE = false; };
      hljs.safeMode = function() { SAFE_MODE = true; };
      hljs.versionString = version;

      for (const key in MODES$1) {
        // @ts-ignore
        if (typeof MODES$1[key] === "object") {
          // @ts-ignore
          deepFreezeEs6(MODES$1[key]);
        }
      }

      // merge all the modes/regexs into our main object
      Object.assign(hljs, MODES$1);

      // built-in plugins, likely to be moved out of core in the future
      hljs.addPlugin(brPlugin); // slated to be removed in v11
      hljs.addPlugin(mergeHTMLPlugin);
      hljs.addPlugin(tabReplacePlugin);
      return hljs;
    };

    // export an "instance" of the highlighter
    var highlight = HLJS({});

    var core = highlight;

    // Current version.
    var VERSION = '1.13.1';

    // Establish the root object, `window` (`self`) in the browser, `global`
    // on the server, or `this` in some virtual machines. We use `self`
    // instead of `window` for `WebWorker` support.
    var root = typeof self == 'object' && self.self === self && self ||
              typeof global == 'object' && global.global === global && global ||
              Function('return this')() ||
              {};

    // Save bytes in the minified (but not gzipped) version:
    var ArrayProto = Array.prototype, ObjProto = Object.prototype;
    var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;

    // Create quick reference variables for speed access to core prototypes.
    var push = ArrayProto.push,
        slice = ArrayProto.slice,
        toString = ObjProto.toString,
        hasOwnProperty = ObjProto.hasOwnProperty;

    // Modern feature detection.
    var supportsArrayBuffer = typeof ArrayBuffer !== 'undefined',
        supportsDataView = typeof DataView !== 'undefined';

    // All **ECMAScript 5+** native function implementations that we hope to use
    // are declared here.
    var nativeIsArray = Array.isArray,
        nativeKeys = Object.keys,
        nativeCreate = Object.create,
        nativeIsView = supportsArrayBuffer && ArrayBuffer.isView;

    // Create references to these builtin functions because we override them.
    var _isNaN = isNaN,
        _isFinite = isFinite;

    // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
    var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
    var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

    // The largest integer that can be represented exactly.
    var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;

    // Some functions take a variable number of arguments, or a few expected
    // arguments at the beginning and then a variable number of values to operate
    // on. This helper accumulates all remaining arguments past the function’s
    // argument length (or an explicit `startIndex`), into an array that becomes
    // the last argument. Similar to ES6’s "rest parameter".
    function restArguments(func, startIndex) {
      startIndex = startIndex == null ? func.length - 1 : +startIndex;
      return function() {
        var length = Math.max(arguments.length - startIndex, 0),
            rest = Array(length),
            index = 0;
        for (; index < length; index++) {
          rest[index] = arguments[index + startIndex];
        }
        switch (startIndex) {
          case 0: return func.call(this, rest);
          case 1: return func.call(this, arguments[0], rest);
          case 2: return func.call(this, arguments[0], arguments[1], rest);
        }
        var args = Array(startIndex + 1);
        for (index = 0; index < startIndex; index++) {
          args[index] = arguments[index];
        }
        args[startIndex] = rest;
        return func.apply(this, args);
      };
    }

    // Is a given variable an object?
    function isObject(obj) {
      var type = typeof obj;
      return type === 'function' || type === 'object' && !!obj;
    }

    // Is a given value equal to null?
    function isNull(obj) {
      return obj === null;
    }

    // Is a given variable undefined?
    function isUndefined(obj) {
      return obj === void 0;
    }

    // Is a given value a boolean?
    function isBoolean(obj) {
      return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
    }

    // Is a given value a DOM element?
    function isElement(obj) {
      return !!(obj && obj.nodeType === 1);
    }

    // Internal function for creating a `toString`-based type tester.
    function tagTester(name) {
      var tag = '[object ' + name + ']';
      return function(obj) {
        return toString.call(obj) === tag;
      };
    }

    var isString = tagTester('String');

    var isNumber = tagTester('Number');

    var isDate = tagTester('Date');

    var isRegExp = tagTester('RegExp');

    var isError = tagTester('Error');

    var isSymbol = tagTester('Symbol');

    var isArrayBuffer = tagTester('ArrayBuffer');

    var isFunction = tagTester('Function');

    // Optimize `isFunction` if appropriate. Work around some `typeof` bugs in old
    // v8, IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).
    var nodelist = root.document && root.document.childNodes;
    if (typeof /./ != 'function' && typeof Int8Array != 'object' && typeof nodelist != 'function') {
      isFunction = function(obj) {
        return typeof obj == 'function' || false;
      };
    }

    var isFunction$1 = isFunction;

    var hasObjectTag = tagTester('Object');

    // In IE 10 - Edge 13, `DataView` has string tag `'[object Object]'`.
    // In IE 11, the most common among them, this problem also applies to
    // `Map`, `WeakMap` and `Set`.
    var hasStringTagBug = (
          supportsDataView && hasObjectTag(new DataView(new ArrayBuffer(8)))
        ),
        isIE11 = (typeof Map !== 'undefined' && hasObjectTag(new Map));

    var isDataView = tagTester('DataView');

    // In IE 10 - Edge 13, we need a different heuristic
    // to determine whether an object is a `DataView`.
    function ie10IsDataView(obj) {
      return obj != null && isFunction$1(obj.getInt8) && isArrayBuffer(obj.buffer);
    }

    var isDataView$1 = (hasStringTagBug ? ie10IsDataView : isDataView);

    // Is a given value an array?
    // Delegates to ECMA5's native `Array.isArray`.
    var isArray = nativeIsArray || tagTester('Array');

    // Internal function to check whether `key` is an own property name of `obj`.
    function has$1(obj, key) {
      return obj != null && hasOwnProperty.call(obj, key);
    }

    var isArguments = tagTester('Arguments');

    // Define a fallback version of the method in browsers (ahem, IE < 9), where
    // there isn't any inspectable "Arguments" type.
    (function() {
      if (!isArguments(arguments)) {
        isArguments = function(obj) {
          return has$1(obj, 'callee');
        };
      }
    }());

    var isArguments$1 = isArguments;

    // Is a given object a finite number?
    function isFinite$1(obj) {
      return !isSymbol(obj) && _isFinite(obj) && !isNaN(parseFloat(obj));
    }

    // Is the given value `NaN`?
    function isNaN$1(obj) {
      return isNumber(obj) && _isNaN(obj);
    }

    // Predicate-generating function. Often useful outside of Underscore.
    function constant(value) {
      return function() {
        return value;
      };
    }

    // Common internal logic for `isArrayLike` and `isBufferLike`.
    function createSizePropertyCheck(getSizeProperty) {
      return function(collection) {
        var sizeProperty = getSizeProperty(collection);
        return typeof sizeProperty == 'number' && sizeProperty >= 0 && sizeProperty <= MAX_ARRAY_INDEX;
      }
    }

    // Internal helper to generate a function to obtain property `key` from `obj`.
    function shallowProperty(key) {
      return function(obj) {
        return obj == null ? void 0 : obj[key];
      };
    }

    // Internal helper to obtain the `byteLength` property of an object.
    var getByteLength = shallowProperty('byteLength');

    // Internal helper to determine whether we should spend extensive checks against
    // `ArrayBuffer` et al.
    var isBufferLike = createSizePropertyCheck(getByteLength);

    // Is a given value a typed array?
    var typedArrayPattern = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
    function isTypedArray(obj) {
      // `ArrayBuffer.isView` is the most future-proof, so use it when available.
      // Otherwise, fall back on the above regular expression.
      return nativeIsView ? (nativeIsView(obj) && !isDataView$1(obj)) :
                    isBufferLike(obj) && typedArrayPattern.test(toString.call(obj));
    }

    var isTypedArray$1 = supportsArrayBuffer ? isTypedArray : constant(false);

    // Internal helper to obtain the `length` property of an object.
    var getLength = shallowProperty('length');

    // Internal helper to create a simple lookup structure.
    // `collectNonEnumProps` used to depend on `_.contains`, but this led to
    // circular imports. `emulatedSet` is a one-off solution that only works for
    // arrays of strings.
    function emulatedSet(keys) {
      var hash = {};
      for (var l = keys.length, i = 0; i < l; ++i) hash[keys[i]] = true;
      return {
        contains: function(key) { return hash[key]; },
        push: function(key) {
          hash[key] = true;
          return keys.push(key);
        }
      };
    }

    // Internal helper. Checks `keys` for the presence of keys in IE < 9 that won't
    // be iterated by `for key in ...` and thus missed. Extends `keys` in place if
    // needed.
    function collectNonEnumProps(obj, keys) {
      keys = emulatedSet(keys);
      var nonEnumIdx = nonEnumerableProps.length;
      var constructor = obj.constructor;
      var proto = isFunction$1(constructor) && constructor.prototype || ObjProto;

      // Constructor is a special case.
      var prop = 'constructor';
      if (has$1(obj, prop) && !keys.contains(prop)) keys.push(prop);

      while (nonEnumIdx--) {
        prop = nonEnumerableProps[nonEnumIdx];
        if (prop in obj && obj[prop] !== proto[prop] && !keys.contains(prop)) {
          keys.push(prop);
        }
      }
    }

    // Retrieve the names of an object's own properties.
    // Delegates to **ECMAScript 5**'s native `Object.keys`.
    function keys(obj) {
      if (!isObject(obj)) return [];
      if (nativeKeys) return nativeKeys(obj);
      var keys = [];
      for (var key in obj) if (has$1(obj, key)) keys.push(key);
      // Ahem, IE < 9.
      if (hasEnumBug) collectNonEnumProps(obj, keys);
      return keys;
    }

    // Is a given array, string, or object empty?
    // An "empty" object has no enumerable own-properties.
    function isEmpty(obj) {
      if (obj == null) return true;
      // Skip the more expensive `toString`-based type checks if `obj` has no
      // `.length`.
      var length = getLength(obj);
      if (typeof length == 'number' && (
        isArray(obj) || isString(obj) || isArguments$1(obj)
      )) return length === 0;
      return getLength(keys(obj)) === 0;
    }

    // Returns whether an object has a given set of `key:value` pairs.
    function isMatch(object, attrs) {
      var _keys = keys(attrs), length = _keys.length;
      if (object == null) return !length;
      var obj = Object(object);
      for (var i = 0; i < length; i++) {
        var key = _keys[i];
        if (attrs[key] !== obj[key] || !(key in obj)) return false;
      }
      return true;
    }

    // If Underscore is called as a function, it returns a wrapped object that can
    // be used OO-style. This wrapper holds altered versions of all functions added
    // through `_.mixin`. Wrapped objects may be chained.
    function _$1(obj) {
      if (obj instanceof _$1) return obj;
      if (!(this instanceof _$1)) return new _$1(obj);
      this._wrapped = obj;
    }

    _$1.VERSION = VERSION;

    // Extracts the result from a wrapped and chained object.
    _$1.prototype.value = function() {
      return this._wrapped;
    };

    // Provide unwrapping proxies for some methods used in engine operations
    // such as arithmetic and JSON stringification.
    _$1.prototype.valueOf = _$1.prototype.toJSON = _$1.prototype.value;

    _$1.prototype.toString = function() {
      return String(this._wrapped);
    };

    // Internal function to wrap or shallow-copy an ArrayBuffer,
    // typed array or DataView to a new view, reusing the buffer.
    function toBufferView(bufferSource) {
      return new Uint8Array(
        bufferSource.buffer || bufferSource,
        bufferSource.byteOffset || 0,
        getByteLength(bufferSource)
      );
    }

    // We use this string twice, so give it a name for minification.
    var tagDataView = '[object DataView]';

    // Internal recursive comparison function for `_.isEqual`.
    function eq(a, b, aStack, bStack) {
      // Identical objects are equal. `0 === -0`, but they aren't identical.
      // See the [Harmony `egal` proposal](https://wiki.ecmascript.org/doku.php?id=harmony:egal).
      if (a === b) return a !== 0 || 1 / a === 1 / b;
      // `null` or `undefined` only equal to itself (strict comparison).
      if (a == null || b == null) return false;
      // `NaN`s are equivalent, but non-reflexive.
      if (a !== a) return b !== b;
      // Exhaust primitive checks
      var type = typeof a;
      if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;
      return deepEq(a, b, aStack, bStack);
    }

    // Internal recursive comparison function for `_.isEqual`.
    function deepEq(a, b, aStack, bStack) {
      // Unwrap any wrapped objects.
      if (a instanceof _$1) a = a._wrapped;
      if (b instanceof _$1) b = b._wrapped;
      // Compare `[[Class]]` names.
      var className = toString.call(a);
      if (className !== toString.call(b)) return false;
      // Work around a bug in IE 10 - Edge 13.
      if (hasStringTagBug && className == '[object Object]' && isDataView$1(a)) {
        if (!isDataView$1(b)) return false;
        className = tagDataView;
      }
      switch (className) {
        // These types are compared by value.
        case '[object RegExp]':
          // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
        case '[object String]':
          // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
          // equivalent to `new String("5")`.
          return '' + a === '' + b;
        case '[object Number]':
          // `NaN`s are equivalent, but non-reflexive.
          // Object(NaN) is equivalent to NaN.
          if (+a !== +a) return +b !== +b;
          // An `egal` comparison is performed for other numeric values.
          return +a === 0 ? 1 / +a === 1 / b : +a === +b;
        case '[object Date]':
        case '[object Boolean]':
          // Coerce dates and booleans to numeric primitive values. Dates are compared by their
          // millisecond representations. Note that invalid dates with millisecond representations
          // of `NaN` are not equivalent.
          return +a === +b;
        case '[object Symbol]':
          return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
        case '[object ArrayBuffer]':
        case tagDataView:
          // Coerce to typed array so we can fall through.
          return deepEq(toBufferView(a), toBufferView(b), aStack, bStack);
      }

      var areArrays = className === '[object Array]';
      if (!areArrays && isTypedArray$1(a)) {
          var byteLength = getByteLength(a);
          if (byteLength !== getByteLength(b)) return false;
          if (a.buffer === b.buffer && a.byteOffset === b.byteOffset) return true;
          areArrays = true;
      }
      if (!areArrays) {
        if (typeof a != 'object' || typeof b != 'object') return false;

        // Objects with different constructors are not equivalent, but `Object`s or `Array`s
        // from different frames are.
        var aCtor = a.constructor, bCtor = b.constructor;
        if (aCtor !== bCtor && !(isFunction$1(aCtor) && aCtor instanceof aCtor &&
                                 isFunction$1(bCtor) && bCtor instanceof bCtor)
                            && ('constructor' in a && 'constructor' in b)) {
          return false;
        }
      }
      // Assume equality for cyclic structures. The algorithm for detecting cyclic
      // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

      // Initializing stack of traversed objects.
      // It's done here since we only need them for objects and arrays comparison.
      aStack = aStack || [];
      bStack = bStack || [];
      var length = aStack.length;
      while (length--) {
        // Linear search. Performance is inversely proportional to the number of
        // unique nested structures.
        if (aStack[length] === a) return bStack[length] === b;
      }

      // Add the first object to the stack of traversed objects.
      aStack.push(a);
      bStack.push(b);

      // Recursively compare objects and arrays.
      if (areArrays) {
        // Compare array lengths to determine if a deep comparison is necessary.
        length = a.length;
        if (length !== b.length) return false;
        // Deep compare the contents, ignoring non-numeric properties.
        while (length--) {
          if (!eq(a[length], b[length], aStack, bStack)) return false;
        }
      } else {
        // Deep compare objects.
        var _keys = keys(a), key;
        length = _keys.length;
        // Ensure that both objects contain the same number of properties before comparing deep equality.
        if (keys(b).length !== length) return false;
        while (length--) {
          // Deep compare each member
          key = _keys[length];
          if (!(has$1(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
        }
      }
      // Remove the first object from the stack of traversed objects.
      aStack.pop();
      bStack.pop();
      return true;
    }

    // Perform a deep comparison to check if two objects are equal.
    function isEqual(a, b) {
      return eq(a, b);
    }

    // Retrieve all the enumerable property names of an object.
    function allKeys(obj) {
      if (!isObject(obj)) return [];
      var keys = [];
      for (var key in obj) keys.push(key);
      // Ahem, IE < 9.
      if (hasEnumBug) collectNonEnumProps(obj, keys);
      return keys;
    }

    // Since the regular `Object.prototype.toString` type tests don't work for
    // some types in IE 11, we use a fingerprinting heuristic instead, based
    // on the methods. It's not great, but it's the best we got.
    // The fingerprint method lists are defined below.
    function ie11fingerprint(methods) {
      var length = getLength(methods);
      return function(obj) {
        if (obj == null) return false;
        // `Map`, `WeakMap` and `Set` have no enumerable keys.
        var keys = allKeys(obj);
        if (getLength(keys)) return false;
        for (var i = 0; i < length; i++) {
          if (!isFunction$1(obj[methods[i]])) return false;
        }
        // If we are testing against `WeakMap`, we need to ensure that
        // `obj` doesn't have a `forEach` method in order to distinguish
        // it from a regular `Map`.
        return methods !== weakMapMethods || !isFunction$1(obj[forEachName]);
      };
    }

    // In the interest of compact minification, we write
    // each string in the fingerprints only once.
    var forEachName = 'forEach',
        hasName = 'has',
        commonInit = ['clear', 'delete'],
        mapTail = ['get', hasName, 'set'];

    // `Map`, `WeakMap` and `Set` each have slightly different
    // combinations of the above sublists.
    var mapMethods = commonInit.concat(forEachName, mapTail),
        weakMapMethods = commonInit.concat(mapTail),
        setMethods = ['add'].concat(commonInit, forEachName, hasName);

    var isMap = isIE11 ? ie11fingerprint(mapMethods) : tagTester('Map');

    var isWeakMap = isIE11 ? ie11fingerprint(weakMapMethods) : tagTester('WeakMap');

    var isSet = isIE11 ? ie11fingerprint(setMethods) : tagTester('Set');

    var isWeakSet = tagTester('WeakSet');

    // Retrieve the values of an object's properties.
    function values(obj) {
      var _keys = keys(obj);
      var length = _keys.length;
      var values = Array(length);
      for (var i = 0; i < length; i++) {
        values[i] = obj[_keys[i]];
      }
      return values;
    }

    // Convert an object into a list of `[key, value]` pairs.
    // The opposite of `_.object` with one argument.
    function pairs(obj) {
      var _keys = keys(obj);
      var length = _keys.length;
      var pairs = Array(length);
      for (var i = 0; i < length; i++) {
        pairs[i] = [_keys[i], obj[_keys[i]]];
      }
      return pairs;
    }

    // Invert the keys and values of an object. The values must be serializable.
    function invert(obj) {
      var result = {};
      var _keys = keys(obj);
      for (var i = 0, length = _keys.length; i < length; i++) {
        result[obj[_keys[i]]] = _keys[i];
      }
      return result;
    }

    // Return a sorted list of the function names available on the object.
    function functions(obj) {
      var names = [];
      for (var key in obj) {
        if (isFunction$1(obj[key])) names.push(key);
      }
      return names.sort();
    }

    // An internal function for creating assigner functions.
    function createAssigner(keysFunc, defaults) {
      return function(obj) {
        var length = arguments.length;
        if (defaults) obj = Object(obj);
        if (length < 2 || obj == null) return obj;
        for (var index = 1; index < length; index++) {
          var source = arguments[index],
              keys = keysFunc(source),
              l = keys.length;
          for (var i = 0; i < l; i++) {
            var key = keys[i];
            if (!defaults || obj[key] === void 0) obj[key] = source[key];
          }
        }
        return obj;
      };
    }

    // Extend a given object with all the properties in passed-in object(s).
    var extend = createAssigner(allKeys);

    // Assigns a given object with all the own properties in the passed-in
    // object(s).
    // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
    var extendOwn = createAssigner(keys);

    // Fill in a given object with default properties.
    var defaults = createAssigner(allKeys, true);

    // Create a naked function reference for surrogate-prototype-swapping.
    function ctor() {
      return function(){};
    }

    // An internal function for creating a new object that inherits from another.
    function baseCreate(prototype) {
      if (!isObject(prototype)) return {};
      if (nativeCreate) return nativeCreate(prototype);
      var Ctor = ctor();
      Ctor.prototype = prototype;
      var result = new Ctor;
      Ctor.prototype = null;
      return result;
    }

    // Creates an object that inherits from the given prototype object.
    // If additional properties are provided then they will be added to the
    // created object.
    function create(prototype, props) {
      var result = baseCreate(prototype);
      if (props) extendOwn(result, props);
      return result;
    }

    // Create a (shallow-cloned) duplicate of an object.
    function clone(obj) {
      if (!isObject(obj)) return obj;
      return isArray(obj) ? obj.slice() : extend({}, obj);
    }

    // Invokes `interceptor` with the `obj` and then returns `obj`.
    // The primary purpose of this method is to "tap into" a method chain, in
    // order to perform operations on intermediate results within the chain.
    function tap(obj, interceptor) {
      interceptor(obj);
      return obj;
    }

    // Normalize a (deep) property `path` to array.
    // Like `_.iteratee`, this function can be customized.
    function toPath$1(path) {
      return isArray(path) ? path : [path];
    }
    _$1.toPath = toPath$1;

    // Internal wrapper for `_.toPath` to enable minification.
    // Similar to `cb` for `_.iteratee`.
    function toPath(path) {
      return _$1.toPath(path);
    }

    // Internal function to obtain a nested property in `obj` along `path`.
    function deepGet(obj, path) {
      var length = path.length;
      for (var i = 0; i < length; i++) {
        if (obj == null) return void 0;
        obj = obj[path[i]];
      }
      return length ? obj : void 0;
    }

    // Get the value of the (deep) property on `path` from `object`.
    // If any property in `path` does not exist or if the value is
    // `undefined`, return `defaultValue` instead.
    // The `path` is normalized through `_.toPath`.
    function get(object, path, defaultValue) {
      var value = deepGet(object, toPath(path));
      return isUndefined(value) ? defaultValue : value;
    }

    // Shortcut function for checking if an object has a given property directly on
    // itself (in other words, not on a prototype). Unlike the internal `has`
    // function, this public version can also traverse nested properties.
    function has(obj, path) {
      path = toPath(path);
      var length = path.length;
      for (var i = 0; i < length; i++) {
        var key = path[i];
        if (!has$1(obj, key)) return false;
        obj = obj[key];
      }
      return !!length;
    }

    // Keep the identity function around for default iteratees.
    function identity(value) {
      return value;
    }

    // Returns a predicate for checking whether an object has a given set of
    // `key:value` pairs.
    function matcher(attrs) {
      attrs = extendOwn({}, attrs);
      return function(obj) {
        return isMatch(obj, attrs);
      };
    }

    // Creates a function that, when passed an object, will traverse that object’s
    // properties down the given `path`, specified as an array of keys or indices.
    function property(path) {
      path = toPath(path);
      return function(obj) {
        return deepGet(obj, path);
      };
    }

    // Internal function that returns an efficient (for current engines) version
    // of the passed-in callback, to be repeatedly applied in other Underscore
    // functions.
    function optimizeCb(func, context, argCount) {
      if (context === void 0) return func;
      switch (argCount == null ? 3 : argCount) {
        case 1: return function(value) {
          return func.call(context, value);
        };
        // The 2-argument case is omitted because we’re not using it.
        case 3: return function(value, index, collection) {
          return func.call(context, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(context, accumulator, value, index, collection);
        };
      }
      return function() {
        return func.apply(context, arguments);
      };
    }

    // An internal function to generate callbacks that can be applied to each
    // element in a collection, returning the desired result — either `_.identity`,
    // an arbitrary callback, a property matcher, or a property accessor.
    function baseIteratee(value, context, argCount) {
      if (value == null) return identity;
      if (isFunction$1(value)) return optimizeCb(value, context, argCount);
      if (isObject(value) && !isArray(value)) return matcher(value);
      return property(value);
    }

    // External wrapper for our callback generator. Users may customize
    // `_.iteratee` if they want additional predicate/iteratee shorthand styles.
    // This abstraction hides the internal-only `argCount` argument.
    function iteratee(value, context) {
      return baseIteratee(value, context, Infinity);
    }
    _$1.iteratee = iteratee;

    // The function we call internally to generate a callback. It invokes
    // `_.iteratee` if overridden, otherwise `baseIteratee`.
    function cb(value, context, argCount) {
      if (_$1.iteratee !== iteratee) return _$1.iteratee(value, context);
      return baseIteratee(value, context, argCount);
    }

    // Returns the results of applying the `iteratee` to each element of `obj`.
    // In contrast to `_.map` it returns an object.
    function mapObject(obj, iteratee, context) {
      iteratee = cb(iteratee, context);
      var _keys = keys(obj),
          length = _keys.length,
          results = {};
      for (var index = 0; index < length; index++) {
        var currentKey = _keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
    }

    // Predicate-generating function. Often useful outside of Underscore.
    function noop(){}

    // Generates a function for a given object that returns a given property.
    function propertyOf(obj) {
      if (obj == null) return noop;
      return function(path) {
        return get(obj, path);
      };
    }

    // Run a function **n** times.
    function times(n, iteratee, context) {
      var accum = Array(Math.max(0, n));
      iteratee = optimizeCb(iteratee, context, 1);
      for (var i = 0; i < n; i++) accum[i] = iteratee(i);
      return accum;
    }

    // Return a random integer between `min` and `max` (inclusive).
    function random(min, max) {
      if (max == null) {
        max = min;
        min = 0;
      }
      return min + Math.floor(Math.random() * (max - min + 1));
    }

    // A (possibly faster) way to get the current timestamp as an integer.
    var now = Date.now || function() {
      return new Date().getTime();
    };

    // Internal helper to generate functions for escaping and unescaping strings
    // to/from HTML interpolation.
    function createEscaper(map) {
      var escaper = function(match) {
        return map[match];
      };
      // Regexes for identifying a key that needs to be escaped.
      var source = '(?:' + keys(map).join('|') + ')';
      var testRegexp = RegExp(source);
      var replaceRegexp = RegExp(source, 'g');
      return function(string) {
        string = string == null ? '' : '' + string;
        return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
      };
    }

    // Internal list of HTML entities for escaping.
    var escapeMap = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;',
      '`': '&#x60;'
    };

    // Function for escaping strings to HTML interpolation.
    var _escape = createEscaper(escapeMap);

    // Internal list of HTML entities for unescaping.
    var unescapeMap = invert(escapeMap);

    // Function for unescaping strings from HTML interpolation.
    var _unescape = createEscaper(unescapeMap);

    // By default, Underscore uses ERB-style template delimiters. Change the
    // following template settings to use alternative delimiters.
    var templateSettings = _$1.templateSettings = {
      evaluate: /<%([\s\S]+?)%>/g,
      interpolate: /<%=([\s\S]+?)%>/g,
      escape: /<%-([\s\S]+?)%>/g
    };

    // When customizing `_.templateSettings`, if you don't want to define an
    // interpolation, evaluation or escaping regex, we need one that is
    // guaranteed not to match.
    var noMatch = /(.)^/;

    // Certain characters need to be escaped so that they can be put into a
    // string literal.
    var escapes = {
      "'": "'",
      '\\': '\\',
      '\r': 'r',
      '\n': 'n',
      '\u2028': 'u2028',
      '\u2029': 'u2029'
    };

    var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;

    function escapeChar(match) {
      return '\\' + escapes[match];
    }

    // In order to prevent third-party code injection through
    // `_.templateSettings.variable`, we test it against the following regular
    // expression. It is intentionally a bit more liberal than just matching valid
    // identifiers, but still prevents possible loopholes through defaults or
    // destructuring assignment.
    var bareIdentifier = /^\s*(\w|\$)+\s*$/;

    // JavaScript micro-templating, similar to John Resig's implementation.
    // Underscore templating handles arbitrary delimiters, preserves whitespace,
    // and correctly escapes quotes within interpolated code.
    // NB: `oldSettings` only exists for backwards compatibility.
    function template(text, settings, oldSettings) {
      if (!settings && oldSettings) settings = oldSettings;
      settings = defaults({}, settings, _$1.templateSettings);

      // Combine delimiters into one regular expression via alternation.
      var matcher = RegExp([
        (settings.escape || noMatch).source,
        (settings.interpolate || noMatch).source,
        (settings.evaluate || noMatch).source
      ].join('|') + '|$', 'g');

      // Compile the template source, escaping string literals appropriately.
      var index = 0;
      var source = "__p+='";
      text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
        source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
        index = offset + match.length;

        if (escape) {
          source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
        } else if (interpolate) {
          source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
        } else if (evaluate) {
          source += "';\n" + evaluate + "\n__p+='";
        }

        // Adobe VMs need the match returned to produce the correct offset.
        return match;
      });
      source += "';\n";

      var argument = settings.variable;
      if (argument) {
        // Insure against third-party code injection. (CVE-2021-23358)
        if (!bareIdentifier.test(argument)) throw new Error(
          'variable is not a bare identifier: ' + argument
        );
      } else {
        // If a variable is not specified, place data values in local scope.
        source = 'with(obj||{}){\n' + source + '}\n';
        argument = 'obj';
      }

      source = "var __t,__p='',__j=Array.prototype.join," +
        "print=function(){__p+=__j.call(arguments,'');};\n" +
        source + 'return __p;\n';

      var render;
      try {
        render = new Function(argument, '_', source);
      } catch (e) {
        e.source = source;
        throw e;
      }

      var template = function(data) {
        return render.call(this, data, _$1);
      };

      // Provide the compiled source as a convenience for precompilation.
      template.source = 'function(' + argument + '){\n' + source + '}';

      return template;
    }

    // Traverses the children of `obj` along `path`. If a child is a function, it
    // is invoked with its parent as context. Returns the value of the final
    // child, or `fallback` if any child is undefined.
    function result(obj, path, fallback) {
      path = toPath(path);
      var length = path.length;
      if (!length) {
        return isFunction$1(fallback) ? fallback.call(obj) : fallback;
      }
      for (var i = 0; i < length; i++) {
        var prop = obj == null ? void 0 : obj[path[i]];
        if (prop === void 0) {
          prop = fallback;
          i = length; // Ensure we don't continue iterating.
        }
        obj = isFunction$1(prop) ? prop.call(obj) : prop;
      }
      return obj;
    }

    // Generate a unique integer id (unique within the entire client session).
    // Useful for temporary DOM ids.
    var idCounter = 0;
    function uniqueId(prefix) {
      var id = ++idCounter + '';
      return prefix ? prefix + id : id;
    }

    // Start chaining a wrapped Underscore object.
    function chain(obj) {
      var instance = _$1(obj);
      instance._chain = true;
      return instance;
    }

    // Internal function to execute `sourceFunc` bound to `context` with optional
    // `args`. Determines whether to execute a function as a constructor or as a
    // normal function.
    function executeBound(sourceFunc, boundFunc, context, callingContext, args) {
      if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
      var self = baseCreate(sourceFunc.prototype);
      var result = sourceFunc.apply(self, args);
      if (isObject(result)) return result;
      return self;
    }

    // Partially apply a function by creating a version that has had some of its
    // arguments pre-filled, without changing its dynamic `this` context. `_` acts
    // as a placeholder by default, allowing any combination of arguments to be
    // pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.
    var partial = restArguments(function(func, boundArgs) {
      var placeholder = partial.placeholder;
      var bound = function() {
        var position = 0, length = boundArgs.length;
        var args = Array(length);
        for (var i = 0; i < length; i++) {
          args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
        }
        while (position < arguments.length) args.push(arguments[position++]);
        return executeBound(func, bound, this, this, args);
      };
      return bound;
    });

    partial.placeholder = _$1;

    // Create a function bound to a given object (assigning `this`, and arguments,
    // optionally).
    var bind = restArguments(function(func, context, args) {
      if (!isFunction$1(func)) throw new TypeError('Bind must be called on a function');
      var bound = restArguments(function(callArgs) {
        return executeBound(func, bound, context, this, args.concat(callArgs));
      });
      return bound;
    });

    // Internal helper for collection methods to determine whether a collection
    // should be iterated as an array or as an object.
    // Related: https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
    // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
    var isArrayLike = createSizePropertyCheck(getLength);

    // Internal implementation of a recursive `flatten` function.
    function flatten$1(input, depth, strict, output) {
      output = output || [];
      if (!depth && depth !== 0) {
        depth = Infinity;
      } else if (depth <= 0) {
        return output.concat(input);
      }
      var idx = output.length;
      for (var i = 0, length = getLength(input); i < length; i++) {
        var value = input[i];
        if (isArrayLike(value) && (isArray(value) || isArguments$1(value))) {
          // Flatten current level of array or arguments object.
          if (depth > 1) {
            flatten$1(value, depth - 1, strict, output);
            idx = output.length;
          } else {
            var j = 0, len = value.length;
            while (j < len) output[idx++] = value[j++];
          }
        } else if (!strict) {
          output[idx++] = value;
        }
      }
      return output;
    }

    // Bind a number of an object's methods to that object. Remaining arguments
    // are the method names to be bound. Useful for ensuring that all callbacks
    // defined on an object belong to it.
    var bindAll = restArguments(function(obj, keys) {
      keys = flatten$1(keys, false, false);
      var index = keys.length;
      if (index < 1) throw new Error('bindAll must be passed function names');
      while (index--) {
        var key = keys[index];
        obj[key] = bind(obj[key], obj);
      }
      return obj;
    });

    // Memoize an expensive function by storing its results.
    function memoize(func, hasher) {
      var memoize = function(key) {
        var cache = memoize.cache;
        var address = '' + (hasher ? hasher.apply(this, arguments) : key);
        if (!has$1(cache, address)) cache[address] = func.apply(this, arguments);
        return cache[address];
      };
      memoize.cache = {};
      return memoize;
    }

    // Delays a function for the given number of milliseconds, and then calls
    // it with the arguments supplied.
    var delay = restArguments(function(func, wait, args) {
      return setTimeout(function() {
        return func.apply(null, args);
      }, wait);
    });

    // Defers a function, scheduling it to run after the current call stack has
    // cleared.
    var defer = partial(delay, _$1, 1);

    // Returns a function, that, when invoked, will only be triggered at most once
    // during a given window of time. Normally, the throttled function will run
    // as much as it can, without ever going more than once per `wait` duration;
    // but if you'd like to disable the execution on the leading edge, pass
    // `{leading: false}`. To disable execution on the trailing edge, ditto.
    function throttle(func, wait, options) {
      var timeout, context, args, result;
      var previous = 0;
      if (!options) options = {};

      var later = function() {
        previous = options.leading === false ? 0 : now();
        timeout = null;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      };

      var throttled = function() {
        var _now = now();
        if (!previous && options.leading === false) previous = _now;
        var remaining = wait - (_now - previous);
        context = this;
        args = arguments;
        if (remaining <= 0 || remaining > wait) {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;
          }
          previous = _now;
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        } else if (!timeout && options.trailing !== false) {
          timeout = setTimeout(later, remaining);
        }
        return result;
      };

      throttled.cancel = function() {
        clearTimeout(timeout);
        previous = 0;
        timeout = context = args = null;
      };

      return throttled;
    }

    // When a sequence of calls of the returned function ends, the argument
    // function is triggered. The end of a sequence is defined by the `wait`
    // parameter. If `immediate` is passed, the argument function will be
    // triggered at the beginning of the sequence instead of at the end.
    function debounce(func, wait, immediate) {
      var timeout, previous, args, result, context;

      var later = function() {
        var passed = now() - previous;
        if (wait > passed) {
          timeout = setTimeout(later, wait - passed);
        } else {
          timeout = null;
          if (!immediate) result = func.apply(context, args);
          // This check is needed because `func` can recursively invoke `debounced`.
          if (!timeout) args = context = null;
        }
      };

      var debounced = restArguments(function(_args) {
        context = this;
        args = _args;
        previous = now();
        if (!timeout) {
          timeout = setTimeout(later, wait);
          if (immediate) result = func.apply(context, args);
        }
        return result;
      });

      debounced.cancel = function() {
        clearTimeout(timeout);
        timeout = args = context = null;
      };

      return debounced;
    }

    // Returns the first function passed as an argument to the second,
    // allowing you to adjust arguments, run code before and after, and
    // conditionally execute the original function.
    function wrap(func, wrapper) {
      return partial(wrapper, func);
    }

    // Returns a negated version of the passed-in predicate.
    function negate(predicate) {
      return function() {
        return !predicate.apply(this, arguments);
      };
    }

    // Returns a function that is the composition of a list of functions, each
    // consuming the return value of the function that follows.
    function compose() {
      var args = arguments;
      var start = args.length - 1;
      return function() {
        var i = start;
        var result = args[start].apply(this, arguments);
        while (i--) result = args[i].call(this, result);
        return result;
      };
    }

    // Returns a function that will only be executed on and after the Nth call.
    function after(times, func) {
      return function() {
        if (--times < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    // Returns a function that will only be executed up to (but not including) the
    // Nth call.
    function before(times, func) {
      var memo;
      return function() {
        if (--times > 0) {
          memo = func.apply(this, arguments);
        }
        if (times <= 1) func = null;
        return memo;
      };
    }

    // Returns a function that will be executed at most one time, no matter how
    // often you call it. Useful for lazy initialization.
    var once = partial(before, 2);

    // Returns the first key on an object that passes a truth test.
    function findKey(obj, predicate, context) {
      predicate = cb(predicate, context);
      var _keys = keys(obj), key;
      for (var i = 0, length = _keys.length; i < length; i++) {
        key = _keys[i];
        if (predicate(obj[key], key, obj)) return key;
      }
    }

    // Internal function to generate `_.findIndex` and `_.findLastIndex`.
    function createPredicateIndexFinder(dir) {
      return function(array, predicate, context) {
        predicate = cb(predicate, context);
        var length = getLength(array);
        var index = dir > 0 ? 0 : length - 1;
        for (; index >= 0 && index < length; index += dir) {
          if (predicate(array[index], index, array)) return index;
        }
        return -1;
      };
    }

    // Returns the first index on an array-like that passes a truth test.
    var findIndex = createPredicateIndexFinder(1);

    // Returns the last index on an array-like that passes a truth test.
    var findLastIndex = createPredicateIndexFinder(-1);

    // Use a comparator function to figure out the smallest index at which
    // an object should be inserted so as to maintain order. Uses binary search.
    function sortedIndex(array, obj, iteratee, context) {
      iteratee = cb(iteratee, context, 1);
      var value = iteratee(obj);
      var low = 0, high = getLength(array);
      while (low < high) {
        var mid = Math.floor((low + high) / 2);
        if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
      }
      return low;
    }

    // Internal function to generate the `_.indexOf` and `_.lastIndexOf` functions.
    function createIndexFinder(dir, predicateFind, sortedIndex) {
      return function(array, item, idx) {
        var i = 0, length = getLength(array);
        if (typeof idx == 'number') {
          if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
          } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
          }
        } else if (sortedIndex && idx && length) {
          idx = sortedIndex(array, item);
          return array[idx] === item ? idx : -1;
        }
        if (item !== item) {
          idx = predicateFind(slice.call(array, i, length), isNaN$1);
          return idx >= 0 ? idx + i : -1;
        }
        for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
          if (array[idx] === item) return idx;
        }
        return -1;
      };
    }

    // Return the position of the first occurrence of an item in an array,
    // or -1 if the item is not included in the array.
    // If the array is large and already in sort order, pass `true`
    // for **isSorted** to use binary search.
    var indexOf = createIndexFinder(1, findIndex, sortedIndex);

    // Return the position of the last occurrence of an item in an array,
    // or -1 if the item is not included in the array.
    var lastIndexOf = createIndexFinder(-1, findLastIndex);

    // Return the first value which passes a truth test.
    function find(obj, predicate, context) {
      var keyFinder = isArrayLike(obj) ? findIndex : findKey;
      var key = keyFinder(obj, predicate, context);
      if (key !== void 0 && key !== -1) return obj[key];
    }

    // Convenience version of a common use case of `_.find`: getting the first
    // object containing specific `key:value` pairs.
    function findWhere(obj, attrs) {
      return find(obj, matcher(attrs));
    }

    // The cornerstone for collection functions, an `each`
    // implementation, aka `forEach`.
    // Handles raw objects in addition to array-likes. Treats all
    // sparse array-likes as if they were dense.
    function each(obj, iteratee, context) {
      iteratee = optimizeCb(iteratee, context);
      var i, length;
      if (isArrayLike(obj)) {
        for (i = 0, length = obj.length; i < length; i++) {
          iteratee(obj[i], i, obj);
        }
      } else {
        var _keys = keys(obj);
        for (i = 0, length = _keys.length; i < length; i++) {
          iteratee(obj[_keys[i]], _keys[i], obj);
        }
      }
      return obj;
    }

    // Return the results of applying the iteratee to each element.
    function map(obj, iteratee, context) {
      iteratee = cb(iteratee, context);
      var _keys = !isArrayLike(obj) && keys(obj),
          length = (_keys || obj).length,
          results = Array(length);
      for (var index = 0; index < length; index++) {
        var currentKey = _keys ? _keys[index] : index;
        results[index] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
    }

    // Internal helper to create a reducing function, iterating left or right.
    function createReduce(dir) {
      // Wrap code that reassigns argument variables in a separate function than
      // the one that accesses `arguments.length` to avoid a perf hit. (#1991)
      var reducer = function(obj, iteratee, memo, initial) {
        var _keys = !isArrayLike(obj) && keys(obj),
            length = (_keys || obj).length,
            index = dir > 0 ? 0 : length - 1;
        if (!initial) {
          memo = obj[_keys ? _keys[index] : index];
          index += dir;
        }
        for (; index >= 0 && index < length; index += dir) {
          var currentKey = _keys ? _keys[index] : index;
          memo = iteratee(memo, obj[currentKey], currentKey, obj);
        }
        return memo;
      };

      return function(obj, iteratee, memo, context) {
        var initial = arguments.length >= 3;
        return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
      };
    }

    // **Reduce** builds up a single result from a list of values, aka `inject`,
    // or `foldl`.
    var reduce = createReduce(1);

    // The right-associative version of reduce, also known as `foldr`.
    var reduceRight = createReduce(-1);

    // Return all the elements that pass a truth test.
    function filter(obj, predicate, context) {
      var results = [];
      predicate = cb(predicate, context);
      each(obj, function(value, index, list) {
        if (predicate(value, index, list)) results.push(value);
      });
      return results;
    }

    // Return all the elements for which a truth test fails.
    function reject(obj, predicate, context) {
      return filter(obj, negate(cb(predicate)), context);
    }

    // Determine whether all of the elements pass a truth test.
    function every(obj, predicate, context) {
      predicate = cb(predicate, context);
      var _keys = !isArrayLike(obj) && keys(obj),
          length = (_keys || obj).length;
      for (var index = 0; index < length; index++) {
        var currentKey = _keys ? _keys[index] : index;
        if (!predicate(obj[currentKey], currentKey, obj)) return false;
      }
      return true;
    }

    // Determine if at least one element in the object passes a truth test.
    function some(obj, predicate, context) {
      predicate = cb(predicate, context);
      var _keys = !isArrayLike(obj) && keys(obj),
          length = (_keys || obj).length;
      for (var index = 0; index < length; index++) {
        var currentKey = _keys ? _keys[index] : index;
        if (predicate(obj[currentKey], currentKey, obj)) return true;
      }
      return false;
    }

    // Determine if the array or object contains a given item (using `===`).
    function contains(obj, item, fromIndex, guard) {
      if (!isArrayLike(obj)) obj = values(obj);
      if (typeof fromIndex != 'number' || guard) fromIndex = 0;
      return indexOf(obj, item, fromIndex) >= 0;
    }

    // Invoke a method (with arguments) on every item in a collection.
    var invoke = restArguments(function(obj, path, args) {
      var contextPath, func;
      if (isFunction$1(path)) {
        func = path;
      } else {
        path = toPath(path);
        contextPath = path.slice(0, -1);
        path = path[path.length - 1];
      }
      return map(obj, function(context) {
        var method = func;
        if (!method) {
          if (contextPath && contextPath.length) {
            context = deepGet(context, contextPath);
          }
          if (context == null) return void 0;
          method = context[path];
        }
        return method == null ? method : method.apply(context, args);
      });
    });

    // Convenience version of a common use case of `_.map`: fetching a property.
    function pluck(obj, key) {
      return map(obj, property(key));
    }

    // Convenience version of a common use case of `_.filter`: selecting only
    // objects containing specific `key:value` pairs.
    function where(obj, attrs) {
      return filter(obj, matcher(attrs));
    }

    // Return the maximum element (or element-based computation).
    function max(obj, iteratee, context) {
      var result = -Infinity, lastComputed = -Infinity,
          value, computed;
      if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
        obj = isArrayLike(obj) ? obj : values(obj);
        for (var i = 0, length = obj.length; i < length; i++) {
          value = obj[i];
          if (value != null && value > result) {
            result = value;
          }
        }
      } else {
        iteratee = cb(iteratee, context);
        each(obj, function(v, index, list) {
          computed = iteratee(v, index, list);
          if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
            result = v;
            lastComputed = computed;
          }
        });
      }
      return result;
    }

    // Return the minimum element (or element-based computation).
    function min(obj, iteratee, context) {
      var result = Infinity, lastComputed = Infinity,
          value, computed;
      if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
        obj = isArrayLike(obj) ? obj : values(obj);
        for (var i = 0, length = obj.length; i < length; i++) {
          value = obj[i];
          if (value != null && value < result) {
            result = value;
          }
        }
      } else {
        iteratee = cb(iteratee, context);
        each(obj, function(v, index, list) {
          computed = iteratee(v, index, list);
          if (computed < lastComputed || computed === Infinity && result === Infinity) {
            result = v;
            lastComputed = computed;
          }
        });
      }
      return result;
    }

    // Sample **n** random values from a collection using the modern version of the
    // [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
    // If **n** is not specified, returns a single random element.
    // The internal `guard` argument allows it to work with `_.map`.
    function sample(obj, n, guard) {
      if (n == null || guard) {
        if (!isArrayLike(obj)) obj = values(obj);
        return obj[random(obj.length - 1)];
      }
      var sample = isArrayLike(obj) ? clone(obj) : values(obj);
      var length = getLength(sample);
      n = Math.max(Math.min(n, length), 0);
      var last = length - 1;
      for (var index = 0; index < n; index++) {
        var rand = random(index, last);
        var temp = sample[index];
        sample[index] = sample[rand];
        sample[rand] = temp;
      }
      return sample.slice(0, n);
    }

    // Shuffle a collection.
    function shuffle(obj) {
      return sample(obj, Infinity);
    }

    // Sort the object's values by a criterion produced by an iteratee.
    function sortBy(obj, iteratee, context) {
      var index = 0;
      iteratee = cb(iteratee, context);
      return pluck(map(obj, function(value, key, list) {
        return {
          value: value,
          index: index++,
          criteria: iteratee(value, key, list)
        };
      }).sort(function(left, right) {
        var a = left.criteria;
        var b = right.criteria;
        if (a !== b) {
          if (a > b || a === void 0) return 1;
          if (a < b || b === void 0) return -1;
        }
        return left.index - right.index;
      }), 'value');
    }

    // An internal function used for aggregate "group by" operations.
    function group(behavior, partition) {
      return function(obj, iteratee, context) {
        var result = partition ? [[], []] : {};
        iteratee = cb(iteratee, context);
        each(obj, function(value, index) {
          var key = iteratee(value, index, obj);
          behavior(result, value, key);
        });
        return result;
      };
    }

    // Groups the object's values by a criterion. Pass either a string attribute
    // to group by, or a function that returns the criterion.
    var groupBy = group(function(result, value, key) {
      if (has$1(result, key)) result[key].push(value); else result[key] = [value];
    });

    // Indexes the object's values by a criterion, similar to `_.groupBy`, but for
    // when you know that your index values will be unique.
    var indexBy = group(function(result, value, key) {
      result[key] = value;
    });

    // Counts instances of an object that group by a certain criterion. Pass
    // either a string attribute to count by, or a function that returns the
    // criterion.
    var countBy = group(function(result, value, key) {
      if (has$1(result, key)) result[key]++; else result[key] = 1;
    });

    // Split a collection into two arrays: one whose elements all pass the given
    // truth test, and one whose elements all do not pass the truth test.
    var partition = group(function(result, value, pass) {
      result[pass ? 0 : 1].push(value);
    }, true);

    // Safely create a real, live array from anything iterable.
    var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
    function toArray(obj) {
      if (!obj) return [];
      if (isArray(obj)) return slice.call(obj);
      if (isString(obj)) {
        // Keep surrogate pair characters together.
        return obj.match(reStrSymbol);
      }
      if (isArrayLike(obj)) return map(obj, identity);
      return values(obj);
    }

    // Return the number of elements in a collection.
    function size(obj) {
      if (obj == null) return 0;
      return isArrayLike(obj) ? obj.length : keys(obj).length;
    }

    // Internal `_.pick` helper function to determine whether `key` is an enumerable
    // property name of `obj`.
    function keyInObj(value, key, obj) {
      return key in obj;
    }

    // Return a copy of the object only containing the allowed properties.
    var pick = restArguments(function(obj, keys) {
      var result = {}, iteratee = keys[0];
      if (obj == null) return result;
      if (isFunction$1(iteratee)) {
        if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);
        keys = allKeys(obj);
      } else {
        iteratee = keyInObj;
        keys = flatten$1(keys, false, false);
        obj = Object(obj);
      }
      for (var i = 0, length = keys.length; i < length; i++) {
        var key = keys[i];
        var value = obj[key];
        if (iteratee(value, key, obj)) result[key] = value;
      }
      return result;
    });

    // Return a copy of the object without the disallowed properties.
    var omit = restArguments(function(obj, keys) {
      var iteratee = keys[0], context;
      if (isFunction$1(iteratee)) {
        iteratee = negate(iteratee);
        if (keys.length > 1) context = keys[1];
      } else {
        keys = map(flatten$1(keys, false, false), String);
        iteratee = function(value, key) {
          return !contains(keys, key);
        };
      }
      return pick(obj, iteratee, context);
    });

    // Returns everything but the last entry of the array. Especially useful on
    // the arguments object. Passing **n** will return all the values in
    // the array, excluding the last N.
    function initial(array, n, guard) {
      return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
    }

    // Get the first element of an array. Passing **n** will return the first N
    // values in the array. The **guard** check allows it to work with `_.map`.
    function first(array, n, guard) {
      if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
      if (n == null || guard) return array[0];
      return initial(array, array.length - n);
    }

    // Returns everything but the first entry of the `array`. Especially useful on
    // the `arguments` object. Passing an **n** will return the rest N values in the
    // `array`.
    function rest(array, n, guard) {
      return slice.call(array, n == null || guard ? 1 : n);
    }

    // Get the last element of an array. Passing **n** will return the last N
    // values in the array.
    function last(array, n, guard) {
      if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
      if (n == null || guard) return array[array.length - 1];
      return rest(array, Math.max(0, array.length - n));
    }

    // Trim out all falsy values from an array.
    function compact(array) {
      return filter(array, Boolean);
    }

    // Flatten out an array, either recursively (by default), or up to `depth`.
    // Passing `true` or `false` as `depth` means `1` or `Infinity`, respectively.
    function flatten(array, depth) {
      return flatten$1(array, depth, false);
    }

    // Take the difference between one array and a number of other arrays.
    // Only the elements present in just the first array will remain.
    var difference = restArguments(function(array, rest) {
      rest = flatten$1(rest, true, true);
      return filter(array, function(value){
        return !contains(rest, value);
      });
    });

    // Return a version of the array that does not contain the specified value(s).
    var without = restArguments(function(array, otherArrays) {
      return difference(array, otherArrays);
    });

    // Produce a duplicate-free version of the array. If the array has already
    // been sorted, you have the option of using a faster algorithm.
    // The faster algorithm will not work with an iteratee if the iteratee
    // is not a one-to-one function, so providing an iteratee will disable
    // the faster algorithm.
    function uniq(array, isSorted, iteratee, context) {
      if (!isBoolean(isSorted)) {
        context = iteratee;
        iteratee = isSorted;
        isSorted = false;
      }
      if (iteratee != null) iteratee = cb(iteratee, context);
      var result = [];
      var seen = [];
      for (var i = 0, length = getLength(array); i < length; i++) {
        var value = array[i],
            computed = iteratee ? iteratee(value, i, array) : value;
        if (isSorted && !iteratee) {
          if (!i || seen !== computed) result.push(value);
          seen = computed;
        } else if (iteratee) {
          if (!contains(seen, computed)) {
            seen.push(computed);
            result.push(value);
          }
        } else if (!contains(result, value)) {
          result.push(value);
        }
      }
      return result;
    }

    // Produce an array that contains the union: each distinct element from all of
    // the passed-in arrays.
    var union = restArguments(function(arrays) {
      return uniq(flatten$1(arrays, true, true));
    });

    // Produce an array that contains every item shared between all the
    // passed-in arrays.
    function intersection(array) {
      var result = [];
      var argsLength = arguments.length;
      for (var i = 0, length = getLength(array); i < length; i++) {
        var item = array[i];
        if (contains(result, item)) continue;
        var j;
        for (j = 1; j < argsLength; j++) {
          if (!contains(arguments[j], item)) break;
        }
        if (j === argsLength) result.push(item);
      }
      return result;
    }

    // Complement of zip. Unzip accepts an array of arrays and groups
    // each array's elements on shared indices.
    function unzip(array) {
      var length = array && max(array, getLength).length || 0;
      var result = Array(length);

      for (var index = 0; index < length; index++) {
        result[index] = pluck(array, index);
      }
      return result;
    }

    // Zip together multiple lists into a single array -- elements that share
    // an index go together.
    var zip = restArguments(unzip);

    // Converts lists into objects. Pass either a single array of `[key, value]`
    // pairs, or two parallel arrays of the same length -- one of keys, and one of
    // the corresponding values. Passing by pairs is the reverse of `_.pairs`.
    function object(list, values) {
      var result = {};
      for (var i = 0, length = getLength(list); i < length; i++) {
        if (values) {
          result[list[i]] = values[i];
        } else {
          result[list[i][0]] = list[i][1];
        }
      }
      return result;
    }

    // Generate an integer Array containing an arithmetic progression. A port of
    // the native Python `range()` function. See
    // [the Python documentation](https://docs.python.org/library/functions.html#range).
    function range(start, stop, step) {
      if (stop == null) {
        stop = start || 0;
        start = 0;
      }
      if (!step) {
        step = stop < start ? -1 : 1;
      }

      var length = Math.max(Math.ceil((stop - start) / step), 0);
      var range = Array(length);

      for (var idx = 0; idx < length; idx++, start += step) {
        range[idx] = start;
      }

      return range;
    }

    // Chunk a single array into multiple arrays, each containing `count` or fewer
    // items.
    function chunk(array, count) {
      if (count == null || count < 1) return [];
      var result = [];
      var i = 0, length = array.length;
      while (i < length) {
        result.push(slice.call(array, i, i += count));
      }
      return result;
    }

    // Helper function to continue chaining intermediate results.
    function chainResult(instance, obj) {
      return instance._chain ? _$1(obj).chain() : obj;
    }

    // Add your own custom functions to the Underscore object.
    function mixin(obj) {
      each(functions(obj), function(name) {
        var func = _$1[name] = obj[name];
        _$1.prototype[name] = function() {
          var args = [this._wrapped];
          push.apply(args, arguments);
          return chainResult(this, func.apply(_$1, args));
        };
      });
      return _$1;
    }

    // Add all mutator `Array` functions to the wrapper.
    each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
      var method = ArrayProto[name];
      _$1.prototype[name] = function() {
        var obj = this._wrapped;
        if (obj != null) {
          method.apply(obj, arguments);
          if ((name === 'shift' || name === 'splice') && obj.length === 0) {
            delete obj[0];
          }
        }
        return chainResult(this, obj);
      };
    });

    // Add all accessor `Array` functions to the wrapper.
    each(['concat', 'join', 'slice'], function(name) {
      var method = ArrayProto[name];
      _$1.prototype[name] = function() {
        var obj = this._wrapped;
        if (obj != null) obj = method.apply(obj, arguments);
        return chainResult(this, obj);
      };
    });

    // Named Exports

    var allExports = /*#__PURE__*/Object.freeze({
        __proto__: null,
        VERSION: VERSION,
        restArguments: restArguments,
        isObject: isObject,
        isNull: isNull,
        isUndefined: isUndefined,
        isBoolean: isBoolean,
        isElement: isElement,
        isString: isString,
        isNumber: isNumber,
        isDate: isDate,
        isRegExp: isRegExp,
        isError: isError,
        isSymbol: isSymbol,
        isArrayBuffer: isArrayBuffer,
        isDataView: isDataView$1,
        isArray: isArray,
        isFunction: isFunction$1,
        isArguments: isArguments$1,
        isFinite: isFinite$1,
        isNaN: isNaN$1,
        isTypedArray: isTypedArray$1,
        isEmpty: isEmpty,
        isMatch: isMatch,
        isEqual: isEqual,
        isMap: isMap,
        isWeakMap: isWeakMap,
        isSet: isSet,
        isWeakSet: isWeakSet,
        keys: keys,
        allKeys: allKeys,
        values: values,
        pairs: pairs,
        invert: invert,
        functions: functions,
        methods: functions,
        extend: extend,
        extendOwn: extendOwn,
        assign: extendOwn,
        defaults: defaults,
        create: create,
        clone: clone,
        tap: tap,
        get: get,
        has: has,
        mapObject: mapObject,
        identity: identity,
        constant: constant,
        noop: noop,
        toPath: toPath$1,
        property: property,
        propertyOf: propertyOf,
        matcher: matcher,
        matches: matcher,
        times: times,
        random: random,
        now: now,
        escape: _escape,
        unescape: _unescape,
        templateSettings: templateSettings,
        template: template,
        result: result,
        uniqueId: uniqueId,
        chain: chain,
        iteratee: iteratee,
        partial: partial,
        bind: bind,
        bindAll: bindAll,
        memoize: memoize,
        delay: delay,
        defer: defer,
        throttle: throttle,
        debounce: debounce,
        wrap: wrap,
        negate: negate,
        compose: compose,
        after: after,
        before: before,
        once: once,
        findKey: findKey,
        findIndex: findIndex,
        findLastIndex: findLastIndex,
        sortedIndex: sortedIndex,
        indexOf: indexOf,
        lastIndexOf: lastIndexOf,
        find: find,
        detect: find,
        findWhere: findWhere,
        each: each,
        forEach: each,
        map: map,
        collect: map,
        reduce: reduce,
        foldl: reduce,
        inject: reduce,
        reduceRight: reduceRight,
        foldr: reduceRight,
        filter: filter,
        select: filter,
        reject: reject,
        every: every,
        all: every,
        some: some,
        any: some,
        contains: contains,
        includes: contains,
        include: contains,
        invoke: invoke,
        pluck: pluck,
        where: where,
        max: max,
        min: min,
        shuffle: shuffle,
        sample: sample,
        sortBy: sortBy,
        groupBy: groupBy,
        indexBy: indexBy,
        countBy: countBy,
        partition: partition,
        toArray: toArray,
        size: size,
        pick: pick,
        omit: omit,
        first: first,
        head: first,
        take: first,
        initial: initial,
        last: last,
        rest: rest,
        tail: rest,
        drop: rest,
        compact: compact,
        flatten: flatten,
        without: without,
        uniq: uniq,
        unique: uniq,
        union: union,
        intersection: intersection,
        difference: difference,
        unzip: unzip,
        transpose: unzip,
        zip: zip,
        object: object,
        range: range,
        chunk: chunk,
        mixin: mixin,
        'default': _$1
    });

    // Default Export

    // Add all of the Underscore functions to the wrapper object.
    var _ = mixin(allExports);
    // Legacy Node.js API.
    _._ = _;

    /*
    Language: JSON
    Description: JSON (JavaScript Object Notation) is a lightweight data-interchange format.
    Author: Ivan Sagalaev <maniac@softwaremaniacs.org>
    Website: http://www.json.org
    Category: common, protocols
    */

    function json(hljs) {
      const LITERALS = {
        literal: 'true false null'
      };
      const ALLOWED_COMMENTS = [
        hljs.C_LINE_COMMENT_MODE,
        hljs.C_BLOCK_COMMENT_MODE
      ];
      const TYPES = [
        hljs.QUOTE_STRING_MODE,
        hljs.C_NUMBER_MODE
      ];
      const VALUE_CONTAINER = {
        end: ',',
        endsWithParent: true,
        excludeEnd: true,
        contains: TYPES,
        keywords: LITERALS
      };
      const OBJECT = {
        begin: /\{/,
        end: /\}/,
        contains: [
          {
            className: 'attr',
            begin: /"/,
            end: /"/,
            contains: [hljs.BACKSLASH_ESCAPE],
            illegal: '\\n'
          },
          hljs.inherit(VALUE_CONTAINER, {
            begin: /:/
          })
        ].concat(ALLOWED_COMMENTS),
        illegal: '\\S'
      };
      const ARRAY = {
        begin: '\\[',
        end: '\\]',
        contains: [hljs.inherit(VALUE_CONTAINER)], // inherit is a workaround for a bug that makes shared modes with endsWithParent compile only the ending of one of the parents
        illegal: '\\S'
      };
      TYPES.push(OBJECT, ARRAY);
      ALLOWED_COMMENTS.forEach(function(rule) {
        TYPES.push(rule);
      });
      return {
        name: 'JSON',
        contains: TYPES,
        keywords: LITERALS,
        illegal: '\\S'
      };
    }

    var json_1 = json;

    const MODES = (hljs) => {
      return {
        IMPORTANT: {
          className: 'meta',
          begin: '!important'
        },
        HEXCOLOR: {
          className: 'number',
          begin: '#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})'
        },
        ATTRIBUTE_SELECTOR_MODE: {
          className: 'selector-attr',
          begin: /\[/,
          end: /\]/,
          illegal: '$',
          contains: [
            hljs.APOS_STRING_MODE,
            hljs.QUOTE_STRING_MODE
          ]
        }
      };
    };

    const TAGS = [
      'a',
      'abbr',
      'address',
      'article',
      'aside',
      'audio',
      'b',
      'blockquote',
      'body',
      'button',
      'canvas',
      'caption',
      'cite',
      'code',
      'dd',
      'del',
      'details',
      'dfn',
      'div',
      'dl',
      'dt',
      'em',
      'fieldset',
      'figcaption',
      'figure',
      'footer',
      'form',
      'h1',
      'h2',
      'h3',
      'h4',
      'h5',
      'h6',
      'header',
      'hgroup',
      'html',
      'i',
      'iframe',
      'img',
      'input',
      'ins',
      'kbd',
      'label',
      'legend',
      'li',
      'main',
      'mark',
      'menu',
      'nav',
      'object',
      'ol',
      'p',
      'q',
      'quote',
      'samp',
      'section',
      'span',
      'strong',
      'summary',
      'sup',
      'table',
      'tbody',
      'td',
      'textarea',
      'tfoot',
      'th',
      'thead',
      'time',
      'tr',
      'ul',
      'var',
      'video'
    ];

    const MEDIA_FEATURES = [
      'any-hover',
      'any-pointer',
      'aspect-ratio',
      'color',
      'color-gamut',
      'color-index',
      'device-aspect-ratio',
      'device-height',
      'device-width',
      'display-mode',
      'forced-colors',
      'grid',
      'height',
      'hover',
      'inverted-colors',
      'monochrome',
      'orientation',
      'overflow-block',
      'overflow-inline',
      'pointer',
      'prefers-color-scheme',
      'prefers-contrast',
      'prefers-reduced-motion',
      'prefers-reduced-transparency',
      'resolution',
      'scan',
      'scripting',
      'update',
      'width',
      // TODO: find a better solution?
      'min-width',
      'max-width',
      'min-height',
      'max-height'
    ];

    // https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes
    const PSEUDO_CLASSES = [
      'active',
      'any-link',
      'blank',
      'checked',
      'current',
      'default',
      'defined',
      'dir', // dir()
      'disabled',
      'drop',
      'empty',
      'enabled',
      'first',
      'first-child',
      'first-of-type',
      'fullscreen',
      'future',
      'focus',
      'focus-visible',
      'focus-within',
      'has', // has()
      'host', // host or host()
      'host-context', // host-context()
      'hover',
      'indeterminate',
      'in-range',
      'invalid',
      'is', // is()
      'lang', // lang()
      'last-child',
      'last-of-type',
      'left',
      'link',
      'local-link',
      'not', // not()
      'nth-child', // nth-child()
      'nth-col', // nth-col()
      'nth-last-child', // nth-last-child()
      'nth-last-col', // nth-last-col()
      'nth-last-of-type', //nth-last-of-type()
      'nth-of-type', //nth-of-type()
      'only-child',
      'only-of-type',
      'optional',
      'out-of-range',
      'past',
      'placeholder-shown',
      'read-only',
      'read-write',
      'required',
      'right',
      'root',
      'scope',
      'target',
      'target-within',
      'user-invalid',
      'valid',
      'visited',
      'where' // where()
    ];

    // https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-elements
    const PSEUDO_ELEMENTS = [
      'after',
      'backdrop',
      'before',
      'cue',
      'cue-region',
      'first-letter',
      'first-line',
      'grammar-error',
      'marker',
      'part',
      'placeholder',
      'selection',
      'slotted',
      'spelling-error'
    ];

    const ATTRIBUTES = [
      'align-content',
      'align-items',
      'align-self',
      'animation',
      'animation-delay',
      'animation-direction',
      'animation-duration',
      'animation-fill-mode',
      'animation-iteration-count',
      'animation-name',
      'animation-play-state',
      'animation-timing-function',
      'auto',
      'backface-visibility',
      'background',
      'background-attachment',
      'background-clip',
      'background-color',
      'background-image',
      'background-origin',
      'background-position',
      'background-repeat',
      'background-size',
      'border',
      'border-bottom',
      'border-bottom-color',
      'border-bottom-left-radius',
      'border-bottom-right-radius',
      'border-bottom-style',
      'border-bottom-width',
      'border-collapse',
      'border-color',
      'border-image',
      'border-image-outset',
      'border-image-repeat',
      'border-image-slice',
      'border-image-source',
      'border-image-width',
      'border-left',
      'border-left-color',
      'border-left-style',
      'border-left-width',
      'border-radius',
      'border-right',
      'border-right-color',
      'border-right-style',
      'border-right-width',
      'border-spacing',
      'border-style',
      'border-top',
      'border-top-color',
      'border-top-left-radius',
      'border-top-right-radius',
      'border-top-style',
      'border-top-width',
      'border-width',
      'bottom',
      'box-decoration-break',
      'box-shadow',
      'box-sizing',
      'break-after',
      'break-before',
      'break-inside',
      'caption-side',
      'clear',
      'clip',
      'clip-path',
      'color',
      'column-count',
      'column-fill',
      'column-gap',
      'column-rule',
      'column-rule-color',
      'column-rule-style',
      'column-rule-width',
      'column-span',
      'column-width',
      'columns',
      'content',
      'counter-increment',
      'counter-reset',
      'cursor',
      'direction',
      'display',
      'empty-cells',
      'filter',
      'flex',
      'flex-basis',
      'flex-direction',
      'flex-flow',
      'flex-grow',
      'flex-shrink',
      'flex-wrap',
      'float',
      'font',
      'font-display',
      'font-family',
      'font-feature-settings',
      'font-kerning',
      'font-language-override',
      'font-size',
      'font-size-adjust',
      'font-smoothing',
      'font-stretch',
      'font-style',
      'font-variant',
      'font-variant-ligatures',
      'font-variation-settings',
      'font-weight',
      'height',
      'hyphens',
      'icon',
      'image-orientation',
      'image-rendering',
      'image-resolution',
      'ime-mode',
      'inherit',
      'initial',
      'justify-content',
      'left',
      'letter-spacing',
      'line-height',
      'list-style',
      'list-style-image',
      'list-style-position',
      'list-style-type',
      'margin',
      'margin-bottom',
      'margin-left',
      'margin-right',
      'margin-top',
      'marks',
      'mask',
      'max-height',
      'max-width',
      'min-height',
      'min-width',
      'nav-down',
      'nav-index',
      'nav-left',
      'nav-right',
      'nav-up',
      'none',
      'normal',
      'object-fit',
      'object-position',
      'opacity',
      'order',
      'orphans',
      'outline',
      'outline-color',
      'outline-offset',
      'outline-style',
      'outline-width',
      'overflow',
      'overflow-wrap',
      'overflow-x',
      'overflow-y',
      'padding',
      'padding-bottom',
      'padding-left',
      'padding-right',
      'padding-top',
      'page-break-after',
      'page-break-before',
      'page-break-inside',
      'perspective',
      'perspective-origin',
      'pointer-events',
      'position',
      'quotes',
      'resize',
      'right',
      'src', // @font-face
      'tab-size',
      'table-layout',
      'text-align',
      'text-align-last',
      'text-decoration',
      'text-decoration-color',
      'text-decoration-line',
      'text-decoration-style',
      'text-indent',
      'text-overflow',
      'text-rendering',
      'text-shadow',
      'text-transform',
      'text-underline-position',
      'top',
      'transform',
      'transform-origin',
      'transform-style',
      'transition',
      'transition-delay',
      'transition-duration',
      'transition-property',
      'transition-timing-function',
      'unicode-bidi',
      'vertical-align',
      'visibility',
      'white-space',
      'widows',
      'width',
      'word-break',
      'word-spacing',
      'word-wrap',
      'z-index'
      // reverse makes sure longer attributes `font-weight` are matched fully
      // instead of getting false positives on say `font`
    ].reverse();

    /**
     * @param {string} value
     * @returns {RegExp}
     * */

    /**
     * @param {RegExp | string } re
     * @returns {string}
     */
    function source(re) {
      if (!re) return null;
      if (typeof re === "string") return re;

      return re.source;
    }

    /**
     * @param {RegExp | string } re
     * @returns {string}
     */
    function lookahead(re) {
      return concat('(?=', re, ')');
    }

    /**
     * @param {...(RegExp | string) } args
     * @returns {string}
     */
    function concat(...args) {
      const joined = args.map((x) => source(x)).join("");
      return joined;
    }

    /*
    Language: CSS
    Category: common, css
    Website: https://developer.mozilla.org/en-US/docs/Web/CSS
    */

    /** @type LanguageFn */
    function css(hljs) {
      const modes = MODES(hljs);
      const FUNCTION_DISPATCH = {
        className: "built_in",
        begin: /[\w-]+(?=\()/
      };
      const VENDOR_PREFIX = {
        begin: /-(webkit|moz|ms|o)-(?=[a-z])/
      };
      const AT_MODIFIERS = "and or not only";
      const AT_PROPERTY_RE = /@-?\w[\w]*(-\w+)*/; // @-webkit-keyframes
      const IDENT_RE = '[a-zA-Z-][a-zA-Z0-9_-]*';
      const STRINGS = [
        hljs.APOS_STRING_MODE,
        hljs.QUOTE_STRING_MODE
      ];

      return {
        name: 'CSS',
        case_insensitive: true,
        illegal: /[=|'\$]/,
        keywords: {
          keyframePosition: "from to"
        },
        classNameAliases: {
          // for visual continuity with `tag {}` and because we
          // don't have a great class for this?
          keyframePosition: "selector-tag"
        },
        contains: [
          hljs.C_BLOCK_COMMENT_MODE,
          VENDOR_PREFIX,
          // to recognize keyframe 40% etc which are outside the scope of our
          // attribute value mode
          hljs.CSS_NUMBER_MODE,
          {
            className: 'selector-id',
            begin: /#[A-Za-z0-9_-]+/,
            relevance: 0
          },
          {
            className: 'selector-class',
            begin: '\\.' + IDENT_RE,
            relevance: 0
          },
          modes.ATTRIBUTE_SELECTOR_MODE,
          {
            className: 'selector-pseudo',
            variants: [
              {
                begin: ':(' + PSEUDO_CLASSES.join('|') + ')'
              },
              {
                begin: '::(' + PSEUDO_ELEMENTS.join('|') + ')'
              }
            ]
          },
          // we may actually need this (12/2020)
          // { // pseudo-selector params
          //   begin: /\(/,
          //   end: /\)/,
          //   contains: [ hljs.CSS_NUMBER_MODE ]
          // },
          {
            className: 'attribute',
            begin: '\\b(' + ATTRIBUTES.join('|') + ')\\b'
          },
          // attribute values
          {
            begin: ':',
            end: '[;}]',
            contains: [
              modes.HEXCOLOR,
              modes.IMPORTANT,
              hljs.CSS_NUMBER_MODE,
              ...STRINGS,
              // needed to highlight these as strings and to avoid issues with
              // illegal characters that might be inside urls that would tigger the
              // languages illegal stack
              {
                begin: /(url|data-uri)\(/,
                end: /\)/,
                relevance: 0, // from keywords
                keywords: {
                  built_in: "url data-uri"
                },
                contains: [
                  {
                    className: "string",
                    // any character other than `)` as in `url()` will be the start
                    // of a string, which ends with `)` (from the parent mode)
                    begin: /[^)]/,
                    endsWithParent: true,
                    excludeEnd: true
                  }
                ]
              },
              FUNCTION_DISPATCH
            ]
          },
          {
            begin: lookahead(/@/),
            end: '[{;]',
            relevance: 0,
            illegal: /:/, // break on Less variables @var: ...
            contains: [
              {
                className: 'keyword',
                begin: AT_PROPERTY_RE
              },
              {
                begin: /\s/,
                endsWithParent: true,
                excludeEnd: true,
                relevance: 0,
                keywords: {
                  $pattern: /[a-z-]+/,
                  keyword: AT_MODIFIERS,
                  attribute: MEDIA_FEATURES.join(" ")
                },
                contains: [
                  {
                    begin: /[a-z-]+(?=:)/,
                    className: "attribute"
                  },
                  ...STRINGS,
                  hljs.CSS_NUMBER_MODE
                ]
              }
            ]
          },
          {
            className: 'selector-tag',
            begin: '\\b(' + TAGS.join('|') + ')\\b'
          }
        ]
      };
    }

    var css_1 = css;

    /* src/components/HighlightedEditor.svelte generated by Svelte v3.38.2 */

    const { console: console_1$l, document: document_1 } = globals;
    const file$z = "src/components/HighlightedEditor.svelte";

    function create_fragment$C(ctx) {
    	let link;
    	let t0;
    	let div;
    	let t1;
    	let t2;
    	let button;
    	let t3;
    	let button_class_value;
    	let button_disabled_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			link = element("link");
    			t0 = space();
    			div = element("div");
    			t1 = text(/*content*/ ctx[1]);
    			t2 = space();
    			button = element("button");
    			t3 = text("Mettre à jour");
    			attr_dev(link, "rel", "stylesheet");
    			attr_dev(link, "href", "/css/highlight/highlight.css");
    			add_location(link, file$z, 36, 4, 882);
    			attr_dev(div, "id", /*id*/ ctx[0]);
    			attr_dev(div, "contenteditable", "true");
    			attr_dev(div, "class", "highlightEditor svelte-psvq8k");
    			add_location(div, file$z, 53, 0, 1136);
    			attr_dev(button, "class", button_class_value = "btn " + (/*toUpdate*/ ctx[2] ? "btn-success" : ""));
    			button.disabled = button_disabled_value = /*toUpdate*/ ctx[2] ? "" : "disabled";
    			attr_dev(button, "type", "button");
    			add_location(button, file$z, 58, 0, 1260);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			append_dev(document_1.head, link);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, t1);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, button, anchor);
    			append_dev(button, t3);

    			if (!mounted) {
    				dispose = [
    					listen_dev(div, "keyup", /*keyup_handler*/ ctx[5], false, false, false),
    					listen_dev(button, "click", /*click_handler*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*content*/ 2) set_data_dev(t1, /*content*/ ctx[1]);

    			if (dirty & /*id*/ 1) {
    				attr_dev(div, "id", /*id*/ ctx[0]);
    			}

    			if (dirty & /*toUpdate*/ 4 && button_class_value !== (button_class_value = "btn " + (/*toUpdate*/ ctx[2] ? "btn-success" : ""))) {
    				attr_dev(button, "class", button_class_value);
    			}

    			if (dirty & /*toUpdate*/ 4 && button_disabled_value !== (button_disabled_value = /*toUpdate*/ ctx[2] ? "" : "disabled")) {
    				prop_dev(button, "disabled", button_disabled_value);
    			}
    		},
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			detach_dev(link);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(button);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$C($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("HighlightedEditor", slots, []);
    	let { id } = $$props;
    	let { content } = $$props;
    	let { onChange } = $$props;
    	let toUpdate;
    	core.registerLanguage("json", json_1);
    	core.registerLanguage("css", css_1);

    	const highlight = htmlElement => {
    		core.highlightBlock(htmlElement);
    		const reg = new RegExp(/\u00A0/g);

    		if (typeof onChange === "function") {
    			onChange(htmlElement.textContent.replace(reg, ""));
    		}
    	};

    	onMount(() => {
    		document.querySelectorAll(".highlightEditor").forEach(htmlElement => {
    			core.highlightBlock(htmlElement);
    		});
    	});

    	onDestroy(() => {
    		
    	});

    	const writable_props = ["id", "content", "onChange"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$l.warn(`<HighlightedEditor> was created with unknown prop '${key}'`);
    	});

    	const keyup_handler = () => {
    		$$invalidate(2, toUpdate = true);
    	};

    	const click_handler = () => {
    		const element = document.getElementById(id);
    		console.log(element);
    		highlight(element);
    		$$invalidate(2, toUpdate = false);
    	};

    	$$self.$$set = $$props => {
    		if ("id" in $$props) $$invalidate(0, id = $$props.id);
    		if ("content" in $$props) $$invalidate(1, content = $$props.content);
    		if ("onChange" in $$props) $$invalidate(4, onChange = $$props.onChange);
    	};

    	$$self.$capture_state = () => ({
    		id,
    		content,
    		onChange,
    		toUpdate,
    		hljs: core,
    		_,
    		onMount,
    		onDestroy,
    		json: json_1,
    		css: css_1,
    		highlight
    	});

    	$$self.$inject_state = $$props => {
    		if ("id" in $$props) $$invalidate(0, id = $$props.id);
    		if ("content" in $$props) $$invalidate(1, content = $$props.content);
    		if ("onChange" in $$props) $$invalidate(4, onChange = $$props.onChange);
    		if ("toUpdate" in $$props) $$invalidate(2, toUpdate = $$props.toUpdate);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [id, content, toUpdate, highlight, onChange, keyup_handler, click_handler];
    }

    class HighlightedEditor extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$C, create_fragment$C, safe_not_equal, { id: 0, content: 1, onChange: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "HighlightedEditor",
    			options,
    			id: create_fragment$C.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*id*/ ctx[0] === undefined && !("id" in props)) {
    			console_1$l.warn("<HighlightedEditor> was created without expected prop 'id'");
    		}

    		if (/*content*/ ctx[1] === undefined && !("content" in props)) {
    			console_1$l.warn("<HighlightedEditor> was created without expected prop 'content'");
    		}

    		if (/*onChange*/ ctx[4] === undefined && !("onChange" in props)) {
    			console_1$l.warn("<HighlightedEditor> was created without expected prop 'onChange'");
    		}
    	}

    	get id() {
    		throw new Error("<HighlightedEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<HighlightedEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get content() {
    		throw new Error("<HighlightedEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set content(value) {
    		throw new Error("<HighlightedEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onChange() {
    		throw new Error("<HighlightedEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onChange(value) {
    		throw new Error("<HighlightedEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Editors/ContentTextContainerEditor.svelte generated by Svelte v3.38.2 */

    const { console: console_1$k } = globals;
    const file$y = "src/components/Editors/ContentTextContainerEditor.svelte";

    function create_fragment$B(ctx) {
    	let div0;
    	let label0;
    	let t1;
    	let input;
    	let t2;
    	let div1;
    	let label1;
    	let t3;
    	let t4;
    	let highlightededitor0;
    	let t5;
    	let div2;
    	let label2;
    	let t6;
    	let t7;
    	let highlightededitor1;
    	let t8;
    	let div4;
    	let label3;
    	let t9;
    	let t10;
    	let div3;
    	let current;
    	let mounted;
    	let dispose;

    	highlightededitor0 = new HighlightedEditor({
    			props: {
    				id: `style-${/*id*/ ctx[1]}`,
    				content: /*properties*/ ctx[0].style
    				? /*properties*/ ctx[0].style
    				: "",
    				onChange: /*func*/ ctx[4]
    			},
    			$$inline: true
    		});

    	highlightededitor1 = new HighlightedEditor({
    			props: {
    				id: `global-style-${/*id*/ ctx[1]}`,
    				content: /*properties*/ ctx[0].globalStyle
    				? /*properties*/ ctx[0].innerStyle
    				: "",
    				onChange: /*func_1*/ ctx[5]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			label0 = element("label");
    			label0.textContent = "CSS Classes :";
    			t1 = space();
    			input = element("input");
    			t2 = space();
    			div1 = element("div");
    			label1 = element("label");
    			t3 = text("Container Style :");
    			t4 = space();
    			create_component(highlightededitor0.$$.fragment);
    			t5 = space();
    			div2 = element("div");
    			label2 = element("label");
    			t6 = text("Global Style :");
    			t7 = space();
    			create_component(highlightededitor1.$$.fragment);
    			t8 = space();
    			div4 = element("div");
    			label3 = element("label");
    			t9 = text("Texte :");
    			t10 = space();
    			div3 = element("div");
    			attr_dev(label0, "for", "classes");
    			attr_dev(label0, "class", "svelte-1u9ur0u");
    			add_location(label0, file$y, 57, 4, 1447);
    			attr_dev(input, "id", "classes");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "class", "form-control");
    			attr_dev(input, "placeholder", "Taper le nom des classes css séparées par un espace");
    			add_location(input, file$y, 58, 4, 1494);
    			attr_dev(div0, "class", "");
    			add_location(div0, file$y, 56, 0, 1428);
    			attr_dev(label1, "for", `style-${/*id*/ ctx[1]}`);
    			attr_dev(label1, "class", "svelte-1u9ur0u");
    			add_location(label1, file$y, 61, 4, 1677);
    			attr_dev(div1, "class", "style");
    			add_location(div1, file$y, 60, 0, 1653);
    			attr_dev(label2, "for", `global-style-${/*id*/ ctx[1]}`);
    			attr_dev(label2, "class", "svelte-1u9ur0u");
    			add_location(label2, file$y, 72, 4, 2026);
    			attr_dev(div2, "class", "style");
    			add_location(div2, file$y, 71, 0, 2002);
    			attr_dev(label3, "for", "content-" + /*id*/ ctx[1]);
    			attr_dev(label3, "class", "svelte-1u9ur0u");
    			add_location(label3, file$y, 83, 4, 2405);
    			attr_dev(div3, "id", "content-" + /*id*/ ctx[1]);
    			add_location(div3, file$y, 84, 4, 2451);
    			attr_dev(div4, "class", "content svelte-1u9ur0u");
    			add_location(div4, file$y, 82, 0, 2379);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, label0);
    			append_dev(div0, t1);
    			append_dev(div0, input);
    			set_input_value(input, /*properties*/ ctx[0].classes);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, label1);
    			append_dev(label1, t3);
    			append_dev(div1, t4);
    			mount_component(highlightededitor0, div1, null);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, label2);
    			append_dev(label2, t6);
    			append_dev(div2, t7);
    			mount_component(highlightededitor1, div2, null);
    			insert_dev(target, t8, anchor);
    			insert_dev(target, div4, anchor);
    			append_dev(div4, label3);
    			append_dev(label3, t9);
    			append_dev(div4, t10);
    			append_dev(div4, div3);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(input, "input", /*input_input_handler*/ ctx[3]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*properties*/ 1 && input.value !== /*properties*/ ctx[0].classes) {
    				set_input_value(input, /*properties*/ ctx[0].classes);
    			}

    			const highlightededitor0_changes = {};

    			if (dirty & /*properties*/ 1) highlightededitor0_changes.content = /*properties*/ ctx[0].style
    			? /*properties*/ ctx[0].style
    			: "";

    			if (dirty & /*properties*/ 1) highlightededitor0_changes.onChange = /*func*/ ctx[4];
    			highlightededitor0.$set(highlightededitor0_changes);
    			const highlightededitor1_changes = {};

    			if (dirty & /*properties*/ 1) highlightededitor1_changes.content = /*properties*/ ctx[0].globalStyle
    			? /*properties*/ ctx[0].innerStyle
    			: "";

    			if (dirty & /*properties*/ 1) highlightededitor1_changes.onChange = /*func_1*/ ctx[5];
    			highlightededitor1.$set(highlightededitor1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(highlightededitor0.$$.fragment, local);
    			transition_in(highlightededitor1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(highlightededitor0.$$.fragment, local);
    			transition_out(highlightededitor1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div1);
    			destroy_component(highlightededitor0);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(div2);
    			destroy_component(highlightededitor1);
    			if (detaching) detach_dev(t8);
    			if (detaching) detach_dev(div4);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$B($$self, $$props, $$invalidate) {
    	let $ComponentEditorStore;
    	validate_store(ComponentEditorStore, "ComponentEditorStore");
    	component_subscribe($$self, ComponentEditorStore, $$value => $$invalidate(6, $ComponentEditorStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ContentTextContainerEditor", slots, []);
    	let { properties } = $$props;
    	let id = v4();

    	afterUpdate(() => {
    		console.log("editor updated");
    	});

    	onMount(() => {
    		window.setTimeout(() => {
    			const contentText = document.getElementById(`content-${id}`);
    			console.log(contentText);

    			const editor = new Editor({
    					target: contentText,
    					props: {
    						actions: [
    							"left",
    							"center",
    							"right",
    							"justify",
    							"b",
    							"i",
    							"u",
    							"strike",
    							"ul",
    							"ol",
    							"a",
    							"viewHtml"
    						],
    						html: properties.content
    					}
    				});

    			editor.$on("change", e => {
    				$$invalidate(0, properties.content = editor.getHtml(), properties);
    				updateEds();
    			});
    		});
    	});

    	function updateEds() {
    		EditableDocumentStore.update(eds => {
    			return eds;
    		});
    	}

    	const writable_props = ["properties"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$k.warn(`<ContentTextContainerEditor> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		properties.classes = this.value;
    		$$invalidate(0, properties);
    	}

    	const func = newStyle => {
    		$$invalidate(0, properties.style = newStyle, properties);
    		updateEds();
    	};

    	const func_1 = newStyle => {
    		$$invalidate(0, properties.globalStyle = newStyle, properties);
    		updateEds();
    	};

    	$$self.$$set = $$props => {
    		if ("properties" in $$props) $$invalidate(0, properties = $$props.properties);
    	};

    	$$self.$capture_state = () => ({
    		Editor,
    		uuid: v4,
    		onMount,
    		afterUpdate,
    		EditableDocumentStore,
    		ComponentEditorStore,
    		HighlightedEditor,
    		properties,
    		id,
    		updateEds,
    		$ComponentEditorStore
    	});

    	$$self.$inject_state = $$props => {
    		if ("properties" in $$props) $$invalidate(0, properties = $$props.properties);
    		if ("id" in $$props) $$invalidate(1, id = $$props.id);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [properties, id, updateEds, input_input_handler, func, func_1];
    }

    class ContentTextContainerEditor extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$B, create_fragment$B, safe_not_equal, { properties: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ContentTextContainerEditor",
    			options,
    			id: create_fragment$B.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*properties*/ ctx[0] === undefined && !("properties" in props)) {
    			console_1$k.warn("<ContentTextContainerEditor> was created without expected prop 'properties'");
    		}
    	}

    	get properties() {
    		throw new Error("<ContentTextContainerEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set properties(value) {
    		throw new Error("<ContentTextContainerEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/ContentImageContainer.svelte generated by Svelte v3.38.2 */

    const { console: console_1$j } = globals;
    const file$x = "src/components/ContentImageContainer.svelte";

    // (62:0) {:else}
    function create_else_block$8(ctx) {
    	let div;
    	let t;
    	let div_style_value;
    	let div_class_value;
    	let if_block0 = /*properties*/ ctx[0].globalStyle && create_if_block_4$5(ctx);
    	let if_block1 = /*properties*/ ctx[0].content && create_if_block_3$7(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();

    			attr_dev(div, "style", div_style_value = "background-image: url('" + (/*properties*/ ctx[0].uri
    			? /*properties*/ ctx[0].uri
    			: "") + "'); " + (/*properties*/ ctx[0].style
    			? /*properties*/ ctx[0].style
    			: ""));

    			attr_dev(div, "class", div_class_value = "default-image-container " + (/*properties*/ ctx[0].classes
    			? /*properties*/ ctx[0].classes
    			: "") + " svelte-14yq4u9");

    			add_location(div, file$x, 62, 4, 1745);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t);
    			if (if_block1) if_block1.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (/*properties*/ ctx[0].globalStyle) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_4$5(ctx);
    					if_block0.c();
    					if_block0.m(div, t);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*properties*/ ctx[0].content) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_3$7(ctx);
    					if_block1.c();
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty & /*properties*/ 1 && div_style_value !== (div_style_value = "background-image: url('" + (/*properties*/ ctx[0].uri
    			? /*properties*/ ctx[0].uri
    			: "") + "'); " + (/*properties*/ ctx[0].style
    			? /*properties*/ ctx[0].style
    			: ""))) {
    				attr_dev(div, "style", div_style_value);
    			}

    			if (dirty & /*properties*/ 1 && div_class_value !== (div_class_value = "default-image-container " + (/*properties*/ ctx[0].classes
    			? /*properties*/ ctx[0].classes
    			: "") + " svelte-14yq4u9")) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$8.name,
    		type: "else",
    		source: "(62:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (52:0) {#if isCrossDomain()}
    function create_if_block$l(ctx) {
    	let div;
    	let t0;
    	let img;
    	let img_src_value;
    	let img_alt_value;
    	let t1;
    	let div_style_value;
    	let div_class_value;
    	let if_block0 = /*properties*/ ctx[0].globalStyle && create_if_block_2$b(ctx);
    	let if_block1 = /*properties*/ ctx[0].content && create_if_block_1$g(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			img = element("img");
    			t1 = space();
    			if (if_block1) if_block1.c();
    			set_style(img, "max-height", "100%");
    			set_style(img, "max-width", "100%");

    			if (img.src !== (img_src_value = /*properties*/ ctx[0].uri
    			? /*properties*/ ctx[0].uri
    			: "")) attr_dev(img, "src", img_src_value);

    			attr_dev(img, "crossorigin", "anonymous");

    			attr_dev(img, "alt", img_alt_value = /*properties*/ ctx[0].uri
    			? /*properties*/ ctx[0].uri
    			: "");

    			add_location(img, file$x, 56, 8, 1483);

    			attr_dev(div, "style", div_style_value = /*properties*/ ctx[0].style
    			? /*properties*/ ctx[0].style
    			: "");

    			attr_dev(div, "class", div_class_value = "default-image-container " + (/*properties*/ ctx[0].classes
    			? /*properties*/ ctx[0].classes
    			: "") + " svelte-14yq4u9");

    			add_location(div, file$x, 52, 4, 1198);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			append_dev(div, img);
    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (/*properties*/ ctx[0].globalStyle) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_2$b(ctx);
    					if_block0.c();
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty & /*properties*/ 1 && img.src !== (img_src_value = /*properties*/ ctx[0].uri
    			? /*properties*/ ctx[0].uri
    			: "")) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty & /*properties*/ 1 && img_alt_value !== (img_alt_value = /*properties*/ ctx[0].uri
    			? /*properties*/ ctx[0].uri
    			: "")) {
    				attr_dev(img, "alt", img_alt_value);
    			}

    			if (/*properties*/ ctx[0].content) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_1$g(ctx);
    					if_block1.c();
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty & /*properties*/ 1 && div_style_value !== (div_style_value = /*properties*/ ctx[0].style
    			? /*properties*/ ctx[0].style
    			: "")) {
    				attr_dev(div, "style", div_style_value);
    			}

    			if (dirty & /*properties*/ 1 && div_class_value !== (div_class_value = "default-image-container " + (/*properties*/ ctx[0].classes
    			? /*properties*/ ctx[0].classes
    			: "") + " svelte-14yq4u9")) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$l.name,
    		type: "if",
    		source: "(52:0) {#if isCrossDomain()}",
    		ctx
    	});

    	return block;
    }

    // (65:8) {#if properties.globalStyle}
    function create_if_block_4$5(ctx) {
    	let html_tag;
    	let raw_value = Helpers.styleOpeningLabel + /*properties*/ ctx[0].innerStyle + Helpers.styleClosingLabel + "";
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_anchor = empty$2();
    			html_tag = new HtmlTag(html_anchor);
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(raw_value, target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*properties*/ 1 && raw_value !== (raw_value = Helpers.styleOpeningLabel + /*properties*/ ctx[0].innerStyle + Helpers.styleClosingLabel + "")) html_tag.p(raw_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$5.name,
    		type: "if",
    		source: "(65:8) {#if properties.globalStyle}",
    		ctx
    	});

    	return block;
    }

    // (68:8) {#if properties.content}
    function create_if_block_3$7(ctx) {
    	let html_tag;
    	let raw_value = /*properties*/ ctx[0].content + "";
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_anchor = empty$2();
    			html_tag = new HtmlTag(html_anchor);
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(raw_value, target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*properties*/ 1 && raw_value !== (raw_value = /*properties*/ ctx[0].content + "")) html_tag.p(raw_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$7.name,
    		type: "if",
    		source: "(68:8) {#if properties.content}",
    		ctx
    	});

    	return block;
    }

    // (54:8) {#if properties.globalStyle}
    function create_if_block_2$b(ctx) {
    	let html_tag;
    	let raw_value = Helpers.styleOpeningLabel + /*properties*/ ctx[0].innerStyle + Helpers.styleClosingLabel + "";
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_anchor = empty$2();
    			html_tag = new HtmlTag(html_anchor);
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(raw_value, target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*properties*/ 1 && raw_value !== (raw_value = Helpers.styleOpeningLabel + /*properties*/ ctx[0].innerStyle + Helpers.styleClosingLabel + "")) html_tag.p(raw_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$b.name,
    		type: "if",
    		source: "(54:8) {#if properties.globalStyle}",
    		ctx
    	});

    	return block;
    }

    // (58:8) {#if properties.content}
    function create_if_block_1$g(ctx) {
    	let html_tag;
    	let raw_value = /*properties*/ ctx[0].content + "";
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_anchor = empty$2();
    			html_tag = new HtmlTag(html_anchor);
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(raw_value, target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*properties*/ 1 && raw_value !== (raw_value = /*properties*/ ctx[0].content + "")) html_tag.p(raw_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$g.name,
    		type: "if",
    		source: "(58:8) {#if properties.content}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$A(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*isCrossDomain*/ ctx[1]()) return create_if_block$l;
    		return create_else_block$8;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$2();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if_block.p(ctx, dirty);
    		},
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$A($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ContentImageContainer", slots, []);
    	let { properties } = $$props;

    	onMount(() => {
    		if (!properties.uri) {
    			$$invalidate(0, properties.uri = "", properties);
    			$$invalidate(0, properties);
    		}
    	});

    	afterUpdate(() => {
    		console.log("updated");
    	});

    	function isCrossDomain() {
    		const loc = window.location;
    		const a = document.createElement("a");
    		a.href = properties.uri;
    		console.log(a);
    		console.log(loc);
    		return properties.uri === undefined || a.hostname !== loc.hostname || a.port !== loc.port || a.protocol !== loc.protocol;
    	}

    	const writable_props = ["properties"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$j.warn(`<ContentImageContainer> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("properties" in $$props) $$invalidate(0, properties = $$props.properties);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		afterUpdate,
    		Helpers,
    		properties,
    		isCrossDomain
    	});

    	$$self.$inject_state = $$props => {
    		if ("properties" in $$props) $$invalidate(0, properties = $$props.properties);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [properties, isCrossDomain];
    }

    class ContentImageContainer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$A, create_fragment$A, safe_not_equal, { properties: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ContentImageContainer",
    			options,
    			id: create_fragment$A.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*properties*/ ctx[0] === undefined && !("properties" in props)) {
    			console_1$j.warn("<ContentImageContainer> was created without expected prop 'properties'");
    		}
    	}

    	get properties() {
    		throw new Error("<ContentImageContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set properties(value) {
    		throw new Error("<ContentImageContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Channel/Attachment.svelte generated by Svelte v3.38.2 */

    const { console: console_1$i } = globals;
    const file_1 = "src/components/Channel/Attachment.svelte";

    // (126:0) {#if !error}
    function create_if_block$k(ctx) {
    	let div;

    	function select_block_type(ctx, dirty) {
    		if (/*media*/ ctx[0]) return create_if_block_1$f;
    		return create_else_block_1$2;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "attachment svelte-1mqyqiw");
    			add_location(div, file_1, 126, 4, 4274);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_block.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div, null);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$k.name,
    		type: "if",
    		source: "(126:0) {#if !error}",
    		ctx
    	});

    	return block;
    }

    // (134:8) {:else}
    function create_else_block_1$2(ctx) {
    	let div;
    	let div_id_value;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "id", div_id_value = "loading-" + /*key*/ ctx[1]);
    			attr_dev(div, "class", "attachment-upload spinner-border text-danger");
    			attr_dev(div, "role", "status");
    			attr_dev(div, "title", "Chargement ...");
    			add_location(div, file_1, 134, 12, 4669);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*key*/ 2 && div_id_value !== (div_id_value = "loading-" + /*key*/ ctx[1])) {
    				attr_dev(div, "id", div_id_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$2.name,
    		type: "else",
    		source: "(134:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (128:8) {#if media}
    function create_if_block_1$f(ctx) {
    	let show_if;
    	let if_block_anchor;

    	function select_block_type_1(ctx, dirty) {
    		if (show_if == null || dirty & /*media*/ 1) show_if = !!(/*media*/ ctx[0].mediaType.indexOf("image") >= 0);
    		if (show_if) return create_if_block_2$a;
    		return create_else_block$7;
    	}

    	let current_block_type = select_block_type_1(ctx, -1);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx, dirty)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$f.name,
    		type: "if",
    		source: "(128:8) {#if media}",
    		ctx
    	});

    	return block;
    }

    // (131:12) {:else }
    function create_else_block$7(ctx) {
    	let div;
    	let span;
    	let t_value = /*media*/ ctx[0].label + "";
    	let t;
    	let div_id_value;
    	let div_title_value;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "class", "label svelte-1mqyqiw");
    			add_location(span, file_1, 131, 88, 4576);
    			attr_dev(div, "class", "attachment-download svelte-1mqyqiw");
    			attr_dev(div, "id", div_id_value = /*media*/ ctx[0].key);
    			attr_dev(div, "title", div_title_value = /*media*/ ctx[0].label);
    			add_location(div, file_1, 131, 16, 4504);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*media*/ 1 && t_value !== (t_value = /*media*/ ctx[0].label + "")) set_data_dev(t, t_value);

    			if (dirty & /*media*/ 1 && div_id_value !== (div_id_value = /*media*/ ctx[0].key)) {
    				attr_dev(div, "id", div_id_value);
    			}

    			if (dirty & /*media*/ 1 && div_title_value !== (div_title_value = /*media*/ ctx[0].label)) {
    				attr_dev(div, "title", div_title_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$7.name,
    		type: "else",
    		source: "(131:12) {:else }",
    		ctx
    	});

    	return block;
    }

    // (129:12) {#if media.mediaType.indexOf('image') >= 0}
    function create_if_block_2$a(ctx) {
    	let div;
    	let div_id_value;
    	let div_title_value;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "attachment-image svelte-1mqyqiw");
    			attr_dev(div, "id", div_id_value = /*media*/ ctx[0].key);
    			attr_dev(div, "title", div_title_value = /*media*/ ctx[0].label);
    			add_location(div, file_1, 129, 16, 4391);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*media*/ 1 && div_id_value !== (div_id_value = /*media*/ ctx[0].key)) {
    				attr_dev(div, "id", div_id_value);
    			}

    			if (dirty & /*media*/ 1 && div_title_value !== (div_title_value = /*media*/ ctx[0].label)) {
    				attr_dev(div, "title", div_title_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$a.name,
    		type: "if",
    		source: "(129:12) {#if media.mediaType.indexOf('image') >= 0}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$z(ctx) {
    	let if_block_anchor;
    	let if_block = !/*error*/ ctx[2] && create_if_block$k(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$2();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (!/*error*/ ctx[2]) if_block.p(ctx, dirty);
    		},
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$z($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Attachment", slots, []);
    	let { key } = $$props;
    	let { label } = $$props;
    	let { visibility } = $$props;
    	let { file } = $$props;
    	let { associatedChannel } = $$props;
    	let src = "defaultImageUrl";
    	let { media } = $$props;
    	let error;
    	const { displayError } = globalFEService$1.getService("displayError");
    	console.log(displayError);

    	let icons = {
    		default: "fa-file",
    		"application/pdf": "fa-file-pdf",
    		"audio/mp3": "fa-file-audio",
    		"audio/mpeg": "fa-file-audio",
    		"audio/webm": "fa-file-audio",
    		"audio/ogg": "fa-file-audio",
    		"audio/aac": "fa-file-audio",
    		"audio/wav": "fa-file-audio",
    		"video/webm": "fa-file-video",
    		"video/ogg": "fa-file-video",
    		"video/mp4": "fa-file-video",
    		"video/x-msvideo": "fa-file-video"
    	};

    	onMount(async () => {
    		window.setTimeout(
    			async () => {
    				if (!media && file && !error) {
    					try {
    						const backEndService = await dist$1.getBackendClient();

    						if (!await backEndService.mediaService.mediaExists(key)) {
    							const channel = await backEndService.channelsService.getChannel(associatedChannel);
    							const mediaReaders = [];
    							if (Array.isArray(channel.administrators)) mediaReaders.push(...channel.administrators);
    							if (Array.isArray(channel.editors)) mediaReaders.push(...channel.editors);
    							if (Array.isArray(channel.contributors)) mediaReaders.push(...channel.contributors);
    							if (Array.isArray(channel.readers)) mediaReaders.push(...channel.readers);
    							$$invalidate(0, media = await backEndService.mediaService.createMedia(file, key, label, visibility, [], mediaReaders));
    						}

    						$$invalidate(0, media = await backEndService.mediaService.getMediaMetadata(key));
    					} catch(error) {
    						const loading = document.getElementById(`loading-${key}`);
    						if (loading) loading.parentNode.remove();
    					}
    				}
    			},
    			200
    		);
    	});

    	afterUpdate(async () => {
    		if (media) {
    			const div = document.getElementById(`${media.key}`);

    			if (media.mediaType.indexOf("image") >= 0) {
    				const backEndService = await dist$1.getBackendClient();
    				const localMedia = await backEndService.mediaService.getMedia(key);
    				const localBuffer = new Uint8Array(localMedia.blob.data);
    				const blob = new Blob([localBuffer], { type: media.mediaType });
    				div.style.backgroundImage = `url(${URL.createObjectURL(blob)})`;
    			} else {
    				if (!div.querySelector("i.fas")) {
    					const fileIcon = document.createElement("i");
    					fileIcon.classList.add("fas");
    					fileIcon.classList.add("fa-2x");

    					fileIcon.classList.add(icons[media.mediaType]
    					? icons[media.mediaType]
    					: icons.default);

    					div.prepend(fileIcon);
    				}
    			}
    		} //Do nothing
    	});

    	const writable_props = ["key", "label", "visibility", "file", "associatedChannel", "media"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$i.warn(`<Attachment> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("key" in $$props) $$invalidate(1, key = $$props.key);
    		if ("label" in $$props) $$invalidate(3, label = $$props.label);
    		if ("visibility" in $$props) $$invalidate(4, visibility = $$props.visibility);
    		if ("file" in $$props) $$invalidate(5, file = $$props.file);
    		if ("associatedChannel" in $$props) $$invalidate(6, associatedChannel = $$props.associatedChannel);
    		if ("media" in $$props) $$invalidate(0, media = $$props.media);
    	};

    	$$self.$capture_state = () => ({
    		getBackendClient: dist$1.getBackendClient,
    		afterUpdate,
    		getContext,
    		onMount,
    		FEServices,
    		globalFEService: globalFEService$1,
    		key,
    		label,
    		visibility,
    		file,
    		associatedChannel,
    		src,
    		media,
    		error,
    		displayError,
    		icons
    	});

    	$$self.$inject_state = $$props => {
    		if ("key" in $$props) $$invalidate(1, key = $$props.key);
    		if ("label" in $$props) $$invalidate(3, label = $$props.label);
    		if ("visibility" in $$props) $$invalidate(4, visibility = $$props.visibility);
    		if ("file" in $$props) $$invalidate(5, file = $$props.file);
    		if ("associatedChannel" in $$props) $$invalidate(6, associatedChannel = $$props.associatedChannel);
    		if ("src" in $$props) src = $$props.src;
    		if ("media" in $$props) $$invalidate(0, media = $$props.media);
    		if ("error" in $$props) $$invalidate(2, error = $$props.error);
    		if ("icons" in $$props) icons = $$props.icons;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [media, key, error, label, visibility, file, associatedChannel];
    }

    class Attachment extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$z, create_fragment$z, safe_not_equal, {
    			key: 1,
    			label: 3,
    			visibility: 4,
    			file: 5,
    			associatedChannel: 6,
    			media: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Attachment",
    			options,
    			id: create_fragment$z.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*key*/ ctx[1] === undefined && !("key" in props)) {
    			console_1$i.warn("<Attachment> was created without expected prop 'key'");
    		}

    		if (/*label*/ ctx[3] === undefined && !("label" in props)) {
    			console_1$i.warn("<Attachment> was created without expected prop 'label'");
    		}

    		if (/*visibility*/ ctx[4] === undefined && !("visibility" in props)) {
    			console_1$i.warn("<Attachment> was created without expected prop 'visibility'");
    		}

    		if (/*file*/ ctx[5] === undefined && !("file" in props)) {
    			console_1$i.warn("<Attachment> was created without expected prop 'file'");
    		}

    		if (/*associatedChannel*/ ctx[6] === undefined && !("associatedChannel" in props)) {
    			console_1$i.warn("<Attachment> was created without expected prop 'associatedChannel'");
    		}

    		if (/*media*/ ctx[0] === undefined && !("media" in props)) {
    			console_1$i.warn("<Attachment> was created without expected prop 'media'");
    		}
    	}

    	get key() {
    		throw new Error("<Attachment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set key(value) {
    		throw new Error("<Attachment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<Attachment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<Attachment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get visibility() {
    		throw new Error("<Attachment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set visibility(value) {
    		throw new Error("<Attachment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get file() {
    		throw new Error("<Attachment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set file(value) {
    		throw new Error("<Attachment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get associatedChannel() {
    		throw new Error("<Attachment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set associatedChannel(value) {
    		throw new Error("<Attachment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get media() {
    		throw new Error("<Attachment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set media(value) {
    		throw new Error("<Attachment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Channel/PostEditor.svelte generated by Svelte v3.38.2 */

    const { console: console_1$h } = globals;
    const file$w = "src/components/Channel/PostEditor.svelte";

    function get_each_context$i(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	return child_ctx;
    }

    // (208:8) {#each attachments as attachment}
    function create_each_block$i(ctx) {
    	let attachmentatcreation;
    	let current;

    	attachmentatcreation = new Attachment({
    			props: {
    				visibility: /*attachment*/ ctx[8].visibility,
    				key: /*attachment*/ ctx[8].key,
    				label: /*attachment*/ ctx[8].label,
    				file: /*attachment*/ ctx[8].file,
    				associatedChannel: /*channelKey*/ ctx[0]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(attachmentatcreation.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(attachmentatcreation, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const attachmentatcreation_changes = {};
    			if (dirty & /*attachments*/ 4) attachmentatcreation_changes.visibility = /*attachment*/ ctx[8].visibility;
    			if (dirty & /*attachments*/ 4) attachmentatcreation_changes.key = /*attachment*/ ctx[8].key;
    			if (dirty & /*attachments*/ 4) attachmentatcreation_changes.label = /*attachment*/ ctx[8].label;
    			if (dirty & /*attachments*/ 4) attachmentatcreation_changes.file = /*attachment*/ ctx[8].file;
    			if (dirty & /*channelKey*/ 1) attachmentatcreation_changes.associatedChannel = /*channelKey*/ ctx[0];
    			attachmentatcreation.$set(attachmentatcreation_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(attachmentatcreation.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(attachmentatcreation.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(attachmentatcreation, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$i.name,
    		type: "each",
    		source: "(208:8) {#each attachments as attachment}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$y(ctx) {
    	let div2;
    	let div0;
    	let t;
    	let div1;
    	let current;
    	let each_value = /*attachments*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$i(get_each_context$i(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			t = space();
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "id", /*targetId*/ ctx[1]);
    			attr_dev(div0, "class", "svelte-1e9128j");
    			add_location(div0, file$w, 202, 4, 9186);
    			attr_dev(div1, "class", "attachments svelte-1e9128j");
    			add_location(div1, file$w, 206, 4, 9225);
    			attr_dev(div2, "class", "post-creation svelte-1e9128j");
    			add_location(div2, file$w, 200, 0, 9153);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div2, t);
    			append_dev(div2, div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*targetId*/ 2) {
    				attr_dev(div0, "id", /*targetId*/ ctx[1]);
    			}

    			if (dirty & /*attachments, channelKey*/ 5) {
    				each_value = /*attachments*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$i(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$i(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div1, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$y($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("PostEditor", slots, []);
    	let { channelKey } = $$props;
    	let { parentPost } = $$props;
    	let { targetId } = $$props;
    	let attachments = [];
    	const authorizedMimeTypes = dist$1.MediaService.AuthorizedMimeTypes;

    	async function customPaste(file, label) {
    		const backEndService = await dist$1.getBackendClient();
    		const keyAndLabel = v4();
    		const channel = await backEndService.channelsService.getChannel(channelKey);

    		attachments.push({
    			key: keyAndLabel,
    			label: label ? label : keyAndLabel,
    			visibility: channel.visibility,
    			file,
    			uploaded: false
    		});

    		$$invalidate(2, attachments);
    	}

    	const scanText = _.debounce(
    		() => {
    			console.log("scanning text ...");
    			const messageContent = document.querySelector(".cl-content");
    			const urlRegexp = /(https*?:\/\/[^\s<>"]+)/g;
    			const urlGroups = messageContent.innerHTML.match(urlRegexp);

    			if (Array.isArray(urlGroups)) {
    				for (const u of urlGroups) {
    					messageContent.innerHTML = messageContent.innerHTML.replace(u, `<a data-link="true" href="${u.trim()}" target="_blank">${u.trim()}</a>`);
    				}
    			}
    		},
    		1000,
    		false
    	);

    	async function pasteEventHandler(event) {
    		event.preventDefault();
    		event.stopPropagation();

    		for (const i of event.clipboardData.items) {
    			if (i.kind === "file") {
    				const f = i.getAsFile();
    				await customPaste(f);
    			} else if (i.kind === "string") {
    				let paste = (event.clipboardData || window.clipboardData).getData("text");
    				const selection = window.getSelection();
    				if (!selection.rangeCount) return false;
    				const urlRegexp = /^(https*?:\/\/[^\s]+$)/g;
    				const urlGroups = paste.match(urlRegexp);

    				if (Array.isArray(urlGroups)) {
    					for (const u of urlGroups) {
    						const d = document.createElement("div");
    						d.innerHTML = `<a data-link="true" href="${u.trim()}" target="_blank">${u.trim()}</a>`;
    						selection.deleteFromDocument();
    						selection.getRangeAt(0).insertNode(d.firstChild);
    						selection.collapseToEnd();
    					}
    				} else {
    					selection.deleteFromDocument();
    					selection.getRangeAt(0).insertNode(document.createTextNode(paste));
    					selection.collapseToEnd();
    				}
    			}
    		}
    	}

    	afterUpdate(() => {
    		window.setTimeout(
    			() => {
    				if (targetId) {
    					const messageContent = document.getElementById(targetId);

    					if (messageContent.childElementCount === 0) {
    						messageContent.addEventListener("paste", pasteEventHandler, true);

    						let editor = new Editor({
    								target: messageContent,
    								props: {
    									height: "54px",
    									actions: [
    										"b",
    										"i",
    										"u",
    										"strike",
    										"ul",
    										"ol",
    										"viewHtml",
    										{
    											name: "paste",
    											icon: "<i class=\"fas fa-paste\"></i>",
    											title: "Coller",
    											result: async () => {
    												const read = await navigator.clipboard.read();

    												if (read && read.length > 0) {
    													const item = read[0];

    													if (Array.isArray(item.types) && item.types.length > 0) {
    														const type = item.types[0];
    														console.log(type);
    														const blob = await item.getType(type);

    														if (type.indexOf("image") >= 0) {
    															const file = new File([blob], "image");
    															await customPaste(file);
    														} else if (type.indexOf("text") >= 0) {
    															const reader = new FileReader();

    															reader.onload = e => {
    																const content = messageContent.querySelector(".cl-content");
    																content.append(reader.result.toString());
    																content.focus();
    																document.execCommand("selectAll", false, null);
    																document.getSelection().collapseToEnd();
    																content.scrollTop = content.scrollHeight;
    															};

    															reader.readAsText(blob);
    														}
    													}
    												}
    											}
    										},
    										{
    											name: "attach",
    											icon: "<i class=\"fas fa-paperclip\"></i>",
    											title: "Ajouter une pièce jointe",
    											result: async () => {
    												const input = document.createElement("input");
    												input.type = "file";
    												input.accept = authorizedMimeTypes.join(",");

    												input.onchange = e => {
    													if (input.files) {
    														for (const file of input.files) {
    															customPaste(file, file.name);
    														}
    													}
    												};

    												input.click();
    											}
    										}
    									]
    								}
    							});

    						messageContent.addEventListener("keyup", async event => {
    							const backEndService = await dist$1.getBackendClient();

    							if (event.key === "Enter") {
    								event.preventDefault();
    								event.stopPropagation();

    								if (!event.ctrlKey) {
    									if (!document.querySelectorAll(".attachment-upload").length) {
    										messageContent.querySelector("br")?.remove();
    										await backEndService.postService.createPost(channelKey, editor.getHtml(false), attachments, parentPost);
    										editor.setHtml("");
    										$$invalidate(2, attachments = []);
    									}
    								} else {
    									window.setTimeout(
    										() => {
    											const carriageReturn = document.createElement("div");
    											carriageReturn.innerHTML = "<br>";
    											const content = messageContent.querySelector(".cl-content");
    											content.append(carriageReturn);
    											content.focus();
    											document.execCommand("selectAll", false, null);
    											document.getSelection().collapseToEnd();
    											content.scrollTop = content.scrollHeight;
    										},
    										150
    									);
    								}
    							}
    						});
    					}
    				}
    			},
    			150
    		);
    	});

    	const writable_props = ["channelKey", "parentPost", "targetId"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$h.warn(`<PostEditor> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("channelKey" in $$props) $$invalidate(0, channelKey = $$props.channelKey);
    		if ("parentPost" in $$props) $$invalidate(3, parentPost = $$props.parentPost);
    		if ("targetId" in $$props) $$invalidate(1, targetId = $$props.targetId);
    	};

    	$$self.$capture_state = () => ({
    		Editor,
    		afterUpdate,
    		onMount,
    		getBackendClient: dist$1.getBackendClient,
    		uuid,
    		AttachmentAtCreation: Attachment,
    		_,
    		MediaService: dist$1.MediaService,
    		channelKey,
    		parentPost,
    		targetId,
    		attachments,
    		authorizedMimeTypes,
    		customPaste,
    		scanText,
    		pasteEventHandler
    	});

    	$$self.$inject_state = $$props => {
    		if ("channelKey" in $$props) $$invalidate(0, channelKey = $$props.channelKey);
    		if ("parentPost" in $$props) $$invalidate(3, parentPost = $$props.parentPost);
    		if ("targetId" in $$props) $$invalidate(1, targetId = $$props.targetId);
    		if ("attachments" in $$props) $$invalidate(2, attachments = $$props.attachments);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [channelKey, targetId, attachments, parentPost];
    }

    class PostEditor extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$y, create_fragment$y, safe_not_equal, {
    			channelKey: 0,
    			parentPost: 3,
    			targetId: 1
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PostEditor",
    			options,
    			id: create_fragment$y.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*channelKey*/ ctx[0] === undefined && !("channelKey" in props)) {
    			console_1$h.warn("<PostEditor> was created without expected prop 'channelKey'");
    		}

    		if (/*parentPost*/ ctx[3] === undefined && !("parentPost" in props)) {
    			console_1$h.warn("<PostEditor> was created without expected prop 'parentPost'");
    		}

    		if (/*targetId*/ ctx[1] === undefined && !("targetId" in props)) {
    			console_1$h.warn("<PostEditor> was created without expected prop 'targetId'");
    		}
    	}

    	get channelKey() {
    		throw new Error("<PostEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set channelKey(value) {
    		throw new Error("<PostEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get parentPost() {
    		throw new Error("<PostEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set parentPost(value) {
    		throw new Error("<PostEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get targetId() {
    		throw new Error("<PostEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set targetId(value) {
    		throw new Error("<PostEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    class PostWithChildren {
        constructor() {
            this.posts = [];
        }
    }

    function cubicOut(t) {
        const f = t - 1.0;
        return f * f * f + 1.0;
    }

    function fade(node, { delay = 0, duration = 400, easing = identity$1 } = {}) {
        const o = +getComputedStyle(node).opacity;
        return {
            delay,
            duration,
            easing,
            css: t => `opacity: ${t * o}`
        };
    }
    function fly(node, { delay = 0, duration = 400, easing = cubicOut, x = 0, y = 0, opacity = 0 } = {}) {
        const style = getComputedStyle(node);
        const target_opacity = +style.opacity;
        const transform = style.transform === 'none' ? '' : style.transform;
        const od = target_opacity * (1 - opacity);
        return {
            delay,
            duration,
            easing,
            css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * x}px, ${(1 - t) * y}px);
			opacity: ${target_opacity - (od * u)}`
        };
    }
    function slide(node, { delay = 0, duration = 400, easing = cubicOut } = {}) {
        const style = getComputedStyle(node);
        const opacity = +style.opacity;
        const height = parseFloat(style.height);
        const padding_top = parseFloat(style.paddingTop);
        const padding_bottom = parseFloat(style.paddingBottom);
        const margin_top = parseFloat(style.marginTop);
        const margin_bottom = parseFloat(style.marginBottom);
        const border_top_width = parseFloat(style.borderTopWidth);
        const border_bottom_width = parseFloat(style.borderBottomWidth);
        return {
            delay,
            duration,
            easing,
            css: t => 'overflow: hidden;' +
                `opacity: ${Math.min(t * 20, 1) * opacity};` +
                `height: ${t * height}px;` +
                `padding-top: ${t * padding_top}px;` +
                `padding-bottom: ${t * padding_bottom}px;` +
                `margin-top: ${t * margin_top}px;` +
                `margin-bottom: ${t * margin_bottom}px;` +
                `border-top-width: ${t * border_top_width}px;` +
                `border-bottom-width: ${t * border_bottom_width}px;`
        };
    }

    /* src/components/Channel/Post.svelte generated by Svelte v3.38.2 */
    const file$v = "src/components/Channel/Post.svelte";

    function get_each_context$h(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    // (123:8) {#if typeof post.parentPost !== 'number'}
    function create_if_block_2$9(ctx) {
    	let div1;
    	let div0;
    	let i;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			i = element("i");
    			attr_dev(i, "class", "fa fa-comment-lines");
    			add_location(i, file$v, 125, 20, 3796);
    			attr_dev(div0, "class", "post-action svelte-nr6zru");
    			attr_dev(div0, "title", "Montrer les réponses");
    			add_location(div0, file$v, 124, 16, 3696);
    			attr_dev(div1, "class", "post-actions svelte-nr6zru");
    			add_location(div1, file$v, 123, 12, 3653);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, i);

    			if (!mounted) {
    				dispose = listen_dev(div0, "click", /*onAnswerClick*/ ctx[1], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$9.name,
    		type: "if",
    		source: "(123:8) {#if typeof post.parentPost !== 'number'}",
    		ctx
    	});

    	return block;
    }

    // (161:8) {#if Array.isArray(post.attachments) && post.attachments.length > 0}
    function create_if_block_1$e(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*post*/ ctx[0].attachments;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$h(get_each_context$h(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*Helpers, post*/ 1) {
    				each_value = /*post*/ ctx[0].attachments;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$h(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$h(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$e.name,
    		type: "if",
    		source: "(161:8) {#if Array.isArray(post.attachments) && post.attachments.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (162:12) {#each post.attachments as attachmentKey}
    function create_each_block$h(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Helpers.getAttachmentComponent(/*attachmentKey*/ ctx[4].mediaType);

    	function switch_props(ctx) {
    		return {
    			props: { attachment: /*attachmentKey*/ ctx[4].key },
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty & /*post*/ 1) switch_instance_changes.attachment = /*attachmentKey*/ ctx[4].key;

    			if (switch_value !== (switch_value = Helpers.getAttachmentComponent(/*attachmentKey*/ ctx[4].mediaType))) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$h.name,
    		type: "each",
    		source: "(162:12) {#each post.attachments as attachmentKey}",
    		ctx
    	});

    	return block;
    }

    // (167:12) {#if post.answerCount}
    function create_if_block$j(ctx) {
    	let div;
    	let span;
    	let t0_value = /*post*/ ctx[0].answerCount + "";
    	let t0;
    	let t1;
    	let i;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			i = element("i");
    			add_location(span, file$v, 168, 20, 5176);
    			attr_dev(i, "class", "fas fa-comment-lines");
    			add_location(i, file$v, 169, 20, 5228);
    			attr_dev(div, "class", "metadata svelte-nr6zru");
    			attr_dev(div, "title", "Nombre de réponses");
    			add_location(div, file$v, 167, 16, 5106);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);
    			append_dev(span, t0);
    			append_dev(div, t1);
    			append_dev(div, i);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*post*/ 1 && t0_value !== (t0_value = /*post*/ ctx[0].answerCount + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$j.name,
    		type: "if",
    		source: "(167:12) {#if post.answerCount}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$x(ctx) {
    	let div4;
    	let div0;
    	let i;
    	let t0;
    	let span;
    	let t1_value = /*post*/ ctx[0].author.login + "";
    	let t1;
    	let t2;
    	let div3;
    	let t3;
    	let style;
    	let t5;
    	let div1;
    	let t6_value = new Date(/*post*/ ctx[0].creationDate).toLocaleDateString() + "";
    	let t6;
    	let t7;
    	let t8_value = new Date(/*post*/ ctx[0].creationDate).toLocaleTimeString() + "";
    	let t8;
    	let t9;
    	let html_tag;
    	let raw_value = createHtmlContent(/*post*/ ctx[0].content) + "";
    	let t10;
    	let show_if = Array.isArray(/*post*/ ctx[0].attachments) && /*post*/ ctx[0].attachments.length > 0;
    	let t11;
    	let div2;
    	let div4_id_value;
    	let div4_intro;
    	let current;
    	let if_block0 = typeof /*post*/ ctx[0].parentPost !== "number" && create_if_block_2$9(ctx);
    	let if_block1 = show_if && create_if_block_1$e(ctx);
    	let if_block2 = /*post*/ ctx[0].answerCount && create_if_block$j(ctx);

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div0 = element("div");
    			i = element("i");
    			t0 = space();
    			span = element("span");
    			t1 = text(t1_value);
    			t2 = space();
    			div3 = element("div");
    			if (if_block0) if_block0.c();
    			t3 = space();
    			style = element("style");
    			style.textContent = ".postContent h1 {\n                text-align: start;\n                font-size: 25px;\n            }\n\n            div {\n                text-align: start;\n            }\n\n            .link-preview {\n                display: flex;\n            }\n\n            .link-preview > div {\n                display: flex;\n                flex-direction: column;\n                justify-content: center;\n                align-items: flex-start;\n            }\n\n            .link-preview img {\n                max-width: 25%;\n                margin-right: 15px;\n                width: auto;\n                height: auto;\n            }";
    			t5 = space();
    			div1 = element("div");
    			t6 = text(t6_value);
    			t7 = space();
    			t8 = text(t8_value);
    			t9 = space();
    			t10 = space();
    			if (if_block1) if_block1.c();
    			t11 = space();
    			div2 = element("div");
    			if (if_block2) if_block2.c();
    			attr_dev(i, "class", "fas fa-user-circle fa-3x svelte-nr6zru");
    			add_location(i, file$v, 118, 8, 3468);
    			add_location(span, file$v, 119, 8, 3517);
    			attr_dev(div0, "class", "author svelte-nr6zru");
    			add_location(div0, file$v, 117, 4, 3439);
    			add_location(style, file$v, 129, 8, 3896);
    			attr_dev(div1, "class", "svelte-nr6zru");
    			add_location(div1, file$v, 158, 8, 4560);
    			html_tag = new HtmlTag(t10);
    			attr_dev(div2, "class", "postMetadata svelte-nr6zru");
    			add_location(div2, file$v, 165, 8, 5028);
    			attr_dev(div3, "class", "postContent svelte-nr6zru");
    			add_location(div3, file$v, 121, 4, 3565);

    			attr_dev(div4, "id", div4_id_value = /*post*/ ctx[0] && typeof /*post*/ ctx[0].id === "number"
    			? `post-${/*post*/ ctx[0].id}`
    			: null);

    			attr_dev(div4, "class", "post svelte-nr6zru");
    			toggle_class(div4, "new-post", /*post*/ ctx[0].isNew);
    			add_location(div4, file$v, 116, 0, 3312);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div0);
    			append_dev(div0, i);
    			append_dev(div0, t0);
    			append_dev(div0, span);
    			append_dev(span, t1);
    			append_dev(div4, t2);
    			append_dev(div4, div3);
    			if (if_block0) if_block0.m(div3, null);
    			append_dev(div3, t3);
    			append_dev(div3, style);
    			append_dev(div3, t5);
    			append_dev(div3, div1);
    			append_dev(div1, t6);
    			append_dev(div1, t7);
    			append_dev(div1, t8);
    			append_dev(div3, t9);
    			html_tag.m(raw_value, div3);
    			append_dev(div3, t10);
    			if (if_block1) if_block1.m(div3, null);
    			append_dev(div3, t11);
    			append_dev(div3, div2);
    			if (if_block2) if_block2.m(div2, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*post*/ 1) && t1_value !== (t1_value = /*post*/ ctx[0].author.login + "")) set_data_dev(t1, t1_value);

    			if (typeof /*post*/ ctx[0].parentPost !== "number") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_2$9(ctx);
    					if_block0.c();
    					if_block0.m(div3, t3);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if ((!current || dirty & /*post*/ 1) && t6_value !== (t6_value = new Date(/*post*/ ctx[0].creationDate).toLocaleDateString() + "")) set_data_dev(t6, t6_value);
    			if ((!current || dirty & /*post*/ 1) && t8_value !== (t8_value = new Date(/*post*/ ctx[0].creationDate).toLocaleTimeString() + "")) set_data_dev(t8, t8_value);
    			if ((!current || dirty & /*post*/ 1) && raw_value !== (raw_value = createHtmlContent(/*post*/ ctx[0].content) + "")) html_tag.p(raw_value);
    			if (dirty & /*post*/ 1) show_if = Array.isArray(/*post*/ ctx[0].attachments) && /*post*/ ctx[0].attachments.length > 0;

    			if (show_if) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*post*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_1$e(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div3, t11);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*post*/ ctx[0].answerCount) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block$j(ctx);
    					if_block2.c();
    					if_block2.m(div2, null);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (!current || dirty & /*post*/ 1 && div4_id_value !== (div4_id_value = /*post*/ ctx[0] && typeof /*post*/ ctx[0].id === "number"
    			? `post-${/*post*/ ctx[0].id}`
    			: null)) {
    				attr_dev(div4, "id", div4_id_value);
    			}

    			if (dirty & /*post*/ 1) {
    				toggle_class(div4, "new-post", /*post*/ ctx[0].isNew);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);

    			if (!div4_intro) {
    				add_render_callback(() => {
    					div4_intro = create_in_transition(div4, fade, {});
    					div4_intro.start();
    				});
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function createHtmlContent(content) {
    	const element = document.createElement("div");
    	element.innerHTML = content;
    	return element.outerHTML;
    }

    function instance$x($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Post", slots, []);
    	let { post } = $$props;
    	const dispatch = createEventDispatcher();

    	afterUpdate(() => {
    		window.setTimeout(
    			() => {
    				if (post && typeof post.id === "number") {
    					const postView = document.getElementById(`post-${post.id}`);
    					const tempCache = globalFEService$1.getService("TempCache");

    					if (postView) {
    						const webThumbnails = postView.querySelectorAll("a[data-link=true]");

    						for (const link of webThumbnails) {
    							const setInnerLink = () => {
    								const newInnerHTML = tempCache.get(link.getAttribute("href"));

    								if (newInnerHTML) {
    									link.innerHTML = newInnerHTML;
    								}
    							};

    							window.setTimeout(setInnerLink, 500);
    						}
    					}
    				}
    			},
    			100
    		);
    	});

    	let mouseHover = false;

    	async function onAnswerClick(event) {
    		const postWithChildren = new PostWithChildren();
    		postWithChildren.parentPost = post;
    		$$invalidate(0, post.isNew = false, post);
    		const backendClient = await getBackendClient();
    		const children = await backendClient.channelsService.getChildrenPosts(post.channelKey, post.id);

    		for (const p of children) {
    			if (p.content) {
    				await Helpers.preloadContentPreview(p.content);
    			}

    			if (Array.isArray(p.attachments) && p.attachments.length > 0) {
    				const attachmentsMetadata = [];

    				for (const a of p.attachments) {
    					const m = await backendClient.mediaService.getMediaMetadata(a);
    					attachmentsMetadata.push(m);
    				}

    				p.attachments = attachmentsMetadata;
    			}
    		}

    		postWithChildren.posts = children;
    		dispatch("answer-clicked", postWithChildren);
    	}

    	const writable_props = ["post"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Post> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("post" in $$props) $$invalidate(0, post = $$props.post);
    	};

    	$$self.$capture_state = () => ({
    		afterUpdate,
    		createEventDispatcher,
    		globalFEService: globalFEService$1,
    		PostWithChildren,
    		Helpers,
    		fade,
    		post,
    		dispatch,
    		createHtmlContent,
    		mouseHover,
    		onAnswerClick
    	});

    	$$self.$inject_state = $$props => {
    		if ("post" in $$props) $$invalidate(0, post = $$props.post);
    		if ("mouseHover" in $$props) mouseHover = $$props.mouseHover;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [post, onAnswerClick];
    }

    class Post extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$x, create_fragment$x, safe_not_equal, { post: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Post",
    			options,
    			id: create_fragment$x.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*post*/ ctx[0] === undefined && !("post" in props)) {
    			console.warn("<Post> was created without expected prop 'post'");
    		}
    	}

    	get post() {
    		throw new Error("<Post>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set post(value) {
    		throw new Error("<Post>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Channel/ContentChannelContainer.svelte generated by Svelte v3.38.2 */

    const { console: console_1$g } = globals;
    const file$u = "src/components/Channel/ContentChannelContainer.svelte";

    function get_each_context$g(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[18] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[18] = list[i];
    	return child_ctx;
    }

    // (455:0) {:else}
    function create_else_block$6(ctx) {
    	let div;
    	let t;
    	let div_style_value;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text("No Channel");

    			attr_dev(div, "style", div_style_value = /*properties*/ ctx[1].style
    			? /*properties*/ ctx[1].style
    			: "");

    			add_location(div, file$u, 455, 4, 18363);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*properties*/ 2 && div_style_value !== (div_style_value = /*properties*/ ctx[1].style
    			? /*properties*/ ctx[1].style
    			: "")) {
    				attr_dev(div, "style", div_style_value);
    			}
    		},
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$6.name,
    		type: "else",
    		source: "(455:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (382:0) {#if $observableChannelCache[properties.channelKey]}
    function create_if_block$i(ctx) {
    	let div4;
    	let div2;
    	let div0;
    	let t0;
    	let div1;
    	let t1;
    	let div3;
    	let current_block_type_index;
    	let if_block1;
    	let t2;
    	let div3_id_value;
    	let t3;
    	let div4_id_value;
    	let div4_style_value;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*$observableChannelCache*/ ctx[2][/*properties*/ ctx[1].channelKey].channel && /*$observableChannelCache*/ ctx[2][/*properties*/ ctx[1].channelKey].channel.label && create_if_block_8$1(ctx);
    	const if_block_creators = [create_if_block_5$3, create_if_block_7$2];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*$observableChannelCache*/ ctx[2][/*properties*/ ctx[1].channelKey] && /*$observableChannelCache*/ ctx[2][/*properties*/ ctx[1].channelKey].channel && /*$observableChannelCache*/ ctx[2][/*properties*/ ctx[1].channelKey].channel.isReader) return 0;
    		if (/*$observableChannelCache*/ ctx[2][/*properties*/ ctx[1].channelKey] && /*$observableChannelCache*/ ctx[2][/*properties*/ ctx[1].channelKey].channel && !/*$observableChannelCache*/ ctx[2][/*properties*/ ctx[1].channelKey].channel.isReader) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type_1(ctx))) {
    		if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	let if_block2 = /*$observableChannelCache*/ ctx[2][/*properties*/ ctx[1].channelKey].channel && !/*$observableChannelCache*/ ctx[2][/*properties*/ ctx[1].channelKey].notAuthorized && /*$observableChannelCache*/ ctx[2][/*properties*/ ctx[1].channelKey].channel.isContributor && create_if_block_4$4(ctx);
    	let if_block3 = /*$observableChannelCache*/ ctx[2][/*properties*/ ctx[1].channelKey].channel && /*ActivePost*/ ctx[0] && /*ActivePost*/ ctx[0].parentPost && create_if_block_1$d(ctx);

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div1 = element("div");
    			t1 = space();
    			div3 = element("div");
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (if_block2) if_block2.c();
    			t3 = space();
    			if (if_block3) if_block3.c();
    			attr_dev(div0, "class", "channelHeader svelte-uvfjha");
    			add_location(div0, file$u, 384, 12, 14420);
    			attr_dev(div1, "id", "test");
    			add_location(div1, file$u, 393, 12, 15018);
    			attr_dev(div2, "class", "channelInfo svelte-uvfjha");
    			add_location(div2, file$u, 383, 8, 14382);
    			attr_dev(div3, "class", "channelContent svelte-uvfjha");
    			attr_dev(div3, "id", div3_id_value = "current-posts-for-" + /*properties*/ ctx[1].channelKey);
    			add_location(div3, file$u, 395, 8, 15063);
    			attr_dev(div4, "id", div4_id_value = `channel-${/*properties*/ ctx[1].channelKey}`);
    			attr_dev(div4, "class", "channel svelte-uvfjha");

    			attr_dev(div4, "style", div4_style_value = /*properties*/ ctx[1].style
    			? /*properties*/ ctx[1].style
    			: "");

    			add_location(div4, file$u, 382, 4, 14265);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div2);
    			append_dev(div2, div0);
    			if (if_block0) if_block0.m(div0, null);
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			append_dev(div4, t1);
    			append_dev(div4, div3);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(div3, null);
    			}

    			append_dev(div3, t2);
    			if (if_block2) if_block2.m(div3, null);
    			append_dev(div4, t3);
    			if (if_block3) if_block3.m(div4, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div3, "scroll", /*onScrollForCurrentChannel*/ ctx[6], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*$observableChannelCache*/ ctx[2][/*properties*/ ctx[1].channelKey].channel && /*$observableChannelCache*/ ctx[2][/*properties*/ ctx[1].channelKey].channel.label) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_8$1(ctx);
    					if_block0.c();
    					if_block0.m(div0, null);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block1) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block1 = if_blocks[current_block_type_index];

    					if (!if_block1) {
    						if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block1.c();
    					} else {
    						if_block1.p(ctx, dirty);
    					}

    					transition_in(if_block1, 1);
    					if_block1.m(div3, t2);
    				} else {
    					if_block1 = null;
    				}
    			}

    			if (/*$observableChannelCache*/ ctx[2][/*properties*/ ctx[1].channelKey].channel && !/*$observableChannelCache*/ ctx[2][/*properties*/ ctx[1].channelKey].notAuthorized && /*$observableChannelCache*/ ctx[2][/*properties*/ ctx[1].channelKey].channel.isContributor) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*$observableChannelCache, properties*/ 6) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_4$4(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div3, null);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*properties*/ 2 && div3_id_value !== (div3_id_value = "current-posts-for-" + /*properties*/ ctx[1].channelKey)) {
    				attr_dev(div3, "id", div3_id_value);
    			}

    			if (/*$observableChannelCache*/ ctx[2][/*properties*/ ctx[1].channelKey].channel && /*ActivePost*/ ctx[0] && /*ActivePost*/ ctx[0].parentPost) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty & /*$observableChannelCache, properties, ActivePost*/ 7) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_1$d(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div4, null);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*properties*/ 2 && div4_id_value !== (div4_id_value = `channel-${/*properties*/ ctx[1].channelKey}`)) {
    				attr_dev(div4, "id", div4_id_value);
    			}

    			if (!current || dirty & /*properties*/ 2 && div4_style_value !== (div4_style_value = /*properties*/ ctx[1].style
    			? /*properties*/ ctx[1].style
    			: "")) {
    				attr_dev(div4, "style", div4_style_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			if (if_block0) if_block0.d();

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d();
    			}

    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$i.name,
    		type: "if",
    		source: "(382:0) {#if $observableChannelCache[properties.channelKey]}",
    		ctx
    	});

    	return block;
    }

    // (386:16) {#if $observableChannelCache[properties.channelKey].channel && $observableChannelCache[properties.channelKey].channel.label}
    function create_if_block_8$1(ctx) {
    	let strong;
    	let h6;
    	let t0_value = /*$observableChannelCache*/ ctx[2][/*properties*/ ctx[1].channelKey].channel.label + "";
    	let t0;
    	let t1;
    	let div;
    	let span0;
    	let t2;
    	let t3_value = /*properties*/ ctx[1].channelKey + "";
    	let t3;
    	let t4;
    	let span1;
    	let t5;
    	let span1_id_value;

    	const block = {
    		c: function create() {
    			strong = element("strong");
    			h6 = element("h6");
    			t0 = text(t0_value);
    			t1 = space();
    			div = element("div");
    			span0 = element("span");
    			t2 = text("#");
    			t3 = text(t3_value);
    			t4 = space();
    			span1 = element("span");
    			t5 = text("Nouveau message !");
    			add_location(h6, file$u, 386, 28, 14617);
    			add_location(strong, file$u, 386, 20, 14609);
    			add_location(span0, file$u, 388, 24, 14748);
    			attr_dev(span1, "id", span1_id_value = "new-message-for-" + /*properties*/ ctx[1].channelKey);
    			attr_dev(span1, "class", "new-label " + (/*isThereNewMessage*/ ctx[7]() ? "" : "hidden") + " svelte-uvfjha");
    			add_location(span1, file$u, 389, 24, 14810);
    			add_location(div, file$u, 387, 20, 14718);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, strong, anchor);
    			append_dev(strong, h6);
    			append_dev(h6, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, span0);
    			append_dev(span0, t2);
    			append_dev(span0, t3);
    			append_dev(div, t4);
    			append_dev(div, span1);
    			append_dev(span1, t5);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$observableChannelCache, properties*/ 6 && t0_value !== (t0_value = /*$observableChannelCache*/ ctx[2][/*properties*/ ctx[1].channelKey].channel.label + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*properties*/ 2 && t3_value !== (t3_value = /*properties*/ ctx[1].channelKey + "")) set_data_dev(t3, t3_value);

    			if (dirty & /*properties*/ 2 && span1_id_value !== (span1_id_value = "new-message-for-" + /*properties*/ ctx[1].channelKey)) {
    				attr_dev(span1, "id", span1_id_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(strong);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8$1.name,
    		type: "if",
    		source: "(386:16) {#if $observableChannelCache[properties.channelKey].channel && $observableChannelCache[properties.channelKey].channel.label}",
    		ctx
    	});

    	return block;
    }

    // (409:77) 
    function create_if_block_7$2(ctx) {
    	let div1;
    	let i;
    	let t0;
    	let div0;
    	let t1;
    	let br;
    	let t2;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			i = element("i");
    			t0 = space();
    			div0 = element("div");
    			t1 = text("Ceci est un canal privé ou protégé");
    			br = element("br");
    			t2 = text("\n                        veuillez en demander l'accès à son administrateur");
    			attr_dev(i, "class", "fas fa-10x fa-eye-slash");
    			add_location(i, file$u, 410, 20, 16022);
    			add_location(br, file$u, 412, 58, 16175);
    			attr_dev(div0, "class", "hidden-channel-label");
    			add_location(div0, file$u, 411, 20, 16082);
    			attr_dev(div1, "class", "hidden-channel svelte-uvfjha");
    			add_location(div1, file$u, 409, 16, 15972);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, i);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			append_dev(div0, t1);
    			append_dev(div0, br);
    			append_dev(div0, t2);
    		},
    		p: noop$2,
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$2.name,
    		type: "if",
    		source: "(409:77) ",
    		ctx
    	});

    	return block;
    }

    // (397:12) {#if $observableChannelCache[properties.channelKey] &&             $observableChannelCache[properties.channelKey].channel &&             $observableChannelCache[properties.channelKey].channel.isReader}
    function create_if_block_5$3(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_1 = /*$observableChannelCache*/ ctx[2][/*properties*/ ctx[1].channelKey].posts;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$observableChannelCache, properties, ActivePost*/ 7) {
    				each_value_1 = /*$observableChannelCache*/ ctx[2][/*properties*/ ctx[1].channelKey].posts;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$3(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$3(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$3.name,
    		type: "if",
    		source: "(397:12) {#if $observableChannelCache[properties.channelKey] &&             $observableChannelCache[properties.channelKey].channel &&             $observableChannelCache[properties.channelKey].channel.isReader}",
    		ctx
    	});

    	return block;
    }

    // (401:20) {#if typeof post.parentPost !== 'number'}
    function create_if_block_6$2(ctx) {
    	let post;
    	let current;

    	post = new Post({
    			props: { post: /*post*/ ctx[18] },
    			$$inline: true
    		});

    	post.$on("answer-clicked", /*answer_clicked_handler*/ ctx[9]);

    	const block = {
    		c: function create() {
    			create_component(post.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(post, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const post_changes = {};
    			if (dirty & /*$observableChannelCache, properties*/ 6) post_changes.post = /*post*/ ctx[18];
    			post.$set(post_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(post.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(post.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(post, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$2.name,
    		type: "if",
    		source: "(401:20) {#if typeof post.parentPost !== 'number'}",
    		ctx
    	});

    	return block;
    }

    // (400:16) {#each $observableChannelCache[properties.channelKey].posts as post}
    function create_each_block_1$3(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = typeof /*post*/ ctx[18].parentPost !== "number" && create_if_block_6$2(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (typeof /*post*/ ctx[18].parentPost !== "number") {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$observableChannelCache, properties*/ 6) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_6$2(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$3.name,
    		type: "each",
    		source: "(400:16) {#each $observableChannelCache[properties.channelKey].posts as post}",
    		ctx
    	});

    	return block;
    }

    // (418:12) {#if $observableChannelCache[properties.channelKey].channel &&             !$observableChannelCache[properties.channelKey].notAuthorized &&             $observableChannelCache[properties.channelKey].channel.isContributor}
    function create_if_block_4$4(ctx) {
    	let posteditor;
    	let current;

    	posteditor = new PostEditor({
    			props: {
    				channelKey: /*properties*/ ctx[1].channelKey,
    				targetId: /*id*/ ctx[3]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(posteditor.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(posteditor, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const posteditor_changes = {};
    			if (dirty & /*properties*/ 2) posteditor_changes.channelKey = /*properties*/ ctx[1].channelKey;
    			posteditor.$set(posteditor_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(posteditor.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(posteditor.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(posteditor, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$4.name,
    		type: "if",
    		source: "(418:12) {#if $observableChannelCache[properties.channelKey].channel &&             !$observableChannelCache[properties.channelKey].notAuthorized &&             $observableChannelCache[properties.channelKey].channel.isContributor}",
    		ctx
    	});

    	return block;
    }

    // (424:8) {#if $observableChannelCache[properties.channelKey].channel &&         ActivePost &&         ActivePost.parentPost}
    function create_if_block_1$d(ctx) {
    	let div4;
    	let div2;
    	let div1;
    	let h6;
    	let t1;
    	let div0;
    	let span0;
    	let t2;
    	let t3_value = /*properties*/ ctx[1].channelKey + "";
    	let t3;
    	let t4;
    	let span1;
    	let t5;
    	let span1_id_value;
    	let t6;
    	let i;
    	let t7;
    	let div3;
    	let t8;
    	let post;
    	let t9;
    	let div4_intro;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*ActivePost*/ ctx[0].posts;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$g(get_each_context$g(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	post = new Post({
    			props: { post: /*ActivePost*/ ctx[0].parentPost },
    			$$inline: true
    		});

    	let if_block = /*$observableChannelCache*/ ctx[2][/*properties*/ ctx[1].channelKey].channel && !/*$observableChannelCache*/ ctx[2][/*properties*/ ctx[1].channelKey].notAuthorized && /*$observableChannelCache*/ ctx[2][/*properties*/ ctx[1].channelKey].channel.isContributor && create_if_block_2$8(ctx);

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			h6 = element("h6");
    			h6.textContent = "Fil de discussion";
    			t1 = space();
    			div0 = element("div");
    			span0 = element("span");
    			t2 = text("#");
    			t3 = text(t3_value);
    			t4 = space();
    			span1 = element("span");
    			t5 = text("Nouvelle réponse !");
    			t6 = space();
    			i = element("i");
    			t7 = space();
    			div3 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t8 = space();
    			create_component(post.$$.fragment);
    			t9 = space();
    			if (if_block) if_block.c();
    			attr_dev(h6, "class", "svelte-uvfjha");
    			add_location(h6, file$u, 429, 24, 16949);
    			add_location(span0, file$u, 431, 28, 17034);
    			attr_dev(span1, "id", span1_id_value = "new-answer-for-" + /*properties*/ ctx[1].channelKey);
    			attr_dev(span1, "class", "new-label " + (/*isThereNewAnswer*/ ctx[8]() ? "" : "hidden") + " svelte-uvfjha");
    			add_location(span1, file$u, 432, 28, 17100);
    			add_location(div0, file$u, 430, 24, 17000);
    			attr_dev(div1, "class", "svelte-uvfjha");
    			add_location(div1, file$u, 428, 20, 16919);
    			attr_dev(i, "class", "fal fa-window-close");
    			add_location(i, file$u, 435, 20, 17306);
    			attr_dev(div2, "class", "header svelte-uvfjha");
    			add_location(div2, file$u, 427, 16, 16877);
    			attr_dev(div3, "class", "channelContent svelte-uvfjha");
    			add_location(div3, file$u, 437, 16, 17407);
    			attr_dev(div4, "class", "channel-right-panel svelte-uvfjha");
    			add_location(div4, file$u, 426, 12, 16816);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div2);
    			append_dev(div2, div1);
    			append_dev(div1, h6);
    			append_dev(div1, t1);
    			append_dev(div1, div0);
    			append_dev(div0, span0);
    			append_dev(span0, t2);
    			append_dev(span0, t3);
    			append_dev(div0, t4);
    			append_dev(div0, span1);
    			append_dev(span1, t5);
    			append_dev(div2, t6);
    			append_dev(div2, i);
    			append_dev(div4, t7);
    			append_dev(div4, div3);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div3, null);
    			}

    			append_dev(div3, t8);
    			mount_component(post, div3, null);
    			append_dev(div3, t9);
    			if (if_block) if_block.m(div3, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(i, "click", /*hideRightPanel*/ ctx[4], false, false, false),
    					listen_dev(div3, "scroll", /*onScrollForChildren*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*properties*/ 2) && t3_value !== (t3_value = /*properties*/ ctx[1].channelKey + "")) set_data_dev(t3, t3_value);

    			if (!current || dirty & /*properties*/ 2 && span1_id_value !== (span1_id_value = "new-answer-for-" + /*properties*/ ctx[1].channelKey)) {
    				attr_dev(span1, "id", span1_id_value);
    			}

    			if (dirty & /*ActivePost*/ 1) {
    				each_value = /*ActivePost*/ ctx[0].posts;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$g(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$g(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div3, t8);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			const post_changes = {};
    			if (dirty & /*ActivePost*/ 1) post_changes.post = /*ActivePost*/ ctx[0].parentPost;
    			post.$set(post_changes);

    			if (/*$observableChannelCache*/ ctx[2][/*properties*/ ctx[1].channelKey].channel && !/*$observableChannelCache*/ ctx[2][/*properties*/ ctx[1].channelKey].notAuthorized && /*$observableChannelCache*/ ctx[2][/*properties*/ ctx[1].channelKey].channel.isContributor) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$observableChannelCache, properties*/ 6) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_2$8(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div3, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(post.$$.fragment, local);
    			transition_in(if_block);

    			if (!div4_intro) {
    				add_render_callback(() => {
    					div4_intro = create_in_transition(div4, slideIn, {});
    					div4_intro.start();
    				});
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(post.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			destroy_each(each_blocks, detaching);
    			destroy_component(post);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$d.name,
    		type: "if",
    		source: "(424:8) {#if $observableChannelCache[properties.channelKey].channel &&         ActivePost &&         ActivePost.parentPost}",
    		ctx
    	});

    	return block;
    }

    // (440:24) {#if post.parentPost === ActivePost.parentPost.id  }
    function create_if_block_3$6(ctx) {
    	let post;
    	let current;

    	post = new Post({
    			props: { post: /*post*/ ctx[18] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(post.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(post, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const post_changes = {};
    			if (dirty & /*ActivePost*/ 1) post_changes.post = /*post*/ ctx[18];
    			post.$set(post_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(post.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(post.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(post, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$6.name,
    		type: "if",
    		source: "(440:24) {#if post.parentPost === ActivePost.parentPost.id  }",
    		ctx
    	});

    	return block;
    }

    // (439:20) {#each ActivePost.posts as post}
    function create_each_block$g(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*post*/ ctx[18].parentPost === /*ActivePost*/ ctx[0].parentPost.id && create_if_block_3$6(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*post*/ ctx[18].parentPost === /*ActivePost*/ ctx[0].parentPost.id) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*ActivePost*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_3$6(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$g.name,
    		type: "each",
    		source: "(439:20) {#each ActivePost.posts as post}",
    		ctx
    	});

    	return block;
    }

    // (445:20) {#if $observableChannelCache[properties.channelKey].channel &&                     !$observableChannelCache[properties.channelKey].notAuthorized &&                     $observableChannelCache[properties.channelKey].channel.isContributor}
    function create_if_block_2$8(ctx) {
    	let posteditor;
    	let current;

    	posteditor = new PostEditor({
    			props: {
    				channelKey: /*$observableChannelCache*/ ctx[2][/*properties*/ ctx[1].channelKey].channel.key,
    				parentPost: /*ActivePost*/ ctx[0].parentPost.id,
    				targetId: "messageInThread"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(posteditor.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(posteditor, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const posteditor_changes = {};
    			if (dirty & /*$observableChannelCache, properties*/ 6) posteditor_changes.channelKey = /*$observableChannelCache*/ ctx[2][/*properties*/ ctx[1].channelKey].channel.key;
    			if (dirty & /*ActivePost*/ 1) posteditor_changes.parentPost = /*ActivePost*/ ctx[0].parentPost.id;
    			posteditor.$set(posteditor_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(posteditor.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(posteditor.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(posteditor, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$8.name,
    		type: "if",
    		source: "(445:20) {#if $observableChannelCache[properties.channelKey].channel &&                     !$observableChannelCache[properties.channelKey].notAuthorized &&                     $observableChannelCache[properties.channelKey].channel.isContributor}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$w(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$i, create_else_block$6];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$observableChannelCache*/ ctx[2][/*properties*/ ctx[1].channelKey]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$2();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function slideIn(node, { delay = 0, duration = 100 }) {
    	let p = getComputedStyle(node).width;
    	p = parseInt(p.replace("px", ""));

    	return {
    		delay,
    		duration,
    		css: t => `width: ${t * p}px;`
    	};
    }

    function slideOut(node, { delay = 0, duration = 100 }) {
    	let p = getComputedStyle(node).width;
    	p = parseInt(p.replace("px", ""));

    	return {
    		delay,
    		duration,
    		css: t => `width: ${(1 - t) * p}px;`
    	};
    }

    function instance$w($$self, $$props, $$invalidate) {
    	let $observableChannelCache;
    	validate_store(observableChannelCache, "observableChannelCache");
    	component_subscribe($$self, observableChannelCache, $$value => $$invalidate(2, $observableChannelCache = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ContentChannelContainer", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	let { properties } = $$props;
    	let { ActivePost } = $$props;
    	let editor = null;
    	let tailActivated = true;
    	let tailForChildrenActivated = true;
    	const id = v4();
    	let posts = [];

    	const unsubscribe = observableChannelCache.subscribe(occ => {
    		console.log(occ);

    		if (properties.channelKey && occ && occ[properties.channelKey]) {
    			posts = occ[properties.channelKey].posts;
    		}
    	});

    	function isRightPanelVisible() {
    		const b = $observableChannelCache[properties.channelKey] && ActivePost && ActivePost.parentPost && ActivePost.parentPost.channelKey === properties.channelKey;
    		console.log(`Testing if right panel must be shown : ${b}`);
    		return b;
    	}

    	function hideRightPanel() {
    		$$invalidate(0, ActivePost = undefined);
    	}

    	function onScrollForChildren(event) {
    		return __awaiter(this, void 0, void 0, function* () {
    			const channelContentView = document.querySelector(".channel-right-panel div.channelContent");

    			if (channelContentView) {
    				const bottom = channelContentView.scrollHeight - channelContentView.clientHeight;

    				if (event.target.scrollTop === bottom) {
    					if (ActivePost && ActivePost.parentPost && $observableChannelCache[properties.channelKey]) {
    						const lastId = ActivePost.posts[ActivePost.posts.length - 1].id;
    						const backendClient = yield dist$1.getBackendClient();
    						const otherChildrenPage = yield backendClient.channelsService.getChildrenPosts(ActivePost.parentPost.channelKey, ActivePost.parentPost.id, lastId);
    						let toUpdate = false;

    						if (otherChildrenPage.length) {
    							for (const ocp of otherChildrenPage) {
    								if (!ActivePost.posts.find(p => p.id === ocp.id)) {
    									if (ocp.content) {
    										yield Helpers.preloadContentPreview(ocp.content);
    									}

    									if (Array.isArray(ocp.attachments) && ocp.attachments.length > 0) {
    										const attachmentsMetadata = [];

    										for (const a of ocp.attachments) {
    											const m = yield backendClient.mediaService.getMediaMetadata(a);
    											attachmentsMetadata.push(m);
    										}

    										ocp.attachments = attachmentsMetadata;
    									}

    									ActivePost.posts.push(ocp);
    									toUpdate = true;
    								}
    							}

    							if (toUpdate) {
    								ActivePost.posts.sort((p1, p2) => {
    									if (p1.id > p2.id) return -1;
    									if (p1.id < p2.id) return 1;
    									return 0;
    								});

    								$$invalidate(0, ActivePost);
    							}
    						}
    					}
    				}

    				tailForChildrenActivated = channelContentView.scrollTop === 0;
    			}
    		});
    	}

    	function onScrollForCurrentChannel(event) {
    		return __awaiter(this, void 0, void 0, function* () {
    			const channelContentView = document.querySelector(`#channel-${properties.channelKey} div.channelContent`);

    			if (channelContentView) {
    				const bottom = channelContentView.scrollHeight - channelContentView.clientHeight;

    				if (event.target.scrollTop === bottom) {
    					let posts = $observableChannelCache[properties.channelKey].posts.filter(p => typeof p.parentPost !== "number");
    					const lastId = posts[posts.length - 1].id;
    					const backendClient = yield dist$1.getBackendClient();
    					const nextPage = yield backendClient.channelsService.getChannelPosts(properties.channelKey, undefined, lastId);

    					if (nextPage.length) {
    						let toUpdate = false;

    						for (const ocp of nextPage) {
    							if (!$observableChannelCache[properties.channelKey].posts.find(p => p.id === ocp.id)) {
    								if (ocp.content) {
    									yield Helpers.preloadContentPreview(ocp.content);
    								}

    								if (Array.isArray(ocp.attachments) && ocp.attachments.length > 0) {
    									const attachmentsMetadata = [];

    									for (const a of ocp.attachments) {
    										const m = yield backendClient.mediaService.getMediaMetadata(a);
    										attachmentsMetadata.push(m);
    									}

    									ocp.attachments = attachmentsMetadata;
    								}

    								$observableChannelCache[properties.channelKey].posts.push(ocp);
    								toUpdate = true;
    							}
    						}

    						if (toUpdate) {
    							console.log("update after scroll down");

    							observableChannelCache.update(occ => {
    								return occ;
    							});
    						}
    					}
    				}

    				tailActivated = channelContentView.scrollTop === 0;
    			}
    		});
    	}

    	function isThereNewMessage() {
    		if ($observableChannelCache[properties.channelKey]) {
    			const newMessage = $observableChannelCache[properties.channelKey].posts.findIndex(p => {
    				if ((typeof p.parentPost === "undefined" || p.parentPost === null) && typeof p.isNew === "boolean" && p.isNew) {
    					return true;
    				}

    				return false;
    			}) >= 0;

    			return newMessage;
    		}

    		return false;
    	}

    	function isThereNewAnswer() {
    		if ($observableChannelCache[properties.channelKey]) {
    			const newAnswer = $observableChannelCache[properties.channelKey].posts.findIndex(p => {
    				if (ActivePost && ActivePost.parentPost && p.parentPost === ActivePost.parentPost.id && typeof p.isNew === "boolean" && p.isNew) {
    					return true;
    				}

    				return false;
    			}) >= 0;

    			return newAnswer;
    		}

    		return false;
    	}

    	function createChannelFromKey() {
    		return __awaiter(this, void 0, void 0, function* () {
    			if (properties && properties.channelKey) {
    				yield Helpers.getChannelContentAndSubscribe(properties.channelKey);
    			}
    		});
    	}

    	onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    		yield createChannelFromKey();
    	}));

    	beforeUpdate(() => {
    		if (isThereNewAnswer()) {
    			const newAnswers = $observableChannelCache[properties.channelKey].posts.filter(p => p.parentPost === ActivePost.parentPost.id);

    			if (newAnswers && newAnswers.length > 0) {
    				for (const p of ActivePost.posts) {
    					p.isNew = false;
    				}

    				for (const a of newAnswers) {
    					$observableChannelCache[properties.channelKey].posts.splice($observableChannelCache[properties.channelKey].posts.indexOf(a), 1);
    					ActivePost.posts.push(a);
    				}

    				ActivePost.posts.sort((p1, p2) => {
    					if (p1.id > p2.id) return -1;
    					if (p1.id < p2.id) return 1;
    					return 0;
    				});

    				$$invalidate(0, ActivePost);
    			}
    		}
    	});

    	afterUpdate(() => __awaiter(void 0, void 0, void 0, function* () {
    		var _a, _b, _c, _d;

    		if (isThereNewMessage()) {
    			(_a = document.getElementById(`new-message-for-${properties.channelKey}`)) === null || _a === void 0
    			? void 0
    			: _a.classList.remove("hidden");
    		} else {
    			(_b = document.getElementById(`new-message-for-${properties.channelKey}`)) === null || _b === void 0
    			? void 0
    			: _b.classList.add("hidden");
    		}

    		if (isThereNewAnswer()) {
    			(_c = document.getElementById(`new-answer-for-${properties.channelKey}`)) === null || _c === void 0
    			? void 0
    			: _c.classList.remove("hidden");
    		} else {
    			(_d = document.getElementById(`new-answer-for-${properties.channelKey}`)) === null || _d === void 0
    			? void 0
    			: _d.classList.add("hidden");
    		}

    		if ($observableChannelCache.hasChannel(properties.channelKey) && tailActivated) {
    			const channelContentView = document.querySelector(`#channel-${properties.channelKey} div.channelContent`);

    			if (channelContentView) {
    				channelContentView.scrollTop = channelContentView.clientHeight - channelContentView.scrollHeight;
    			}
    		}

    		if ($observableChannelCache.hasChannel(properties.channelKey) && tailForChildrenActivated) {
    			const rightPanel = document.querySelector(".channel-right-panel > .channelContent");

    			if (rightPanel) {
    				rightPanel.scrollTop = rightPanel.clientHeight - rightPanel.scrollHeight;
    			}
    		}

    		if ($observableChannelCache.hasChannel(properties.channelKey)) {
    			const messages = document.querySelector(`#channel-${properties.channelKey} > .channelContent`);
    			const lastMessages = document.querySelectorAll(`#channel-${properties.channelKey} > .channelContent > .post.new-post`);
    			if (lastMessages.length > 0) 

    			{
    				const lastMessage = lastMessages[lastMessages.length - 1];
    				lastMessage.remove();
    				messages.prepend(lastMessage);
    			}
    		}

    		if (ActivePost) {
    			const messages = document.querySelector(`#channel-${properties.channelKey} > .channel-right-panel > .channelContent`);
    			const lastMessages = document.querySelectorAll(`#channel-${properties.channelKey} > .channel-right-panel > .channelContent > .post.new-post`);
    			if (lastMessages.length > 0) 

    			{
    				const lastMessage = lastMessages[lastMessages.length - 1];
    				lastMessage.remove();
    				messages.prepend(lastMessage);
    			}
    		}
    	}));

    	onDestroy(() => {
    		unsubscribe();
    	});

    	const writable_props = ["properties", "ActivePost"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$g.warn(`<ContentChannelContainer> was created with unknown prop '${key}'`);
    	});

    	const answer_clicked_handler = p => {
    		$$invalidate(0, ActivePost = p.detail);
    	};

    	$$self.$$set = $$props => {
    		if ("properties" in $$props) $$invalidate(1, properties = $$props.properties);
    		if ("ActivePost" in $$props) $$invalidate(0, ActivePost = $$props.ActivePost);
    	};

    	$$self.$capture_state = () => ({
    		__awaiter,
    		getBackendClient: dist$1.getBackendClient,
    		Helpers,
    		uuid: v4,
    		onMount,
    		beforeUpdate,
    		afterUpdate,
    		onDestroy,
    		PostEditor,
    		Post,
    		observableChannelCache,
    		properties,
    		ActivePost,
    		editor,
    		tailActivated,
    		tailForChildrenActivated,
    		id,
    		posts,
    		unsubscribe,
    		isRightPanelVisible,
    		hideRightPanel,
    		slideIn,
    		slideOut,
    		onScrollForChildren,
    		onScrollForCurrentChannel,
    		isThereNewMessage,
    		isThereNewAnswer,
    		createChannelFromKey,
    		$observableChannelCache
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("properties" in $$props) $$invalidate(1, properties = $$props.properties);
    		if ("ActivePost" in $$props) $$invalidate(0, ActivePost = $$props.ActivePost);
    		if ("editor" in $$props) editor = $$props.editor;
    		if ("tailActivated" in $$props) tailActivated = $$props.tailActivated;
    		if ("tailForChildrenActivated" in $$props) tailForChildrenActivated = $$props.tailForChildrenActivated;
    		if ("posts" in $$props) posts = $$props.posts;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		ActivePost,
    		properties,
    		$observableChannelCache,
    		id,
    		hideRightPanel,
    		onScrollForChildren,
    		onScrollForCurrentChannel,
    		isThereNewMessage,
    		isThereNewAnswer,
    		answer_clicked_handler
    	];
    }

    class ContentChannelContainer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$w, create_fragment$w, safe_not_equal, { properties: 1, ActivePost: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ContentChannelContainer",
    			options,
    			id: create_fragment$w.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*properties*/ ctx[1] === undefined && !("properties" in props)) {
    			console_1$g.warn("<ContentChannelContainer> was created without expected prop 'properties'");
    		}

    		if (/*ActivePost*/ ctx[0] === undefined && !("ActivePost" in props)) {
    			console_1$g.warn("<ContentChannelContainer> was created without expected prop 'ActivePost'");
    		}
    	}

    	get properties() {
    		throw new Error("<ContentChannelContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set properties(value) {
    		throw new Error("<ContentChannelContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ActivePost() {
    		throw new Error("<ContentChannelContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ActivePost(value) {
    		throw new Error("<ContentChannelContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Channel/ContentChannelsContainer.svelte generated by Svelte v3.38.2 */

    const { console: console_1$f } = globals;
    const file$t = "src/components/Channel/ContentChannelsContainer.svelte";

    function get_each_context$f(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[12] = list[i];
    	return child_ctx;
    }

    // (203:12) {#each availableChannels as availableChannel}
    function create_each_block$f(ctx) {
    	let li;
    	let span;
    	let t_value = /*availableChannel*/ ctx[12].label + "";
    	let t;
    	let li_data_channelkey_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			li = element("li");
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "class", "channels-item-label svelte-o44ivz");
    			add_location(span, file$t, 203, 183, 7313);
    			attr_dev(li, "data-channelkey", li_data_channelkey_value = /*availableChannel*/ ctx[12].key);
    			attr_dev(li, "class", "channels-items list-group-item list-group-item-dark list-group-item-action svelte-o44ivz");
    			add_location(li, file$t, 203, 16, 7146);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, span);
    			append_dev(span, t);

    			if (!mounted) {
    				dispose = listen_dev(li, "click", /*changeCurrentChannelOnclick*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*availableChannels*/ 1 && t_value !== (t_value = /*availableChannel*/ ctx[12].label + "")) set_data_dev(t, t_value);

    			if (dirty & /*availableChannels*/ 1 && li_data_channelkey_value !== (li_data_channelkey_value = /*availableChannel*/ ctx[12].key)) {
    				attr_dev(li, "data-channelkey", li_data_channelkey_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$f.name,
    		type: "each",
    		source: "(203:12) {#each availableChannels as availableChannel}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$v(ctx) {
    	let main;
    	let div0;
    	let ul;
    	let li;
    	let i;
    	let span0;
    	let t1;
    	let t2;
    	let contentchannelcontainer;
    	let t3;
    	let div13;
    	let style;
    	let t5;
    	let div12;
    	let div11;
    	let div1;
    	let h5;
    	let t7;
    	let button0;
    	let span1;
    	let t9;
    	let div7;
    	let form;
    	let div3;
    	let label0;
    	let t11;
    	let input0;
    	let t12;
    	let div2;
    	let t14;
    	let div5;
    	let label1;
    	let t16;
    	let input1;
    	let t17;
    	let div4;
    	let t19;
    	let div6;
    	let label2;
    	let t21;
    	let select;
    	let option0;
    	let option1;
    	let option2;
    	let t25;
    	let div10;
    	let div9;
    	let div8;
    	let t26;
    	let button1;
    	let span2;
    	let t27;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*availableChannels*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$f(get_each_context$f(ctx, each_value, i));
    	}

    	contentchannelcontainer = new ContentChannelContainer({
    			props: {
    				ActivePostStore: undefined,
    				properties: { channelKey: /*Channel*/ ctx[1] }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			main = element("main");
    			div0 = element("div");
    			ul = element("ul");
    			li = element("li");
    			i = element("i");
    			span0 = element("span");
    			span0.textContent = "Ajouter un canal";
    			t1 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t2 = space();
    			create_component(contentchannelcontainer.$$.fragment);
    			t3 = space();
    			div13 = element("div");
    			style = element("style");
    			style.textContent = "label {\n            text-align: start;\n        }";
    			t5 = space();
    			div12 = element("div");
    			div11 = element("div");
    			div1 = element("div");
    			h5 = element("h5");
    			h5.textContent = "Créer un nouveau canal";
    			t7 = space();
    			button0 = element("button");
    			span1 = element("span");
    			span1.textContent = "×";
    			t9 = space();
    			div7 = element("div");
    			form = element("form");
    			div3 = element("div");
    			label0 = element("label");
    			label0.textContent = "Label";
    			t11 = space();
    			input0 = element("input");
    			t12 = space();
    			div2 = element("div");
    			div2.textContent = "Le label ne peut pas être vide.";
    			t14 = space();
    			div5 = element("div");
    			label1 = element("label");
    			label1.textContent = "Clé unique du canal";
    			t16 = space();
    			input1 = element("input");
    			t17 = space();
    			div4 = element("div");
    			div4.textContent = "La clé ne peut pas être vide ou un canal avec la même clé existe déjà.";
    			t19 = space();
    			div6 = element("div");
    			label2 = element("label");
    			label2.textContent = "Visibilité";
    			t21 = space();
    			select = element("select");
    			option0 = element("option");
    			option0.textContent = "Privé";
    			option1 = element("option");
    			option1.textContent = "Protégé";
    			option2 = element("option");
    			option2.textContent = "Public";
    			t25 = space();
    			div10 = element("div");
    			div9 = element("div");
    			div8 = element("div");
    			t26 = space();
    			button1 = element("button");
    			span2 = element("span");
    			t27 = text("Créer le canal");
    			attr_dev(i, "class", "fas fa-2x fa-plus-circle");
    			add_location(i, file$t, 201, 153, 6969);
    			attr_dev(span0, "class", "channels-item-label svelte-o44ivz");
    			add_location(span0, file$t, 201, 193, 7009);
    			attr_dev(li, "id", "show-create-channel");
    			attr_dev(li, "class", "channels-items list-group-item list-group-item-dark list-group-item-action svelte-o44ivz");
    			add_location(li, file$t, 201, 12, 6828);
    			attr_dev(ul, "class", "list-group");
    			add_location(ul, file$t, 200, 8, 6792);
    			attr_dev(div0, "class", "channelsMenu svelte-o44ivz");
    			add_location(div0, file$t, 199, 4, 6757);
    			attr_dev(main, "class", "channelPanel svelte-o44ivz");
    			add_location(main, file$t, 198, 0, 6725);
    			add_location(style, file$t, 213, 4, 7647);
    			attr_dev(h5, "id", "create-channel-modal-title");
    			attr_dev(h5, "class", "modal-title");
    			add_location(h5, file$t, 221, 16, 7869);
    			attr_dev(span1, "aria-hidden", "true");
    			add_location(span1, file$t, 223, 20, 8082);
    			attr_dev(button0, "id", "ErrorClose");
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "close");
    			attr_dev(button0, "data-dismiss", "modal");
    			attr_dev(button0, "aria-label", "Close");
    			add_location(button0, file$t, 222, 16, 7969);
    			attr_dev(div1, "class", "modal-header");
    			add_location(div1, file$t, 220, 12, 7826);
    			attr_dev(label0, "for", "channelLabel");
    			add_location(label0, file$t, 229, 24, 8322);
    			attr_dev(input0, "class", "form-control");
    			attr_dev(input0, "id", "channelLabel");
    			attr_dev(input0, "name", "channelLabel");
    			attr_dev(input0, "type", "text");
    			input0.required = true;
    			add_location(input0, file$t, 230, 24, 8386);
    			attr_dev(div2, "class", "invalid-feedback");
    			add_location(div2, file$t, 231, 24, 8523);
    			attr_dev(div3, "class", "mb-3");
    			add_location(div3, file$t, 228, 20, 8279);
    			attr_dev(label1, "for", "channelKey");
    			add_location(label1, file$t, 236, 24, 8735);
    			attr_dev(input1, "class", "form-control");
    			attr_dev(input1, "id", "channelKey");
    			attr_dev(input1, "name", "channelKey");
    			attr_dev(input1, "type", "text");
    			input1.required = true;
    			add_location(input1, file$t, 237, 24, 8811);
    			attr_dev(div4, "class", "invalid-feedback");
    			add_location(div4, file$t, 238, 24, 8942);
    			attr_dev(div5, "class", "mb-3");
    			add_location(div5, file$t, 235, 20, 8692);
    			attr_dev(label2, "for", "channelVisibility");
    			add_location(label2, file$t, 243, 24, 9193);
    			option0.__value = "private";
    			option0.value = option0.__value;
    			add_location(option0, file$t, 245, 28, 9482);
    			option1.__value = "protected";
    			option1.value = option1.__value;
    			add_location(option1, file$t, 246, 28, 9550);
    			option2.__value = "public";
    			option2.value = option2.__value;
    			add_location(option2, file$t, 247, 28, 9622);
    			attr_dev(select, "class", "form-select");
    			attr_dev(select, "id", "channelVisibility");
    			attr_dev(select, "name", "channelVisibility");
    			select.required = true;
    			attr_dev(select, "title", "Un canal privé n'est accessible et visible que par ses membres");
    			add_location(select, file$t, 244, 24, 9267);
    			attr_dev(div6, "class", "mb-3");
    			add_location(div6, file$t, 242, 20, 9150);
    			attr_dev(form, "id", "CreateChannelForm");
    			attr_dev(form, "class", "");
    			add_location(form, file$t, 227, 16, 8220);
    			attr_dev(div7, "class", "modal-body");
    			add_location(div7, file$t, 226, 12, 8179);
    			attr_dev(div8, "id", "errorOnCreatingChannelContent");
    			add_location(div8, file$t, 254, 20, 9933);
    			attr_dev(div9, "id", "errorOnCreatingChannel");
    			attr_dev(div9, "class", "alert alert-danger fade svelte-o44ivz");
    			add_location(div9, file$t, 253, 16, 9847);
    			attr_dev(span2, "id", "creating-channel-loading");
    			attr_dev(span2, "class", "spinner-border svelte-o44ivz");
    			add_location(span2, file$t, 256, 95, 10098);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn action btn-danger  svelte-o44ivz");
    			add_location(button1, file$t, 256, 16, 10019);
    			attr_dev(div10, "class", "modal-footer modal-footer-createChannel svelte-o44ivz");
    			add_location(div10, file$t, 252, 12, 9777);
    			attr_dev(div11, "class", "modal-content");
    			add_location(div11, file$t, 219, 8, 7786);
    			attr_dev(div12, "class", "modal-dialog modal-dialog-centered");
    			add_location(div12, file$t, 218, 4, 7729);
    			attr_dev(div13, "id", "CreateChannelModal");
    			attr_dev(div13, "class", "modal fade");
    			attr_dev(div13, "data-keyboard", "false");
    			add_location(div13, file$t, 212, 0, 7572);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div0);
    			append_dev(div0, ul);
    			append_dev(ul, li);
    			append_dev(li, i);
    			append_dev(li, span0);
    			append_dev(ul, t1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			append_dev(main, t2);
    			mount_component(contentchannelcontainer, main, null);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div13, anchor);
    			append_dev(div13, style);
    			append_dev(div13, t5);
    			append_dev(div13, div12);
    			append_dev(div12, div11);
    			append_dev(div11, div1);
    			append_dev(div1, h5);
    			append_dev(div1, t7);
    			append_dev(div1, button0);
    			append_dev(button0, span1);
    			append_dev(div11, t9);
    			append_dev(div11, div7);
    			append_dev(div7, form);
    			append_dev(form, div3);
    			append_dev(div3, label0);
    			append_dev(div3, t11);
    			append_dev(div3, input0);
    			append_dev(div3, t12);
    			append_dev(div3, div2);
    			append_dev(form, t14);
    			append_dev(form, div5);
    			append_dev(div5, label1);
    			append_dev(div5, t16);
    			append_dev(div5, input1);
    			append_dev(div5, t17);
    			append_dev(div5, div4);
    			append_dev(form, t19);
    			append_dev(form, div6);
    			append_dev(div6, label2);
    			append_dev(div6, t21);
    			append_dev(div6, select);
    			append_dev(select, option0);
    			append_dev(select, option1);
    			append_dev(select, option2);
    			append_dev(div11, t25);
    			append_dev(div11, div10);
    			append_dev(div10, div9);
    			append_dev(div9, div8);
    			append_dev(div10, t26);
    			append_dev(div10, button1);
    			append_dev(button1, span2);
    			append_dev(button1, t27);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(li, "click", showCreateChannel, false, false, false),
    					listen_dev(input0, "blur", onLabelChanged$1, false, false, false),
    					listen_dev(input1, "blur", /*onKeyChanged*/ ctx[3], false, false, false),
    					listen_dev(select, "blur", /*onVisibilityChanged*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*createChannel*/ ctx[2], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*availableChannels, changeCurrentChannelOnclick*/ 33) {
    				each_value = /*availableChannels*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$f(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$f(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			const contentchannelcontainer_changes = {};
    			if (dirty & /*Channel*/ 2) contentchannelcontainer_changes.properties = { channelKey: /*Channel*/ ctx[1] };
    			contentchannelcontainer.$set(contentchannelcontainer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(contentchannelcontainer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(contentchannelcontainer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_each(each_blocks, detaching);
    			destroy_component(contentchannelcontainer);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div13);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    async function showCreateChannel(event) {
    	jQuery("#CreateChannelModal").modal("show");
    }

    async function onLabelChanged$1(event) {
    	const keyInput = document.getElementById("channelKey");
    	const labelInput = document.getElementById("channelLabel");

    	if (!keyInput.value) {
    		keyInput.value = labelInput.value;
    		keyInput.dispatchEvent(new Event("change"));
    	}

    	if (!labelInput) {
    		labelInput.classList.remove("is-valid");
    		labelInput.classList.add("is-invalid");
    	} else {
    		labelInput.classList.remove("is-invalid");
    		labelInput.classList.add("is-valid");
    	}
    }

    function instance$v($$self, $$props, $$invalidate) {
    	let $observableChannelCache;
    	validate_store(observableChannelCache, "observableChannelCache");
    	component_subscribe($$self, observableChannelCache, $$value => $$invalidate(7, $observableChannelCache = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ContentChannelsContainer", slots, []);
    	let { properties } = $$props;
    	let availableChannels = [];
    	let ActivePost;
    	let Channel = properties.channelKey;

    	onMount(async () => {
    		const backEndService = await dist$1.getBackendClient();
    		$$invalidate(0, availableChannels = await backEndService.channelsService.getAvailableChannels());
    	});

    	document.addEventListener(dist$1.channelsEventNames.channelsActions, async () => {
    		const backEndService = await dist$1.getBackendClient();
    		$$invalidate(0, availableChannels = await backEndService.channelsService.getAvailableChannels());
    	});

    	async function createChannel(event) {
    		const errorAlertContent = document.getElementById("errorOnCreatingChannelContent");
    		const errorAlert = document.getElementById("errorOnCreatingChannel");

    		if (await validateNewChannel()) {
    			try {
    				const backendService = await dist$1.getBackendClient();

    				const data = {
    					key: document.querySelector("#channelKey").value,
    					label: document.querySelector("#channelLabel").value,
    					visibility: document.querySelector("#channelVisibility").value
    				};

    				await backendService.channelsService.createChannel(data);
    				jQuery("#CreateChannelModal").modal("hide");
    				document.querySelector("#channelKey").value = null;
    				document.querySelector("#channelLabel").value = null;
    				document.querySelector("#channelVisibility").value = "private";
    			} catch(error) {
    				console.log(error);
    				errorAlertContent.innerText = error.message;
    				errorAlert.classList.add("show");
    			}
    		} else {
    			errorAlertContent.innerText = "Impossible de créer le Canal. Vérifier ses paramètres";
    			errorAlert.classList.add("show");
    		}
    	}

    	async function validateNewChannel() {
    		const form = document.getElementById("CreateChannelForm");

    		const p = new Promise(resolve => {
    				form.querySelectorAll("input").forEach(i => {
    					i.dispatchEvent(new Event("change"));
    				});

    				resolve();
    			});

    		await p;
    		const backendService = await dist$1.getBackendClient();

    		const data = {
    			key: document.querySelector("#channelKey").value,
    			label: document.querySelector("#channelLabel").value,
    			visibility: document.querySelector("#channelVisibility").value
    		};

    		return data.key && data.label && data.visibility && !await backendService.channelsService.exists(data.key);
    	}

    	async function onKeyChanged(event) {
    		const backendService = await dist$1.getBackendClient();
    		const keyInput = document.getElementById("channelKey");
    		const labelInput = document.getElementById("channelLabel");

    		if (!labelInput.value) {
    			labelInput.value = keyInput.value;
    		}

    		if (!labelInput) {
    			labelInput.classList.add("is-invalid");
    			labelInput.dispatchEvent(new Event("change"));
    		} else {
    			if (await backendService.channelsService.exists(keyInput.value)) {
    				keyInput.classList.remove("is-valid");
    				keyInput.classList.add("is-invalid");
    			} else {
    				keyInput.classList.remove("is-invalid");
    				keyInput.classList.add("is-valid");
    			}
    		}
    	}

    	const visibilityTooltips = {
    		private: "Un canal privé n'est accessible et visible que par ses membres",
    		protected: "Un canal protégé est visible par tout utilisateur authentifié et accessible uniquement par ses membres",
    		public: "Un canal public est visible et accessible par tout utilisateur identifié"
    	};

    	async function onVisibilityChanged(event) {
    		const visibility = document.getElementById("channelVisibility");
    		visibility.title = visibilityTooltips[visibility.value];
    	}

    	async function changeCurrentChannelOnclick(event) {
    		let selectedChannel = event.target;
    		let selectedChannelKey;

    		if (selectedChannel.attributes["data-channelKey"]) {
    			selectedChannelKey = selectedChannel.attributes["data-channelKey"].value;
    		} else {
    			selectedChannel = event.target.parentNode;
    			selectedChannelKey = selectedChannel.attributes["data-channelKey"].value;
    		}

    		await changeCurrentChannel(selectedChannelKey);
    	}

    	async function changeCurrentChannel(channelKey) {
    		if (channelKey) {
    			await Helpers.getChannelContentAndSubscribe(channelKey);
    			console.log($observableChannelCache);
    			$$invalidate(1, Channel = channelKey);
    		}
    	}

    	const writable_props = ["properties"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$f.warn(`<ContentChannelsContainer> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("properties" in $$props) $$invalidate(6, properties = $$props.properties);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		getBackendClient: dist$1.getBackendClient,
    		ContentChannelContainer,
    		channelsEventNames: dist$1.channelsEventNames,
    		Helpers,
    		observableChannelCache,
    		properties,
    		availableChannels,
    		ActivePost,
    		Channel,
    		showCreateChannel,
    		createChannel,
    		validateNewChannel,
    		onLabelChanged: onLabelChanged$1,
    		onKeyChanged,
    		visibilityTooltips,
    		onVisibilityChanged,
    		changeCurrentChannelOnclick,
    		changeCurrentChannel,
    		$observableChannelCache
    	});

    	$$self.$inject_state = $$props => {
    		if ("properties" in $$props) $$invalidate(6, properties = $$props.properties);
    		if ("availableChannels" in $$props) $$invalidate(0, availableChannels = $$props.availableChannels);
    		if ("ActivePost" in $$props) ActivePost = $$props.ActivePost;
    		if ("Channel" in $$props) $$invalidate(1, Channel = $$props.Channel);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		availableChannels,
    		Channel,
    		createChannel,
    		onKeyChanged,
    		onVisibilityChanged,
    		changeCurrentChannelOnclick,
    		properties
    	];
    }

    class ContentChannelsContainer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$v, create_fragment$v, safe_not_equal, { properties: 6 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ContentChannelsContainer",
    			options,
    			id: create_fragment$v.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*properties*/ ctx[6] === undefined && !("properties" in props)) {
    			console_1$f.warn("<ContentChannelsContainer> was created without expected prop 'properties'");
    		}
    	}

    	get properties() {
    		throw new Error("<ContentChannelsContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set properties(value) {
    		throw new Error("<ContentChannelsContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const ProjectStore = writable(new Array());

    /* src/components/Projects/ProjectCard.svelte generated by Svelte v3.38.2 */

    const file$s = "src/components/Projects/ProjectCard.svelte";

    function create_fragment$u(ctx) {
    	let button;
    	let div;
    	let h5;
    	let t0_value = /*project*/ ctx[0].label + "";
    	let t0;
    	let t1;
    	let p;
    	let t2_value = /*project*/ ctx[0].description + "";
    	let t2;
    	let button_id_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			div = element("div");
    			h5 = element("h5");
    			t0 = text(t0_value);
    			t1 = space();
    			p = element("p");
    			t2 = text(t2_value);
    			attr_dev(h5, "class", "card-title");
    			add_location(h5, file$s, 38, 8, 664);
    			attr_dev(p, "class", "card-text svelte-8rgoha");
    			add_location(p, file$s, 39, 8, 716);
    			attr_dev(div, "class", "card-body svelte-8rgoha");
    			add_location(div, file$s, 37, 4, 632);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "id", button_id_value = "project-" + /*project*/ ctx[0].id);
    			attr_dev(button, "class", "btn btn-secondary card project-card svelte-8rgoha");
    			add_location(button, file$s, 36, 0, 509);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, div);
    			append_dev(div, h5);
    			append_dev(h5, t0);
    			append_dev(div, t1);
    			append_dev(div, p);
    			append_dev(p, t2);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", displayProject, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*project*/ 1 && t0_value !== (t0_value = /*project*/ ctx[0].label + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*project*/ 1 && t2_value !== (t2_value = /*project*/ ctx[0].description + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*project*/ 1 && button_id_value !== (button_id_value = "project-" + /*project*/ ctx[0].id)) {
    				attr_dev(button, "id", button_id_value);
    			}
    		},
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    async function displayProject() {
    	
    }

    function instance$u($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ProjectCard", slots, []);
    	let { project } = $$props;
    	const writable_props = ["project"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ProjectCard> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("project" in $$props) $$invalidate(0, project = $$props.project);
    	};

    	$$self.$capture_state = () => ({ project, displayProject });

    	$$self.$inject_state = $$props => {
    		if ("project" in $$props) $$invalidate(0, project = $$props.project);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [project];
    }

    class ProjectCard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$u, create_fragment$u, safe_not_equal, { project: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ProjectCard",
    			options,
    			id: create_fragment$u.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*project*/ ctx[0] === undefined && !("project" in props)) {
    			console.warn("<ProjectCard> was created without expected prop 'project'");
    		}
    	}

    	get project() {
    		throw new Error("<ProjectCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set project(value) {
    		throw new Error("<ProjectCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Projects/ContentProjectsContainer.svelte generated by Svelte v3.38.2 */

    const { console: console_1$e } = globals;
    const file$r = "src/components/Projects/ContentProjectsContainer.svelte";

    function get_each_context$e(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	return child_ctx;
    }

    // (154:4) {#if $ProjectStore}
    function create_if_block$h(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*$ProjectStore*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$e(get_each_context$e(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$ProjectStore*/ 1) {
    				each_value = /*$ProjectStore*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$e(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$e(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$h.name,
    		type: "if",
    		source: "(154:4) {#if $ProjectStore}",
    		ctx
    	});

    	return block;
    }

    // (155:8) {#each $ProjectStore as project}
    function create_each_block$e(ctx) {
    	let projectcard;
    	let current;

    	projectcard = new ProjectCard({
    			props: { project: /*project*/ ctx[3] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(projectcard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(projectcard, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const projectcard_changes = {};
    			if (dirty & /*$ProjectStore*/ 1) projectcard_changes.project = /*project*/ ctx[3];
    			projectcard.$set(projectcard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(projectcard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(projectcard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(projectcard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$e.name,
    		type: "each",
    		source: "(155:8) {#each $ProjectStore as project}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$t(ctx) {
    	let main;
    	let button0;
    	let i;
    	let t0;
    	let t1;
    	let div12;
    	let style;
    	let t3;
    	let div11;
    	let div10;
    	let div0;
    	let h5;
    	let t5;
    	let button1;
    	let span0;
    	let t7;
    	let div6;
    	let form;
    	let div2;
    	let label0;
    	let t9;
    	let input0;
    	let t10;
    	let div1;
    	let t12;
    	let div4;
    	let label1;
    	let t14;
    	let input1;
    	let t15;
    	let div3;
    	let t17;
    	let div5;
    	let label2;
    	let t19;
    	let textarea;
    	let t20;
    	let div9;
    	let div8;
    	let div7;
    	let t21;
    	let button2;
    	let span1;
    	let t22;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*$ProjectStore*/ ctx[0] && create_if_block$h(ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			button0 = element("button");
    			i = element("i");
    			t0 = space();
    			if (if_block) if_block.c();
    			t1 = space();
    			div12 = element("div");
    			style = element("style");
    			style.textContent = "label {\n            text-align: start;\n        }";
    			t3 = space();
    			div11 = element("div");
    			div10 = element("div");
    			div0 = element("div");
    			h5 = element("h5");
    			h5.textContent = "Créer un nouveau projet";
    			t5 = space();
    			button1 = element("button");
    			span0 = element("span");
    			span0.textContent = "×";
    			t7 = space();
    			div6 = element("div");
    			form = element("form");
    			div2 = element("div");
    			label0 = element("label");
    			label0.textContent = "Label";
    			t9 = space();
    			input0 = element("input");
    			t10 = space();
    			div1 = element("div");
    			div1.textContent = "Le label ne peut pas être vide.";
    			t12 = space();
    			div4 = element("div");
    			label1 = element("label");
    			label1.textContent = "Clé unique du projet";
    			t14 = space();
    			input1 = element("input");
    			t15 = space();
    			div3 = element("div");
    			div3.textContent = "La clé ne peut pas être vide ou un projet avec la même clé existe déjà.";
    			t17 = space();
    			div5 = element("div");
    			label2 = element("label");
    			label2.textContent = "Description du projet";
    			t19 = space();
    			textarea = element("textarea");
    			t20 = space();
    			div9 = element("div");
    			div8 = element("div");
    			div7 = element("div");
    			t21 = space();
    			button2 = element("button");
    			span1 = element("span");
    			t22 = text("Créer le projet");
    			attr_dev(i, "class", "fas fa-plus");
    			add_location(i, file$r, 150, 8, 4515);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn btn-secondary project-creation-button svelte-15anl0h");
    			attr_dev(button0, "title", "Créer un projet");
    			add_location(button0, file$r, 149, 4, 4378);
    			attr_dev(main, "class", "projects-board svelte-15anl0h");
    			add_location(main, file$r, 147, 0, 4343);
    			add_location(style, file$r, 162, 4, 4793);
    			attr_dev(h5, "id", "create-channel-modal-title");
    			attr_dev(h5, "class", "modal-title svelte-15anl0h");
    			add_location(h5, file$r, 170, 16, 5024);
    			attr_dev(span0, "aria-hidden", "true");
    			add_location(span0, file$r, 172, 20, 5238);
    			attr_dev(button1, "id", "ErrorClose");
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "close");
    			attr_dev(button1, "data-dismiss", "modal");
    			attr_dev(button1, "aria-label", "Close");
    			add_location(button1, file$r, 171, 16, 5125);
    			attr_dev(div0, "class", "modal-header");
    			add_location(div0, file$r, 169, 12, 4981);
    			attr_dev(label0, "for", "projectLabel");
    			add_location(label0, file$r, 178, 24, 5478);
    			attr_dev(input0, "class", "form-control");
    			attr_dev(input0, "id", "projectLabel");
    			attr_dev(input0, "name", "projectLabel");
    			attr_dev(input0, "type", "text");
    			input0.required = true;
    			add_location(input0, file$r, 179, 24, 5542);
    			attr_dev(div1, "class", "invalid-feedback");
    			add_location(div1, file$r, 180, 24, 5681);
    			attr_dev(div2, "class", "mb-3");
    			add_location(div2, file$r, 177, 20, 5435);
    			attr_dev(label1, "for", "projectKey");
    			add_location(label1, file$r, 185, 24, 5893);
    			attr_dev(input1, "class", "form-control");
    			attr_dev(input1, "id", "projectKey");
    			attr_dev(input1, "name", "projectKey");
    			attr_dev(input1, "type", "text");
    			input1.required = true;
    			add_location(input1, file$r, 186, 24, 5970);
    			attr_dev(div3, "class", "invalid-feedback");
    			add_location(div3, file$r, 187, 24, 6103);
    			attr_dev(div4, "class", "mb-3");
    			add_location(div4, file$r, 184, 20, 5850);
    			attr_dev(label2, "for", "projectDescription");
    			add_location(label2, file$r, 192, 24, 6355);
    			attr_dev(textarea, "class", "form-control");
    			attr_dev(textarea, "id", "projectDescription");
    			attr_dev(textarea, "name", "projectDescription");
    			attr_dev(textarea, "rows", "4");
    			attr_dev(textarea, "placeholder", "Taper une description pour votre projet");
    			add_location(textarea, file$r, 193, 24, 6441);
    			attr_dev(div5, "class", "mb-3");
    			add_location(div5, file$r, 191, 20, 6312);
    			attr_dev(form, "id", "CreateProjectForm");
    			attr_dev(form, "class", "");
    			add_location(form, file$r, 176, 16, 5376);
    			attr_dev(div6, "class", "modal-body");
    			add_location(div6, file$r, 175, 12, 5335);
    			attr_dev(div7, "id", "errorOnCreatingProjectContent");
    			add_location(div7, file$r, 199, 20, 6835);
    			attr_dev(div8, "id", "errorOnCreatingProject");
    			attr_dev(div8, "class", "alert alert-danger fade svelte-15anl0h");
    			add_location(div8, file$r, 198, 16, 6749);
    			attr_dev(span1, "id", "creating-project-loading");
    			attr_dev(span1, "class", "spinner-border svelte-15anl0h");
    			add_location(span1, file$r, 201, 95, 7000);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn action btn-danger  svelte-15anl0h");
    			add_location(button2, file$r, 201, 16, 6921);
    			attr_dev(div9, "class", "modal-footer modal-footer-createChannel svelte-15anl0h");
    			add_location(div9, file$r, 197, 12, 6679);
    			attr_dev(div10, "class", "modal-content");
    			add_location(div10, file$r, 168, 8, 4941);
    			attr_dev(div11, "class", "modal-dialog modal-dialog-centered modal-lg");
    			add_location(div11, file$r, 167, 4, 4875);
    			attr_dev(div12, "id", "CreateProjectModal");
    			attr_dev(div12, "class", "modal fade ");
    			attr_dev(div12, "data-keyboard", "false");
    			add_location(div12, file$r, 161, 0, 4717);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, button0);
    			append_dev(button0, i);
    			append_dev(main, t0);
    			if (if_block) if_block.m(main, null);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div12, anchor);
    			append_dev(div12, style);
    			append_dev(div12, t3);
    			append_dev(div12, div11);
    			append_dev(div11, div10);
    			append_dev(div10, div0);
    			append_dev(div0, h5);
    			append_dev(div0, t5);
    			append_dev(div0, button1);
    			append_dev(button1, span0);
    			append_dev(div10, t7);
    			append_dev(div10, div6);
    			append_dev(div6, form);
    			append_dev(form, div2);
    			append_dev(div2, label0);
    			append_dev(div2, t9);
    			append_dev(div2, input0);
    			append_dev(div2, t10);
    			append_dev(div2, div1);
    			append_dev(form, t12);
    			append_dev(form, div4);
    			append_dev(div4, label1);
    			append_dev(div4, t14);
    			append_dev(div4, input1);
    			append_dev(div4, t15);
    			append_dev(div4, div3);
    			append_dev(form, t17);
    			append_dev(form, div5);
    			append_dev(div5, label2);
    			append_dev(div5, t19);
    			append_dev(div5, textarea);
    			append_dev(div10, t20);
    			append_dev(div10, div9);
    			append_dev(div9, div8);
    			append_dev(div8, div7);
    			append_dev(div9, t21);
    			append_dev(div9, button2);
    			append_dev(button2, span1);
    			append_dev(button2, t22);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", displayCreateProject, false, false, false),
    					listen_dev(input0, "change", onLabelChanged, false, false, false),
    					listen_dev(input1, "change", /*onKeyChanged*/ ctx[1], false, false, false),
    					listen_dev(button2, "click", /*createProject*/ ctx[2], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$ProjectStore*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$ProjectStore*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$h(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(main, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if (if_block) if_block.d();
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div12);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function displayCreateProject() {
    	jQuery("#CreateProjectModal").modal("show");
    }

    async function onLabelChanged() {
    	const keyInput = document.getElementById("projectKey");
    	const labelInput = document.getElementById("projectLabel");

    	if (!keyInput.value) {
    		keyInput.value = labelInput.value;
    		keyInput.dispatchEvent(new Event("change"));
    	}

    	if (!labelInput) {
    		labelInput.classList.remove("is-valid");
    		labelInput.classList.add("is-invalid");
    	} else {
    		labelInput.classList.remove("is-invalid");
    		labelInput.classList.add("is-valid");
    	}
    }

    async function validateNewProject() {
    	return true;
    }

    function instance$t($$self, $$props, $$invalidate) {
    	let $ProjectStore;
    	validate_store(ProjectStore, "ProjectStore");
    	component_subscribe($$self, ProjectStore, $$value => $$invalidate(0, $ProjectStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ContentProjectsContainer", slots, []);

    	async function onKeyChanged(event) {
    		const backendService = await dist$1.getBackendClient();
    		const keyInput = document.getElementById("projectKey");
    		const labelInput = document.getElementById("projectLabel");

    		if (!labelInput.value) {
    			labelInput.value = keyInput.value;
    		}

    		if (!labelInput) {
    			labelInput.classList.add("is-invalid");
    			labelInput.dispatchEvent(new Event("change"));
    		} else {
    			if (await backendService.projectsService.exists(keyInput.value)) {
    				keyInput.classList.remove("is-valid");
    				keyInput.classList.add("is-invalid");
    			} else {
    				keyInput.classList.remove("is-invalid");
    				keyInput.classList.add("is-valid");
    			}
    		}
    	}

    	async function createProject() {
    		const errorAlertContent = document.getElementById("errorOnCreatingProjectContent");
    		const errorAlert = document.getElementById("errorOnCreatingProject");

    		if (await validateNewProject()) {
    			try {
    				const backendService = await dist$1.getBackendClient();

    				const data = {
    					key: document.querySelector("#projectKey").value,
    					label: document.querySelector("#projectLabel").value,
    					description: document.querySelector("#projectDescription").value
    				};

    				const project = await backendService.projectsService.createProject(data.label, data.key, data.description);
    				jQuery("#CreateProjectModal").modal("hide");
    				document.querySelector("#projectKey").value = null;
    				document.querySelector("#projectLabel").value = null;
    				document.querySelector("#projectDescription").value = null;

    				ProjectStore.update(ps => {
    					ps.push(project);
    					return ps;
    				});
    			} catch(error) {
    				console.log(error);
    				errorAlertContent.innerText = error.message;
    				errorAlert.classList.add("show");
    			}
    		} else {
    			errorAlertContent.innerText = "Impossible de créer le projet. Vérifier ses paramètres";
    			errorAlert.classList.add("show");
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$e.warn(`<ContentProjectsContainer> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		ProjectStore,
    		ProjectCard,
    		getBackendClient: dist$1.getBackendClient,
    		displayCreateProject,
    		onLabelChanged,
    		onKeyChanged,
    		validateNewProject,
    		createProject,
    		$ProjectStore
    	});

    	return [$ProjectStore, onKeyChanged, createProject];
    }

    class ContentProjectsContainer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$t, create_fragment$t, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ContentProjectsContainer",
    			options,
    			id: create_fragment$t.name
    		});
    	}
    }

    class BlockEditorComponent {
    }
    const BlockEditorComponentStore = writable(new BlockEditorComponent());

    /* src/components/Documents/ContentDocumentsContainer.svelte generated by Svelte v3.38.2 */

    const { console: console_1$d } = globals;
    const file$q = "src/components/Documents/ContentDocumentsContainer.svelte";

    function get_each_context$d(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	return child_ctx;
    }

    // (237:16) {#if Array.isArray($observableGenericDataStore.data)}
    function create_if_block_1$c(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*$observableGenericDataStore*/ ctx[0].data;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$d(get_each_context$d(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$observableGenericDataStore, editDocument, displayDocument, Date*/ 7) {
    				each_value = /*$observableGenericDataStore*/ ctx[0].data;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$d(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$d(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$c.name,
    		type: "if",
    		source: "(237:16) {#if Array.isArray($observableGenericDataStore.data)}",
    		ctx
    	});

    	return block;
    }

    // (246:32) {#if document.isReader}
    function create_if_block_3$5(ctx) {
    	let button;
    	let i;
    	let button_data_document_key_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			i = element("i");
    			attr_dev(i, "class", "fas fa-book-reader");
    			add_location(i, file$q, 246, 171, 8862);
    			attr_dev(button, "data-document-key", button_data_document_key_value = /*document*/ ctx[10].key);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "class", "btn btn-secondary");
    			attr_dev(button, "title", "Voir le document");
    			add_location(button, file$q, 246, 36, 8727);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, i);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*displayDocument*/ ctx[1], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$observableGenericDataStore*/ 1 && button_data_document_key_value !== (button_data_document_key_value = /*document*/ ctx[10].key)) {
    				attr_dev(button, "data-document-key", button_data_document_key_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$5.name,
    		type: "if",
    		source: "(246:32) {#if document.isReader}",
    		ctx
    	});

    	return block;
    }

    // (249:32) {#if document.isEditor}
    function create_if_block_2$7(ctx) {
    	let button;
    	let i;
    	let button_data_document_key_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			i = element("i");
    			attr_dev(i, "class", "fas fa-edit");
    			add_location(i, file$q, 249, 170, 9170);
    			attr_dev(button, "data-document-key", button_data_document_key_value = /*document*/ ctx[10].key);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "class", "btn btn-secondary");
    			attr_dev(button, "title", "Editer le document");
    			add_location(button, file$q, 249, 36, 9036);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, i);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*editDocument*/ ctx[2], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$observableGenericDataStore*/ 1 && button_data_document_key_value !== (button_data_document_key_value = /*document*/ ctx[10].key)) {
    				attr_dev(button, "data-document-key", button_data_document_key_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$7.name,
    		type: "if",
    		source: "(249:32) {#if document.isEditor}",
    		ctx
    	});

    	return block;
    }

    // (238:20) {#each $observableGenericDataStore.data as document}
    function create_each_block$d(ctx) {
    	let tr;
    	let th0;
    	let t0_value = /*document*/ ctx[10].id + "";
    	let t0;
    	let t1;
    	let th1;
    	let t2_value = /*document*/ ctx[10].key + "";
    	let t2;
    	let t3;
    	let th2;

    	let t4_value = (/*document*/ ctx[10].author
    	? /*document*/ ctx[10].author.login
    	: "") + "";

    	let t4;
    	let t5;
    	let th3;

    	let t6_value = (/*document*/ ctx[10].creationDate
    	? new Date(/*document*/ ctx[10].creationDate).toLocaleString()
    	: "") + "";

    	let t6;
    	let t7;
    	let th4;

    	let t8_value = (/*document*/ ctx[10].updateDate
    	? new Date(/*document*/ ctx[10].updateDate).toLocaleString()
    	: "") + "";

    	let t8;
    	let t9;
    	let th5;
    	let t10;
    	let t11;
    	let tr_data_document_id_value;
    	let tr_transition;
    	let current;
    	let if_block0 = /*document*/ ctx[10].isReader && create_if_block_3$5(ctx);
    	let if_block1 = /*document*/ ctx[10].isEditor && create_if_block_2$7(ctx);

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			th0 = element("th");
    			t0 = text(t0_value);
    			t1 = space();
    			th1 = element("th");
    			t2 = text(t2_value);
    			t3 = space();
    			th2 = element("th");
    			t4 = text(t4_value);
    			t5 = space();
    			th3 = element("th");
    			t6 = text(t6_value);
    			t7 = space();
    			th4 = element("th");
    			t8 = text(t8_value);
    			t9 = space();
    			th5 = element("th");
    			if (if_block0) if_block0.c();
    			t10 = space();
    			if (if_block1) if_block1.c();
    			t11 = space();
    			attr_dev(th0, "scope", "row");
    			add_location(th0, file$q, 239, 28, 8201);
    			attr_dev(th1, "scope", "row");
    			add_location(th1, file$q, 240, 28, 8264);
    			add_location(th2, file$q, 241, 28, 8328);
    			add_location(th3, file$q, 242, 28, 8408);
    			add_location(th4, file$q, 243, 28, 8521);
    			add_location(th5, file$q, 244, 28, 8630);
    			attr_dev(tr, "data-document-id", tr_data_document_id_value = /*document*/ ctx[10].id);
    			add_location(tr, file$q, 238, 24, 8119);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, th0);
    			append_dev(th0, t0);
    			append_dev(tr, t1);
    			append_dev(tr, th1);
    			append_dev(th1, t2);
    			append_dev(tr, t3);
    			append_dev(tr, th2);
    			append_dev(th2, t4);
    			append_dev(tr, t5);
    			append_dev(tr, th3);
    			append_dev(th3, t6);
    			append_dev(tr, t7);
    			append_dev(tr, th4);
    			append_dev(th4, t8);
    			append_dev(tr, t9);
    			append_dev(tr, th5);
    			if (if_block0) if_block0.m(th5, null);
    			append_dev(th5, t10);
    			if (if_block1) if_block1.m(th5, null);
    			append_dev(th5, t11);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*$observableGenericDataStore*/ 1) && t0_value !== (t0_value = /*document*/ ctx[10].id + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*$observableGenericDataStore*/ 1) && t2_value !== (t2_value = /*document*/ ctx[10].key + "")) set_data_dev(t2, t2_value);

    			if ((!current || dirty & /*$observableGenericDataStore*/ 1) && t4_value !== (t4_value = (/*document*/ ctx[10].author
    			? /*document*/ ctx[10].author.login
    			: "") + "")) set_data_dev(t4, t4_value);

    			if ((!current || dirty & /*$observableGenericDataStore*/ 1) && t6_value !== (t6_value = (/*document*/ ctx[10].creationDate
    			? new Date(/*document*/ ctx[10].creationDate).toLocaleString()
    			: "") + "")) set_data_dev(t6, t6_value);

    			if ((!current || dirty & /*$observableGenericDataStore*/ 1) && t8_value !== (t8_value = (/*document*/ ctx[10].updateDate
    			? new Date(/*document*/ ctx[10].updateDate).toLocaleString()
    			: "") + "")) set_data_dev(t8, t8_value);

    			if (/*document*/ ctx[10].isReader) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_3$5(ctx);
    					if_block0.c();
    					if_block0.m(th5, t10);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*document*/ ctx[10].isEditor) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_2$7(ctx);
    					if_block1.c();
    					if_block1.m(th5, t11);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (!current || dirty & /*$observableGenericDataStore*/ 1 && tr_data_document_id_value !== (tr_data_document_id_value = /*document*/ ctx[10].id)) {
    				attr_dev(tr, "data-document-id", tr_data_document_id_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!tr_transition) tr_transition = create_bidirectional_transition(tr, fade, {}, true);
    				tr_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!tr_transition) tr_transition = create_bidirectional_transition(tr, fade, {}, false);
    			tr_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (detaching && tr_transition) tr_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$d.name,
    		type: "each",
    		source: "(238:20) {#each $observableGenericDataStore.data as document}",
    		ctx
    	});

    	return block;
    }

    // (257:12) {#if $observableGenericDataStore.hasNext}
    function create_if_block$g(ctx) {
    	let div;
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			button.textContent = "Afficher les data suivants";
    			attr_dev(button, "type", "button");
    			attr_dev(button, "class", "btn btn-danger");
    			add_location(button, file$q, 258, 16, 9490);
    			attr_dev(div, "class", "next-documents-wrapper svelte-fyi2z");
    			add_location(div, file$q, 257, 12, 9437);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*displayNextDocuments*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$g.name,
    		type: "if",
    		source: "(257:12) {#if $observableGenericDataStore.hasNext}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$s(ctx) {
    	let main;
    	let div0;
    	let ul;
    	let li;
    	let i;
    	let span0;
    	let t1;
    	let div2;
    	let h1;
    	let t3;
    	let div1;
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let t5;
    	let th1;
    	let t7;
    	let th2;
    	let t9;
    	let th3;
    	let t11;
    	let th4;
    	let t13;
    	let th5;
    	let t15;
    	let tbody;
    	let show_if = Array.isArray(/*$observableGenericDataStore*/ ctx[0].data);
    	let t16;
    	let t17;
    	let div14;
    	let style;
    	let t19;
    	let div13;
    	let div12;
    	let div3;
    	let h5;
    	let t21;
    	let button0;
    	let span1;
    	let t23;
    	let div8;
    	let div7;
    	let div5;
    	let label0;
    	let t25;
    	let input;
    	let t26;
    	let div4;
    	let t28;
    	let div6;
    	let label1;
    	let t30;
    	let select;
    	let option0;
    	let option1;
    	let option2;
    	let t34;
    	let div11;
    	let div10;
    	let div9;
    	let t35;
    	let button1;
    	let span2;
    	let t36;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = show_if && create_if_block_1$c(ctx);
    	let if_block1 = /*$observableGenericDataStore*/ ctx[0].hasNext && create_if_block$g(ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			div0 = element("div");
    			ul = element("ul");
    			li = element("li");
    			i = element("i");
    			span0 = element("span");
    			span0.textContent = "Créer un document";
    			t1 = space();
    			div2 = element("div");
    			h1 = element("h1");
    			h1.textContent = "Documents";
    			t3 = space();
    			div1 = element("div");
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			th0.textContent = "Id";
    			t5 = space();
    			th1 = element("th");
    			th1.textContent = "Clé";
    			t7 = space();
    			th2 = element("th");
    			th2.textContent = "Auteur";
    			t9 = space();
    			th3 = element("th");
    			th3.textContent = "Date de création";
    			t11 = space();
    			th4 = element("th");
    			th4.textContent = "Date de mise à jour";
    			t13 = space();
    			th5 = element("th");
    			th5.textContent = "Actions";
    			t15 = space();
    			tbody = element("tbody");
    			if (if_block0) if_block0.c();
    			t16 = space();
    			if (if_block1) if_block1.c();
    			t17 = space();
    			div14 = element("div");
    			style = element("style");
    			style.textContent = "label {\n            text-align: start;\n        }";
    			t19 = space();
    			div13 = element("div");
    			div12 = element("div");
    			div3 = element("div");
    			h5 = element("h5");
    			h5.textContent = "Créer un Document";
    			t21 = space();
    			button0 = element("button");
    			span1 = element("span");
    			span1.textContent = "×";
    			t23 = space();
    			div8 = element("div");
    			div7 = element("div");
    			div5 = element("div");
    			label0 = element("label");
    			label0.textContent = "Clé";
    			t25 = space();
    			input = element("input");
    			t26 = space();
    			div4 = element("div");
    			div4.textContent = "La clé ne peut pas être vide et doit être unique.";
    			t28 = space();
    			div6 = element("div");
    			label1 = element("label");
    			label1.textContent = "Visibilité";
    			t30 = space();
    			select = element("select");
    			option0 = element("option");
    			option0.textContent = "Privé";
    			option1 = element("option");
    			option1.textContent = "Protégé";
    			option2 = element("option");
    			option2.textContent = "Public";
    			t34 = space();
    			div11 = element("div");
    			div10 = element("div");
    			div9 = element("div");
    			t35 = space();
    			button1 = element("button");
    			span2 = element("span");
    			t36 = text("Créer le Document");
    			attr_dev(i, "class", "fas fa-2x fa-plus-circle");
    			add_location(i, file$q, 217, 16, 7231);
    			attr_dev(span0, "class", "svelte-fyi2z");
    			add_location(span0, file$q, 217, 56, 7271);
    			attr_dev(li, "class", "documentsAction list-group-item list-group-item-dark list-group-item-action svelte-fyi2z");
    			attr_dev(li, "id", "show-create-document");
    			add_location(li, file$q, 215, 12, 7054);
    			attr_dev(ul, "class", "list-group");
    			add_location(ul, file$q, 214, 8, 7018);
    			attr_dev(div0, "class", "documentsMenu svelte-fyi2z");
    			add_location(div0, file$q, 213, 4, 6982);
    			add_location(h1, file$q, 222, 8, 7385);
    			attr_dev(th0, "scope", "col");
    			add_location(th0, file$q, 227, 20, 7596);
    			attr_dev(th1, "scope", "col");
    			add_location(th1, file$q, 228, 20, 7640);
    			attr_dev(th2, "scope", "col");
    			add_location(th2, file$q, 229, 20, 7685);
    			attr_dev(th3, "scope", "col");
    			add_location(th3, file$q, 230, 20, 7733);
    			attr_dev(th4, "scope", "col");
    			add_location(th4, file$q, 231, 20, 7791);
    			attr_dev(th5, "scope", "col");
    			add_location(th5, file$q, 232, 20, 7852);
    			add_location(tr, file$q, 226, 16, 7571);
    			add_location(thead, file$q, 225, 16, 7547);
    			add_location(tbody, file$q, 235, 16, 7944);
    			attr_dev(table, "id", "documents-table");
    			attr_dev(table, "class", "documents table table-striped table-fixed svelte-fyi2z");
    			add_location(table, file$q, 224, 12, 7452);
    			attr_dev(div1, "class", "table-wrapper svelte-fyi2z");
    			add_location(div1, file$q, 223, 8, 7412);
    			attr_dev(div2, "class", "documentsList svelte-fyi2z");
    			add_location(div2, file$q, 221, 4, 7349);
    			attr_dev(main, "class", "documentsPanel svelte-fyi2z");
    			add_location(main, file$q, 212, 0, 6948);
    			add_location(style, file$q, 266, 4, 9751);
    			attr_dev(h5, "id", "create-channel-modal-title");
    			attr_dev(h5, "class", "modal-title");
    			add_location(h5, file$q, 275, 16, 9974);
    			attr_dev(span1, "aria-hidden", "true");
    			add_location(span1, file$q, 277, 20, 10182);
    			attr_dev(button0, "id", "ErrorClose");
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "close");
    			attr_dev(button0, "data-dismiss", "modal");
    			attr_dev(button0, "aria-label", "Close");
    			add_location(button0, file$q, 276, 16, 10069);
    			attr_dev(div3, "class", "modal-header");
    			add_location(div3, file$q, 274, 12, 9931);
    			attr_dev(label0, "for", "documentKey");
    			add_location(label0, file$q, 283, 24, 10422);
    			attr_dev(input, "class", "form-control");
    			attr_dev(input, "id", "documentKey");
    			attr_dev(input, "name", "documentKey");
    			attr_dev(input, "type", "text");
    			input.required = true;
    			add_location(input, file$q, 284, 24, 10483);
    			attr_dev(div4, "class", "invalid-feedback");
    			add_location(div4, file$q, 287, 24, 10686);
    			attr_dev(div5, "class", "mb-3");
    			add_location(div5, file$q, 282, 20, 10379);
    			attr_dev(label1, "for", "documentVisibility");
    			add_location(label1, file$q, 292, 24, 10916);
    			option0.__value = "private";
    			option0.value = option0.__value;
    			add_location(option0, file$q, 299, 28, 11500);
    			option1.__value = "protected";
    			option1.value = option1.__value;
    			add_location(option1, file$q, 300, 28, 11568);
    			option2.__value = "public";
    			option2.value = option2.__value;
    			add_location(option2, file$q, 301, 28, 11640);
    			attr_dev(select, "class", "form-select svelte-fyi2z");
    			attr_dev(select, "id", "documentVisibility");
    			attr_dev(select, "name", "documentVisibility");
    			select.required = true;
    			attr_dev(select, "title", "Un document privé n'est accessible et visible que par ses lecteurs et les administrateurs");
    			add_location(select, file$q, 293, 24, 10991);
    			attr_dev(div6, "class", "mb-3");
    			add_location(div6, file$q, 291, 20, 10873);
    			attr_dev(div7, "id", "CreateDocumentForm");
    			attr_dev(div7, "class", "");
    			add_location(div7, file$q, 281, 16, 10320);
    			attr_dev(div8, "class", "modal-body");
    			add_location(div8, file$q, 280, 12, 10279);
    			attr_dev(div9, "id", "errorOnCreatingDocumentContent");
    			add_location(div9, file$q, 308, 20, 11951);
    			attr_dev(div10, "id", "errorOnCreatingDocument");
    			attr_dev(div10, "class", "alert alert-danger fade");
    			add_location(div10, file$q, 307, 16, 11864);
    			attr_dev(span2, "id", "creating-document-loading");
    			attr_dev(span2, "class", "spinner-border svelte-fyi2z");
    			add_location(span2, file$q, 311, 20, 12139);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn action btn-danger  svelte-fyi2z");
    			add_location(button1, file$q, 310, 16, 12038);
    			attr_dev(div11, "class", "modal-footer modal-footer-createChannel");
    			add_location(div11, file$q, 306, 12, 11794);
    			attr_dev(div12, "class", "modal-content");
    			add_location(div12, file$q, 273, 8, 9891);
    			attr_dev(div13, "class", "modal-dialog modal-dialog-centered");
    			add_location(div13, file$q, 272, 4, 9834);
    			attr_dev(div14, "id", "CreateDocumentModal");
    			attr_dev(div14, "class", "modal fade");
    			attr_dev(div14, "data-keyboard", "false");
    			add_location(div14, file$q, 265, 0, 9675);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div0);
    			append_dev(div0, ul);
    			append_dev(ul, li);
    			append_dev(li, i);
    			append_dev(li, span0);
    			append_dev(main, t1);
    			append_dev(main, div2);
    			append_dev(div2, h1);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, table);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(tr, t5);
    			append_dev(tr, th1);
    			append_dev(tr, t7);
    			append_dev(tr, th2);
    			append_dev(tr, t9);
    			append_dev(tr, th3);
    			append_dev(tr, t11);
    			append_dev(tr, th4);
    			append_dev(tr, t13);
    			append_dev(tr, th5);
    			append_dev(table, t15);
    			append_dev(table, tbody);
    			if (if_block0) if_block0.m(tbody, null);
    			append_dev(div1, t16);
    			if (if_block1) if_block1.m(div1, null);
    			insert_dev(target, t17, anchor);
    			insert_dev(target, div14, anchor);
    			append_dev(div14, style);
    			append_dev(div14, t19);
    			append_dev(div14, div13);
    			append_dev(div13, div12);
    			append_dev(div12, div3);
    			append_dev(div3, h5);
    			append_dev(div3, t21);
    			append_dev(div3, button0);
    			append_dev(button0, span1);
    			append_dev(div12, t23);
    			append_dev(div12, div8);
    			append_dev(div8, div7);
    			append_dev(div7, div5);
    			append_dev(div5, label0);
    			append_dev(div5, t25);
    			append_dev(div5, input);
    			append_dev(div5, t26);
    			append_dev(div5, div4);
    			append_dev(div7, t28);
    			append_dev(div7, div6);
    			append_dev(div6, label1);
    			append_dev(div6, t30);
    			append_dev(div6, select);
    			append_dev(select, option0);
    			append_dev(select, option1);
    			append_dev(select, option2);
    			append_dev(div12, t34);
    			append_dev(div12, div11);
    			append_dev(div11, div10);
    			append_dev(div10, div9);
    			append_dev(div11, t35);
    			append_dev(div11, button1);
    			append_dev(button1, span2);
    			append_dev(button1, t36);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(li, "click", showCreateDocument, false, false, false),
    					listen_dev(input, "blur", /*onDocumentKeyChanged*/ ctx[3], false, false, false),
    					listen_dev(select, "blur", /*blur_handler*/ ctx[6], false, false, false),
    					listen_dev(button1, "click", /*createDocument*/ ctx[4], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$observableGenericDataStore*/ 1) show_if = Array.isArray(/*$observableGenericDataStore*/ ctx[0].data);

    			if (show_if) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*$observableGenericDataStore*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$c(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(tbody, null);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*$observableGenericDataStore*/ ctx[0].hasNext) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$g(ctx);
    					if_block1.c();
    					if_block1.m(div1, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (detaching) detach_dev(t17);
    			if (detaching) detach_dev(div14);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function showCreateDocument(event) {
    	jQuery("#CreateDocumentModal").modal("show");
    }

    function instance$s($$self, $$props, $$invalidate) {
    	let $observableGenericDataStore;
    	validate_store(observableGenericDataStore, "observableGenericDataStore");
    	component_subscribe($$self, observableGenericDataStore, $$value => $$invalidate(0, $observableGenericDataStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ContentDocumentsContainer", slots, []);
    	let documents = $observableGenericDataStore.data;

    	const unsubscribe = observableGenericDataStore.subscribe(ogd => {
    		documents = ogd.data;
    	});

    	async function displayDocument(event) {
    		await Helpers.displayDocument(event.currentTarget.getAttribute("data-document-key"));
    	}

    	async function editDocument(event) {
    		const services = await dist$1.getBackendClient();
    		const documentKey = event.currentTarget.getAttribute("data-document-key");
    		const documentContent = await services.documentService.getDocument(documentKey);

    		BlockEditorComponentStore.update(becs => {
    			becs.component = undefined;
    			becs.zone = undefined;
    			becs.layout = undefined;
    			return becs;
    		});

    		EditableDocumentStore.update(eds => {
    			eds.key = documentKey;
    			eds.document = documentContent;
    			return eds;
    		});

    		await Helpers.displayDocument("documentEditor");
    	}

    	async function onDocumentKeyChanged(event) {
    		const services = await dist$1.getBackendClient();
    		const keyInput = document.getElementById("documentKey");

    		if (!keyInput) {
    			keyInput.classList.add("is-invalid");
    		} else {
    			if (await services.documentService.exists(keyInput.value)) {
    				keyInput.classList.remove("is-valid");
    				keyInput.classList.add("is-invalid");
    			} else {
    				keyInput.classList.remove("is-invalid");
    				keyInput.classList.add("is-valid");
    			}
    		}
    	}

    	onMount(() => {
    		Helpers.subscribeToDocumentEvent(dist$1.documentsEventName.documentsActions, async documentActionEvent => {
    			const services = await dist$1.getBackendClient();
    			const document = await services.documentService.getDocument(documentActionEvent.detail.document);

    			observableGenericDataStore.update(ds => {
    				console.log("pushing to store");
    				ds.data.push(document);
    				return ds;
    			});
    		});
    	});

    	afterUpdate(() => {
    		const rows = Array.from(document.querySelectorAll("#documents-table tbody > tr"));
    		

    		rows.sort((r1, r2) => {
    			const r1Id = parseInt(r1.getAttribute("data-document-id"));
    			const r2Id = parseInt(r2.getAttribute("data-document-id"));
    			if (r1Id < r2Id) return 1;
    			if (r1Id > r2Id) return -1;
    			return 0;
    		});

    		const tableBody = document.querySelector("#documents-table tbody");

    		for (const row of rows) {
    			row.remove();
    			tableBody.append(row);
    		}
    	});

    	onDestroy(() => {
    		console.log("Destroying documents container");
    		unsubscribe();
    	});

    	async function validateNewDocument() {
    		const services = await dist$1.getBackendClient();
    		const key = document.getElementById("documentKey").value;
    		return key && !await services.documentService.exists(key);
    	}

    	async function createDocument(event) {
    		const errorAlertContent = document.getElementById("errorOnCreatingDocumentContent");
    		const errorAlert = document.getElementById("errorOnCreatingDocument");

    		if (await validateNewDocument()) {
    			try {
    				const backendService = await dist$1.getBackendClient();

    				const data = {
    					key: document.getElementById("documentKey").value,
    					visibility: document.getElementById("documentVisibility").value,
    					content: {}
    				};

    				await backendService.documentService.createDocument(data);
    				jQuery("#CreateDocumentModal").modal("hide");
    				document.getElementById("documentKey").value = null;
    				document.getElementById("documentVisibility").value = "private";
    			} catch(error) {
    				console.log(error);
    				errorAlertContent.innerText = error.message;
    				errorAlert.classList.add("show");
    			}
    		} else {
    			errorAlertContent.innerText = "Impossible de créer le Document. Vérifier ses paramètres";
    			errorAlert.classList.add("show");
    		}
    	}

    	async function displayNextDocuments() {
    		const services = await dist$1.getBackendClient();
    		const indexes = $observableGenericDataStore.data.map(d => d.id);
    		const minIndexes = Math.min(...indexes);
    		const nextDocuments = await services.documentService.findDocument({ lastIndex: minIndexes });
    		const lastIndex = Math.min(...nextDocuments.map(d => d.id));
    		const hasNext = (await services.documentService.findDocument({ lastIndex })).length > 0;

    		observableGenericDataStore.update(ds => {
    			for (const nd of nextDocuments) {
    				if (!ds.data.find(d => d.key === nd.key)) {
    					ds.data.push(nd);
    				}
    			}

    			ds.hasNext = hasNext;
    			return ds;
    		});
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$d.warn(`<ContentDocumentsContainer> was created with unknown prop '${key}'`);
    	});

    	const blur_handler = () => {
    		const visibility = document.getElementById("documentVisibility");
    		visibility.title = Helpers.visibilityTooltips[visibility.value];
    	};

    	$$self.$capture_state = () => ({
    		observableGenericDataStore,
    		Helpers,
    		EditableDocumentStore,
    		getBackendClient: dist$1.getBackendClient,
    		onMount,
    		afterUpdate,
    		onDestroy,
    		documentsEventName: dist$1.documentsEventName,
    		fade,
    		BlockEditorComponentStore,
    		documents,
    		unsubscribe,
    		displayDocument,
    		editDocument,
    		showCreateDocument,
    		onDocumentKeyChanged,
    		validateNewDocument,
    		createDocument,
    		displayNextDocuments,
    		$observableGenericDataStore
    	});

    	$$self.$inject_state = $$props => {
    		if ("documents" in $$props) documents = $$props.documents;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		$observableGenericDataStore,
    		displayDocument,
    		editDocument,
    		onDocumentKeyChanged,
    		createDocument,
    		displayNextDocuments,
    		blur_handler
    	];
    }

    class ContentDocumentsContainer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$s, create_fragment$s, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ContentDocumentsContainer",
    			options,
    			id: create_fragment$s.name
    		});
    	}
    }

    /* src/components/Editors/ContentDefaultEditor.svelte generated by Svelte v3.38.2 */

    function create_fragment$r(ctx) {
    	let highlightededitor;
    	let current;

    	highlightededitor = new HighlightedEditor({
    			props: {
    				id: /*id*/ ctx[1],
    				content: JSON.stringify(/*component*/ ctx[0], null, 4),
    				onChange: /*handleChange*/ ctx[2]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(highlightededitor.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(highlightededitor, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const highlightededitor_changes = {};
    			if (dirty & /*component*/ 1) highlightededitor_changes.content = JSON.stringify(/*component*/ ctx[0], null, 4);
    			highlightededitor.$set(highlightededitor_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(highlightededitor.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(highlightededitor.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(highlightededitor, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$r($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ContentDefaultEditor", slots, []);
    	let { component } = $$props;
    	let id = v4();

    	function handleChange(code) {
    		const newJson = JSON.parse(code);

    		for (const propName in newJson) {
    			if (newJson.hasOwnProperty(propName)) {
    				$$invalidate(0, component[propName] = newJson[propName], component);
    			}
    		}

    		EditableDocumentStore.update(eds => {
    			return eds;
    		});
    	}

    	const writable_props = ["component"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ContentDefaultEditor> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("component" in $$props) $$invalidate(0, component = $$props.component);
    	};

    	$$self.$capture_state = () => ({
    		EditableDocumentStore,
    		uuid: v4,
    		HighlightedEditor,
    		component,
    		id,
    		handleChange
    	});

    	$$self.$inject_state = $$props => {
    		if ("component" in $$props) $$invalidate(0, component = $$props.component);
    		if ("id" in $$props) $$invalidate(1, id = $$props.id);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [component, id, handleChange];
    }

    class ContentDefaultEditor extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$r, create_fragment$r, safe_not_equal, { component: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ContentDefaultEditor",
    			options,
    			id: create_fragment$r.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*component*/ ctx[0] === undefined && !("component" in props)) {
    			console.warn("<ContentDefaultEditor> was created without expected prop 'component'");
    		}
    	}

    	get component() {
    		throw new Error("<ContentDefaultEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set component(value) {
    		throw new Error("<ContentDefaultEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Editors/BlockEditor.svelte generated by Svelte v3.38.2 */
    const file$p = "src/components/Editors/BlockEditor.svelte";

    function get_each_context$c(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[6] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	return child_ctx;
    }

    function get_each_context_2$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[12] = list[i];
    	return child_ctx;
    }

    // (61:4) {#if component.properties.globalStyle}
    function create_if_block_5$2(ctx) {
    	let html_tag;
    	let raw_value = Helpers.styleOpeningLabel + /*component*/ ctx[0].properties.globalStyle + Helpers.styleClosingLabel + "";
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_anchor = empty$2();
    			html_tag = new HtmlTag(html_anchor);
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(raw_value, target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*component*/ 1 && raw_value !== (raw_value = Helpers.styleOpeningLabel + /*component*/ ctx[0].properties.globalStyle + Helpers.styleClosingLabel + "")) html_tag.p(raw_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$2.name,
    		type: "if",
    		source: "(61:4) {#if component.properties.globalStyle}",
    		ctx
    	});

    	return block;
    }

    // (82:4) {:else}
    function create_else_block$5(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "Ce bloc n'est pas affichable en mode édition du document";
    			add_location(div, file$p, 82, 8, 4064);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: noop$2,
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$5.name,
    		type: "else",
    		source: "(82:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (80:104) 
    function create_if_block_4$3(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = globalContentContainerFactory.getComponent(/*component*/ ctx[0].type);

    	function switch_props(ctx) {
    		return {
    			props: {
    				properties: /*component*/ ctx[0].properties
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty & /*component*/ 1) switch_instance_changes.properties = /*component*/ ctx[0].properties;

    			if (switch_value !== (switch_value = globalContentContainerFactory.getComponent(/*component*/ ctx[0].type))) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$3.name,
    		type: "if",
    		source: "(80:104) ",
    		ctx
    	});

    	return block;
    }

    // (64:4) {#if component.properties.headers || component.properties.bodies || component.properties.footers}
    function create_if_block$f(ctx) {
    	let show_if_2 = Array.isArray(/*component*/ ctx[0].properties.headers) && /*component*/ ctx[0].properties.headers.length > 0;
    	let t0;
    	let show_if_1 = Array.isArray(/*component*/ ctx[0].properties.bodies) && /*component*/ ctx[0].properties.bodies.length > 0;
    	let t1;
    	let show_if = Array.isArray(/*component*/ ctx[0].properties.footers) && /*component*/ ctx[0].properties.footers.length > 0;
    	let if_block2_anchor;
    	let current;
    	let if_block0 = show_if_2 && create_if_block_3$4(ctx);
    	let if_block1 = show_if_1 && create_if_block_2$6(ctx);
    	let if_block2 = show_if && create_if_block_1$b(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*component*/ 1) show_if_2 = Array.isArray(/*component*/ ctx[0].properties.headers) && /*component*/ ctx[0].properties.headers.length > 0;

    			if (show_if_2) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*component*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_3$4(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*component*/ 1) show_if_1 = Array.isArray(/*component*/ ctx[0].properties.bodies) && /*component*/ ctx[0].properties.bodies.length > 0;

    			if (show_if_1) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*component*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_2$6(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t1.parentNode, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*component*/ 1) show_if = Array.isArray(/*component*/ ctx[0].properties.footers) && /*component*/ ctx[0].properties.footers.length > 0;

    			if (show_if) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*component*/ 1) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_1$b(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$f.name,
    		type: "if",
    		source: "(64:4) {#if component.properties.headers || component.properties.bodies || component.properties.footers}",
    		ctx
    	});

    	return block;
    }

    // (65:8) {#if Array.isArray(component.properties.headers) && component.properties.headers.length > 0}
    function create_if_block_3$4(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_2 = /*component*/ ctx[0].properties.headers;
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*component, zone*/ 3) {
    				each_value_2 = /*component*/ ctx[0].properties.headers;
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$1(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_2$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_2.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_2.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$4.name,
    		type: "if",
    		source: "(65:8) {#if Array.isArray(component.properties.headers) && component.properties.headers.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (66:12) {#each component.properties.headers as headerComponent}
    function create_each_block_2$1(ctx) {
    	let blockeditor;
    	let current;

    	blockeditor = new BlockEditor({
    			props: {
    				component: /*headerComponent*/ ctx[12],
    				zone: /*zone*/ ctx[1]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(blockeditor.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(blockeditor, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const blockeditor_changes = {};
    			if (dirty & /*component*/ 1) blockeditor_changes.component = /*headerComponent*/ ctx[12];
    			if (dirty & /*zone*/ 2) blockeditor_changes.zone = /*zone*/ ctx[1];
    			blockeditor.$set(blockeditor_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(blockeditor.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(blockeditor.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(blockeditor, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$1.name,
    		type: "each",
    		source: "(66:12) {#each component.properties.headers as headerComponent}",
    		ctx
    	});

    	return block;
    }

    // (70:8) {#if Array.isArray(component.properties.bodies)  && component.properties.bodies.length > 0}
    function create_if_block_2$6(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_1 = /*component*/ ctx[0].properties.bodies;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*component, zone*/ 3) {
    				each_value_1 = /*component*/ ctx[0].properties.bodies;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$6.name,
    		type: "if",
    		source: "(70:8) {#if Array.isArray(component.properties.bodies)  && component.properties.bodies.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (71:12) {#each component.properties.bodies as bodyComponent}
    function create_each_block_1$2(ctx) {
    	let blockeditor;
    	let current;

    	blockeditor = new BlockEditor({
    			props: {
    				component: /*bodyComponent*/ ctx[9],
    				zone: /*zone*/ ctx[1]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(blockeditor.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(blockeditor, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const blockeditor_changes = {};
    			if (dirty & /*component*/ 1) blockeditor_changes.component = /*bodyComponent*/ ctx[9];
    			if (dirty & /*zone*/ 2) blockeditor_changes.zone = /*zone*/ ctx[1];
    			blockeditor.$set(blockeditor_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(blockeditor.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(blockeditor.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(blockeditor, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$2.name,
    		type: "each",
    		source: "(71:12) {#each component.properties.bodies as bodyComponent}",
    		ctx
    	});

    	return block;
    }

    // (75:8) {#if Array.isArray(component.properties.footers)  && component.properties.footers.length > 0}
    function create_if_block_1$b(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*component*/ ctx[0].properties.footers;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$c(get_each_context$c(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*component, zone*/ 3) {
    				each_value = /*component*/ ctx[0].properties.footers;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$c(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$c(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$b.name,
    		type: "if",
    		source: "(75:8) {#if Array.isArray(component.properties.footers)  && component.properties.footers.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (76:12) {#each component.properties.footers as footerComponent}
    function create_each_block$c(ctx) {
    	let blockeditor;
    	let current;

    	blockeditor = new BlockEditor({
    			props: {
    				component: /*footerComponent*/ ctx[6],
    				zone: /*zone*/ ctx[1]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(blockeditor.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(blockeditor, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const blockeditor_changes = {};
    			if (dirty & /*component*/ 1) blockeditor_changes.component = /*footerComponent*/ ctx[6];
    			if (dirty & /*zone*/ 2) blockeditor_changes.zone = /*zone*/ ctx[1];
    			blockeditor.$set(blockeditor_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(blockeditor.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(blockeditor.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(blockeditor, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$c.name,
    		type: "each",
    		source: "(76:12) {#each component.properties.footers as footerComponent}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$q(ctx) {
    	let div2;
    	let div1;
    	let div0;
    	let t1;
    	let t2;
    	let current_block_type_index;
    	let if_block1;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*component*/ ctx[0].properties.globalStyle && create_if_block_5$2(ctx);
    	const if_block_creators = [create_if_block$f, create_if_block_4$3, create_else_block$5];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*component*/ ctx[0].properties.headers || /*component*/ ctx[0].properties.bodies || /*component*/ ctx[0].properties.footers) return 0;
    		if (globalContentContainerFactory.registeredConstructors[/*component*/ ctx[0].type].canDisplayInEditMode) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			div0.textContent = "Editer";
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			if_block1.c();
    			attr_dev(div0, "class", "dropdown-item");
    			add_location(div0, file$p, 51, 8, 2010);
    			attr_dev(div1, "class", "contextual-menu dropdown-menu dropdown-menu-sm-left svelte-jmwqxh");
    			add_location(div1, file$p, 50, 4, 1936);
    			attr_dev(div2, "class", "component-container svelte-jmwqxh");
    			add_location(div2, file$p, 34, 0, 759);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div2, t1);
    			if (if_block0) if_block0.m(div2, null);
    			append_dev(div2, t2);
    			if_blocks[current_block_type_index].m(div2, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div0, "click", /*click_handler*/ ctx[4], false, false, false),
    					listen_dev(div2, "contextmenu", /*contextmenu_handler*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*component*/ ctx[0].properties.globalStyle) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_5$2(ctx);
    					if_block0.c();
    					if_block0.m(div2, t2);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				} else {
    					if_block1.p(ctx, dirty);
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(div2, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (if_block0) if_block0.d();
    			if_blocks[current_block_type_index].d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$q($$self, $$props, $$invalidate) {
    	let $BlockEditorComponentStore;
    	validate_store(BlockEditorComponentStore, "BlockEditorComponentStore");
    	component_subscribe($$self, BlockEditorComponentStore, $$value => $$invalidate(3, $BlockEditorComponentStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("BlockEditor", slots, []);
    	let { component } = $$props;
    	let { zone } = $$props;
    	let { layout } = $$props;
    	const writable_props = ["component", "zone", "layout"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<BlockEditor> was created with unknown prop '${key}'`);
    	});

    	const click_handler = event => {
    		event.stopPropagation();
    		event.preventDefault();

    		document.querySelectorAll(".contextual-menu").forEach(cm => {
    			cm.classList.remove("show");
    		});

    		set_store_value(BlockEditorComponentStore, $BlockEditorComponentStore.component = component, $BlockEditorComponentStore);
    		set_store_value(BlockEditorComponentStore, $BlockEditorComponentStore.zone = zone, $BlockEditorComponentStore);
    		set_store_value(BlockEditorComponentStore, $BlockEditorComponentStore.layout = layout, $BlockEditorComponentStore);
    	};

    	const contextmenu_handler = event => {
    		event.stopPropagation();
    		event.preventDefault();

    		if (!$BlockEditorComponentStore.component) {
    			document.querySelectorAll(".contextual-menu").forEach(cm => {
    				cm.classList.remove("show");
    			});

    			const contextMenu = event.target.closest(".component-container").querySelector(".contextual-menu");
    			contextMenu.classList.add("show");
    			contextMenu.style.top = `${event.y}px`;
    			contextMenu.style.left = `${event.x}px`;
    		}

    		document.addEventListener(
    			"click",
    			() => {
    				document.querySelectorAll(".contextual-menu").forEach(cm => {
    					cm.classList.remove("show");
    				});
    			},
    			{ once: true }
    		);
    	};

    	$$self.$$set = $$props => {
    		if ("component" in $$props) $$invalidate(0, component = $$props.component);
    		if ("zone" in $$props) $$invalidate(1, zone = $$props.zone);
    		if ("layout" in $$props) $$invalidate(2, layout = $$props.layout);
    	};

    	$$self.$capture_state = () => ({
    		BlockEditorComponentStore,
    		globalContentContainerFactory,
    		Helpers,
    		component,
    		zone,
    		layout,
    		$BlockEditorComponentStore
    	});

    	$$self.$inject_state = $$props => {
    		if ("component" in $$props) $$invalidate(0, component = $$props.component);
    		if ("zone" in $$props) $$invalidate(1, zone = $$props.zone);
    		if ("layout" in $$props) $$invalidate(2, layout = $$props.layout);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		component,
    		zone,
    		layout,
    		$BlockEditorComponentStore,
    		click_handler,
    		contextmenu_handler
    	];
    }

    class BlockEditor extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$q, create_fragment$q, safe_not_equal, { component: 0, zone: 1, layout: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "BlockEditor",
    			options,
    			id: create_fragment$q.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*component*/ ctx[0] === undefined && !("component" in props)) {
    			console.warn("<BlockEditor> was created without expected prop 'component'");
    		}

    		if (/*zone*/ ctx[1] === undefined && !("zone" in props)) {
    			console.warn("<BlockEditor> was created without expected prop 'zone'");
    		}

    		if (/*layout*/ ctx[2] === undefined && !("layout" in props)) {
    			console.warn("<BlockEditor> was created without expected prop 'layout'");
    		}
    	}

    	get component() {
    		throw new Error("<BlockEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set component(value) {
    		throw new Error("<BlockEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get zone() {
    		throw new Error("<BlockEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set zone(value) {
    		throw new Error("<BlockEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get layout() {
    		throw new Error("<BlockEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set layout(value) {
    		throw new Error("<BlockEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Documents/BlockDropZone.svelte generated by Svelte v3.38.2 */
    const file$o = "src/components/Documents/BlockDropZone.svelte";

    function create_fragment$p(ctx) {
    	let div;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "drop-zone svelte-1r8ui9q");
    			attr_dev(div, "data-zone", /*zone*/ ctx[0]);
    			attr_dev(div, "data-order", /*order*/ ctx[4]);
    			attr_dev(div, "data-row", /*row*/ ctx[1]);
    			attr_dev(div, "data-col", /*col*/ ctx[2]);
    			attr_dev(div, "data-layout", /*layout*/ ctx[3]);
    			toggle_class(div, "new-row", /*isNewRow*/ ctx[5]);
    			add_location(div, file$o, 29, 0, 472);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(div, "dragenter", /*dragenter_handler*/ ctx[8], false, false, false),
    					listen_dev(div, "dragleave", /*dragleave_handler*/ ctx[9], false, false, false),
    					listen_dev(div, "drop", /*drop_handler*/ ctx[10], false, false, false),
    					listen_dev(div, "dragover", dragover_handler, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*zone*/ 1) {
    				attr_dev(div, "data-zone", /*zone*/ ctx[0]);
    			}

    			if (dirty & /*order*/ 16) {
    				attr_dev(div, "data-order", /*order*/ ctx[4]);
    			}

    			if (dirty & /*row*/ 2) {
    				attr_dev(div, "data-row", /*row*/ ctx[1]);
    			}

    			if (dirty & /*col*/ 4) {
    				attr_dev(div, "data-col", /*col*/ ctx[2]);
    			}

    			if (dirty & /*layout*/ 8) {
    				attr_dev(div, "data-layout", /*layout*/ ctx[3]);
    			}

    			if (dirty & /*isNewRow*/ 32) {
    				toggle_class(div, "new-row", /*isNewRow*/ ctx[5]);
    			}
    		},
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const dragover_handler = event => {
    	event.preventDefault();
    	return false;
    };

    function instance$p($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("BlockDropZone", slots, []);
    	const dispatch = createEventDispatcher();
    	let { isBefore = false } = $$props;
    	let { zone } = $$props;
    	let { row } = $$props;
    	let { col } = $$props;
    	let { layout } = $$props;
    	let { order } = $$props;
    	let { isNewRow } = $$props;
    	const writable_props = ["isBefore", "zone", "row", "col", "layout", "order", "isNewRow"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<BlockDropZone> was created with unknown prop '${key}'`);
    	});

    	const dragenter_handler = event => {
    		event.preventDefault();
    		if (event.target) event.target.classList.add("on-hover");
    		dispatch("dragenter", event);
    	};

    	const dragleave_handler = event => {
    		event.preventDefault();
    		if (event.target) event.target.classList.remove("on-hover");
    		dispatch("dragleave", event);
    	};

    	const drop_handler = event => dispatch("drop", event);

    	$$self.$$set = $$props => {
    		if ("isBefore" in $$props) $$invalidate(7, isBefore = $$props.isBefore);
    		if ("zone" in $$props) $$invalidate(0, zone = $$props.zone);
    		if ("row" in $$props) $$invalidate(1, row = $$props.row);
    		if ("col" in $$props) $$invalidate(2, col = $$props.col);
    		if ("layout" in $$props) $$invalidate(3, layout = $$props.layout);
    		if ("order" in $$props) $$invalidate(4, order = $$props.order);
    		if ("isNewRow" in $$props) $$invalidate(5, isNewRow = $$props.isNewRow);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		dispatch,
    		isBefore,
    		zone,
    		row,
    		col,
    		layout,
    		order,
    		isNewRow
    	});

    	$$self.$inject_state = $$props => {
    		if ("isBefore" in $$props) $$invalidate(7, isBefore = $$props.isBefore);
    		if ("zone" in $$props) $$invalidate(0, zone = $$props.zone);
    		if ("row" in $$props) $$invalidate(1, row = $$props.row);
    		if ("col" in $$props) $$invalidate(2, col = $$props.col);
    		if ("layout" in $$props) $$invalidate(3, layout = $$props.layout);
    		if ("order" in $$props) $$invalidate(4, order = $$props.order);
    		if ("isNewRow" in $$props) $$invalidate(5, isNewRow = $$props.isNewRow);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		zone,
    		row,
    		col,
    		layout,
    		order,
    		isNewRow,
    		dispatch,
    		isBefore,
    		dragenter_handler,
    		dragleave_handler,
    		drop_handler
    	];
    }

    class BlockDropZone extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$p, create_fragment$p, safe_not_equal, {
    			isBefore: 7,
    			zone: 0,
    			row: 1,
    			col: 2,
    			layout: 3,
    			order: 4,
    			isNewRow: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "BlockDropZone",
    			options,
    			id: create_fragment$p.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*zone*/ ctx[0] === undefined && !("zone" in props)) {
    			console.warn("<BlockDropZone> was created without expected prop 'zone'");
    		}

    		if (/*row*/ ctx[1] === undefined && !("row" in props)) {
    			console.warn("<BlockDropZone> was created without expected prop 'row'");
    		}

    		if (/*col*/ ctx[2] === undefined && !("col" in props)) {
    			console.warn("<BlockDropZone> was created without expected prop 'col'");
    		}

    		if (/*layout*/ ctx[3] === undefined && !("layout" in props)) {
    			console.warn("<BlockDropZone> was created without expected prop 'layout'");
    		}

    		if (/*order*/ ctx[4] === undefined && !("order" in props)) {
    			console.warn("<BlockDropZone> was created without expected prop 'order'");
    		}

    		if (/*isNewRow*/ ctx[5] === undefined && !("isNewRow" in props)) {
    			console.warn("<BlockDropZone> was created without expected prop 'isNewRow'");
    		}
    	}

    	get isBefore() {
    		throw new Error("<BlockDropZone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isBefore(value) {
    		throw new Error("<BlockDropZone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get zone() {
    		throw new Error("<BlockDropZone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set zone(value) {
    		throw new Error("<BlockDropZone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get row() {
    		throw new Error("<BlockDropZone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set row(value) {
    		throw new Error("<BlockDropZone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get col() {
    		throw new Error("<BlockDropZone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set col(value) {
    		throw new Error("<BlockDropZone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get layout() {
    		throw new Error("<BlockDropZone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set layout(value) {
    		throw new Error("<BlockDropZone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get order() {
    		throw new Error("<BlockDropZone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set order(value) {
    		throw new Error("<BlockDropZone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isNewRow() {
    		throw new Error("<BlockDropZone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isNewRow(value) {
    		throw new Error("<BlockDropZone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Documents/ContentDocumentEditorZoneGridLayout.svelte generated by Svelte v3.38.2 */
    const file$n = "src/components/Documents/ContentDocumentEditorZoneGridLayout.svelte";

    function get_each_context$b(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i];
    	child_ctx[7] = i;
    	return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (75:4) {#if rowIndex > 0}
    function create_if_block_2$5(ctx) {
    	let blockdropzone;
    	let current;

    	blockdropzone = new BlockDropZone({
    			props: {
    				zone: /*zone*/ ctx[0],
    				layout: "grid",
    				row: /*rowIndex*/ ctx[7],
    				col: 0,
    				isNewRow: true
    			},
    			$$inline: true
    		});

    	blockdropzone.$on("drop", /*onDropComponent*/ ctx[2]);

    	const block = {
    		c: function create() {
    			create_component(blockdropzone.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(blockdropzone, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const blockdropzone_changes = {};
    			if (dirty & /*zone*/ 1) blockdropzone_changes.zone = /*zone*/ ctx[0];
    			blockdropzone.$set(blockdropzone_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(blockdropzone.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(blockdropzone.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(blockdropzone, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$5.name,
    		type: "if",
    		source: "(75:4) {#if rowIndex > 0}",
    		ctx
    	});

    	return block;
    }

    // (87:12) {#if component.col !== 0 &&             component.col !== null &&             typeof component.col === 'number' &&             !$EditableDocumentStore.document.content[zone].find(c => c.row === rowIndex &&                 c.col === component.col - 1)             }
    function create_if_block_1$a(ctx) {
    	let blockdropzone;
    	let current;

    	blockdropzone = new BlockDropZone({
    			props: {
    				zone: /*zone*/ ctx[0],
    				layout: "grid",
    				row: /*rowIndex*/ ctx[7],
    				col: /*colIndex*/ ctx[10] - 1
    			},
    			$$inline: true
    		});

    	blockdropzone.$on("drop", /*onDropComponent*/ ctx[2]);

    	const block = {
    		c: function create() {
    			create_component(blockdropzone.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(blockdropzone, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const blockdropzone_changes = {};
    			if (dirty & /*zone*/ 1) blockdropzone_changes.zone = /*zone*/ ctx[0];
    			blockdropzone.$set(blockdropzone_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(blockdropzone.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(blockdropzone.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(blockdropzone, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$a.name,
    		type: "if",
    		source: "(87:12) {#if component.col !== 0 &&             component.col !== null &&             typeof component.col === 'number' &&             !$EditableDocumentStore.document.content[zone].find(c => c.row === rowIndex &&                 c.col === component.col - 1)             }",
    		ctx
    	});

    	return block;
    }

    // (104:12) {#if component.col !== null &&             typeof component.col === 'number' &&             component.col + component.colSpan?component.colSpan:0 < 12 &&                 !$EditableDocumentStore.document.content[zone].find(c => c.row === rowIndex &&                 c.col === component.col + component.colSpan?component.colSpan:0)             }
    function create_if_block$e(ctx) {
    	let blockdropzone;
    	let current;

    	blockdropzone = new BlockDropZone({
    			props: {
    				zone: /*zone*/ ctx[0],
    				layout: "grid",
    				row: /*rowIndex*/ ctx[7],
    				col: /*colIndex*/ ctx[10] + (/*component*/ ctx[8].colSpan
    				? /*component*/ ctx[8].colSpan
    				: 0) + 1
    			},
    			$$inline: true
    		});

    	blockdropzone.$on("drop", /*onDropComponent*/ ctx[2]);

    	const block = {
    		c: function create() {
    			create_component(blockdropzone.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(blockdropzone, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const blockdropzone_changes = {};
    			if (dirty & /*zone*/ 1) blockdropzone_changes.zone = /*zone*/ ctx[0];

    			if (dirty & /*$EditableDocumentStore, zone*/ 3) blockdropzone_changes.col = /*colIndex*/ ctx[10] + (/*component*/ ctx[8].colSpan
    			? /*component*/ ctx[8].colSpan
    			: 0) + 1;

    			blockdropzone.$set(blockdropzone_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(blockdropzone.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(blockdropzone.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(blockdropzone, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$e.name,
    		type: "if",
    		source: "(104:12) {#if component.col !== null &&             typeof component.col === 'number' &&             component.col + component.colSpan?component.colSpan:0 < 12 &&                 !$EditableDocumentStore.document.content[zone].find(c => c.row === rowIndex &&                 c.col === component.col + component.colSpan?component.colSpan:0)             }",
    		ctx
    	});

    	return block;
    }

    // (86:8) {#each row as component,colIndex}
    function create_each_block_1$1(ctx) {
    	let show_if_1 = /*component*/ ctx[8].col !== 0 && /*component*/ ctx[8].col !== null && typeof /*component*/ ctx[8].col === "number" && !/*$EditableDocumentStore*/ ctx[1].document.content[/*zone*/ ctx[0]].find(func_1);
    	let t0;
    	let div;
    	let blockeditor;
    	let div_class_value;
    	let t1;

    	let show_if = /*component*/ ctx[8].col !== null && typeof /*component*/ ctx[8].col === "number" && /*component*/ ctx[8].col + /*component*/ ctx[8].colSpan
    	? /*component*/ ctx[8].colSpan
    	: !/*$EditableDocumentStore*/ ctx[1].document.content[/*zone*/ ctx[0]].find(func);

    	let if_block1_anchor;
    	let current;

    	function func(...args) {
    		return /*func*/ ctx[3](/*rowIndex*/ ctx[7], /*component*/ ctx[8], ...args);
    	}

    	function func_1(...args) {
    		return /*func_1*/ ctx[4](/*rowIndex*/ ctx[7], /*component*/ ctx[8], ...args);
    	}

    	let if_block0 = show_if_1 && create_if_block_1$a(ctx);

    	blockeditor = new BlockEditor({
    			props: {
    				component: /*component*/ ctx[8],
    				zone: /*zone*/ ctx[0],
    				layout: "grid"
    			},
    			$$inline: true
    		});

    	let if_block1 = show_if && create_if_block$e(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div = element("div");
    			create_component(blockeditor.$$.fragment);
    			t1 = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty$2();

    			attr_dev(div, "class", div_class_value = "components-col " + (/*component*/ ctx[8].colSpan
    			? `col-${/*component*/ ctx[8].colSpan}`
    			: "col") + " svelte-1pxjlwh");

    			add_location(div, file$n, 100, 12, 3126);
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(blockeditor, div, null);
    			insert_dev(target, t1, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*$EditableDocumentStore, zone*/ 3) show_if_1 = /*component*/ ctx[8].col !== 0 && /*component*/ ctx[8].col !== null && typeof /*component*/ ctx[8].col === "number" && !/*$EditableDocumentStore*/ ctx[1].document.content[/*zone*/ ctx[0]].find(func_1);

    			if (show_if_1) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*$EditableDocumentStore, zone*/ 3) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$a(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			const blockeditor_changes = {};
    			if (dirty & /*$EditableDocumentStore, zone*/ 3) blockeditor_changes.component = /*component*/ ctx[8];
    			if (dirty & /*zone*/ 1) blockeditor_changes.zone = /*zone*/ ctx[0];
    			blockeditor.$set(blockeditor_changes);

    			if (!current || dirty & /*$EditableDocumentStore, zone*/ 3 && div_class_value !== (div_class_value = "components-col " + (/*component*/ ctx[8].colSpan
    			? `col-${/*component*/ ctx[8].colSpan}`
    			: "col") + " svelte-1pxjlwh")) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (dirty & /*$EditableDocumentStore, zone*/ 3) show_if = /*component*/ ctx[8].col !== null && typeof /*component*/ ctx[8].col === "number" && /*component*/ ctx[8].col + /*component*/ ctx[8].colSpan
    			? /*component*/ ctx[8].colSpan
    			: !/*$EditableDocumentStore*/ ctx[1].document.content[/*zone*/ ctx[0]].find(func);

    			if (show_if) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*$EditableDocumentStore, zone*/ 3) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$e(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(blockeditor.$$.fragment, local);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(blockeditor.$$.fragment, local);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			destroy_component(blockeditor);
    			if (detaching) detach_dev(t1);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$1.name,
    		type: "each",
    		source: "(86:8) {#each row as component,colIndex}",
    		ctx
    	});

    	return block;
    }

    // (74:0) {#each Helpers.getRows($EditableDocumentStore.document.content[zone]) as row,rowIndex}
    function create_each_block$b(ctx) {
    	let t;
    	let div;
    	let current;
    	let if_block = /*rowIndex*/ ctx[7] > 0 && create_if_block_2$5(ctx);
    	let each_value_1 = /*row*/ ctx[5];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "row");
    			add_location(div, file$n, 84, 4, 2496);
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*rowIndex*/ ctx[7] > 0) if_block.p(ctx, dirty);

    			if (dirty & /*zone, Helpers, $EditableDocumentStore, onDropComponent*/ 7) {
    				each_value_1 = /*row*/ ctx[5];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$b.name,
    		type: "each",
    		source: "(74:0) {#each Helpers.getRows($EditableDocumentStore.document.content[zone]) as row,rowIndex}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$o(ctx) {
    	let t;
    	let blockdropzone;
    	let current;
    	let each_value = Helpers.getRows(/*$EditableDocumentStore*/ ctx[1].document.content[/*zone*/ ctx[0]]);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$b(get_each_context$b(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	blockdropzone = new BlockDropZone({
    			props: {
    				zone: /*zone*/ ctx[0],
    				layout: "grid",
    				row: !/*$EditableDocumentStore*/ ctx[1].document.content[/*zone*/ ctx[0]] || /*$EditableDocumentStore*/ ctx[1].document.content[/*zone*/ ctx[0]].length === 0
    				? 0
    				: Helpers.getLastRowIndex(/*$EditableDocumentStore*/ ctx[1].document.content[/*zone*/ ctx[0]]) + 1,
    				col: 0,
    				isNewRow: true
    			},
    			$$inline: true
    		});

    	blockdropzone.$on("drop", /*onDropComponent*/ ctx[2]);

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			create_component(blockdropzone.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, t, anchor);
    			mount_component(blockdropzone, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*Helpers, $EditableDocumentStore, zone, onDropComponent*/ 7) {
    				each_value = Helpers.getRows(/*$EditableDocumentStore*/ ctx[1].document.content[/*zone*/ ctx[0]]);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$b(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$b(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(t.parentNode, t);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			const blockdropzone_changes = {};
    			if (dirty & /*zone*/ 1) blockdropzone_changes.zone = /*zone*/ ctx[0];

    			if (dirty & /*$EditableDocumentStore, zone*/ 3) blockdropzone_changes.row = !/*$EditableDocumentStore*/ ctx[1].document.content[/*zone*/ ctx[0]] || /*$EditableDocumentStore*/ ctx[1].document.content[/*zone*/ ctx[0]].length === 0
    			? 0
    			: Helpers.getLastRowIndex(/*$EditableDocumentStore*/ ctx[1].document.content[/*zone*/ ctx[0]]) + 1;

    			blockdropzone.$set(blockdropzone_changes);
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(blockdropzone.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(blockdropzone.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(blockdropzone, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let $EditableDocumentStore;
    	validate_store(EditableDocumentStore, "EditableDocumentStore");
    	component_subscribe($$self, EditableDocumentStore, $$value => $$invalidate(1, $EditableDocumentStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ContentDocumentEditorZoneGridLayout", slots, []);
    	let { zone } = $$props;

    	function onDropComponent(event) {
    		event = event.detail;
    		if (event.target) event.target.classList.remove("on-hover");

    		const newBlock = {
    			order: typeof event.target.getAttribute("data-order") === "string"
    			? parseInt(event.target.getAttribute("data-order"))
    			: 0,
    			type: event.dataTransfer.getData("constructorType"),
    			properties: {}
    		};

    		const zone = event.target.getAttribute("data-zone");
    		let row = parseInt(event.target.getAttribute("data-row"));

    		if (event.target.classList.contains("new-row")) {
    			set_store_value(
    				EditableDocumentStore,
    				$EditableDocumentStore.document.content[zone] = $EditableDocumentStore.document.content[zone]
    				? $EditableDocumentStore.document.content[zone]
    				: [],
    				$EditableDocumentStore
    			);

    			for (const component of $EditableDocumentStore.document.content[zone]) {
    				if (component.properties.row >= row) {
    					component.properties.row++;
    				}
    			}
    		}

    		newBlock.properties.row = row;
    		newBlock.properties.col = parseInt(event.target.getAttribute("data-col"));

    		EditableDocumentStore.update(eds => {
    			if (!Array.isArray(eds.document.content[zone])) {
    				eds.document.content[zone] = [];
    			}

    			eds.document.content[zone].push(newBlock);
    			return eds;
    		});
    	}

    	const writable_props = ["zone"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ContentDocumentEditorZoneGridLayout> was created with unknown prop '${key}'`);
    	});

    	const func = (rowIndex, component, c) => c.row === rowIndex && c.col === component.col + component.colSpan
    	? component.colSpan
    	: 0;

    	const func_1 = (rowIndex, component, c) => c.row === rowIndex && c.col === component.col - 1;

    	$$self.$$set = $$props => {
    		if ("zone" in $$props) $$invalidate(0, zone = $$props.zone);
    	};

    	$$self.$capture_state = () => ({
    		Helpers,
    		EditableDocumentStore,
    		BlockEditor,
    		BlockDropZone,
    		zone,
    		onDropComponent,
    		$EditableDocumentStore
    	});

    	$$self.$inject_state = $$props => {
    		if ("zone" in $$props) $$invalidate(0, zone = $$props.zone);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [zone, $EditableDocumentStore, onDropComponent, func, func_1];
    }

    class ContentDocumentEditorZoneGridLayout extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$o, create_fragment$o, safe_not_equal, { zone: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ContentDocumentEditorZoneGridLayout",
    			options,
    			id: create_fragment$o.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*zone*/ ctx[0] === undefined && !("zone" in props)) {
    			console.warn("<ContentDocumentEditorZoneGridLayout> was created without expected prop 'zone'");
    		}
    	}

    	get zone() {
    		throw new Error("<ContentDocumentEditorZoneGridLayout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set zone(value) {
    		throw new Error("<ContentDocumentEditorZoneGridLayout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Documents/ContentDocumentEditorZoneStackLayout.svelte generated by Svelte v3.38.2 */

    const { console: console_1$c } = globals;

    function get_each_context$a(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	child_ctx[5] = i;
    	return child_ctx;
    }

    // (71:0) {:else}
    function create_else_block$4(ctx) {
    	let blockdropzone;
    	let current;

    	blockdropzone = new BlockDropZone({
    			props: { zone: /*zone*/ ctx[0], order: 0 },
    			$$inline: true
    		});

    	blockdropzone.$on("drop", /*onDropComponent*/ ctx[2]);

    	const block = {
    		c: function create() {
    			create_component(blockdropzone.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(blockdropzone, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const blockdropzone_changes = {};
    			if (dirty & /*zone*/ 1) blockdropzone_changes.zone = /*zone*/ ctx[0];
    			blockdropzone.$set(blockdropzone_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(blockdropzone.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(blockdropzone.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(blockdropzone, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(71:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (46:0) {#if $EditableDocumentStore &&      $EditableDocumentStore.document &&      $EditableDocumentStore.document.content &&      $EditableDocumentStore.document.content[zone] &&      Array.isArray($EditableDocumentStore.document.content[zone]) && $EditableDocumentStore.document.content[zone].length > 0}
    function create_if_block$d(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = [.../*$EditableDocumentStore*/ ctx[1].document.content[/*zone*/ ctx[0]]].sort(func);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$a(get_each_context$a(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*zone, $EditableDocumentStore, onDropComponent*/ 7) {
    				each_value = [.../*$EditableDocumentStore*/ ctx[1].document.content[/*zone*/ ctx[0]]].sort(func);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$a(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$a(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$d.name,
    		type: "if",
    		source: "(46:0) {#if $EditableDocumentStore &&      $EditableDocumentStore.document &&      $EditableDocumentStore.document.content &&      $EditableDocumentStore.document.content[zone] &&      Array.isArray($EditableDocumentStore.document.content[zone]) && $EditableDocumentStore.document.content[zone].length > 0}",
    		ctx
    	});

    	return block;
    }

    // (58:8) {#if index === 0}
    function create_if_block_1$9(ctx) {
    	let blockdropzone;
    	let current;

    	blockdropzone = new BlockDropZone({
    			props: {
    				zone: /*zone*/ ctx[0],
    				isBefore: true,
    				order: typeof /*component*/ ctx[3].order === "number"
    				? /*component*/ ctx[3].order - 1
    				: 0
    			},
    			$$inline: true
    		});

    	blockdropzone.$on("drop", /*onDropComponent*/ ctx[2]);

    	const block = {
    		c: function create() {
    			create_component(blockdropzone.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(blockdropzone, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const blockdropzone_changes = {};
    			if (dirty & /*zone*/ 1) blockdropzone_changes.zone = /*zone*/ ctx[0];

    			if (dirty & /*$EditableDocumentStore, zone*/ 3) blockdropzone_changes.order = typeof /*component*/ ctx[3].order === "number"
    			? /*component*/ ctx[3].order - 1
    			: 0;

    			blockdropzone.$set(blockdropzone_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(blockdropzone.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(blockdropzone.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(blockdropzone, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$9.name,
    		type: "if",
    		source: "(58:8) {#if index === 0}",
    		ctx
    	});

    	return block;
    }

    // (51:4) {#each [...$EditableDocumentStore.document.content[zone]].sort((c1, c2) => {         if(c1.order > c2.order)             return 1;         if(c1.order < c2.order)             return -1;         return 0;     }) as component, index}
    function create_each_block$a(ctx) {
    	let t0;
    	let blockeditor;
    	let t1;
    	let blockdropzone;
    	let current;
    	let if_block = /*index*/ ctx[5] === 0 && create_if_block_1$9(ctx);

    	blockeditor = new BlockEditor({
    			props: {
    				component: /*component*/ ctx[3],
    				zone: /*zone*/ ctx[0]
    			},
    			$$inline: true
    		});

    	blockdropzone = new BlockDropZone({
    			props: {
    				zone: /*zone*/ ctx[0],
    				order: typeof /*component*/ ctx[3].order === "number"
    				? /*component*/ ctx[3].order + 1
    				: 1
    			},
    			$$inline: true
    		});

    	blockdropzone.$on("drop", /*onDropComponent*/ ctx[2]);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t0 = space();
    			create_component(blockeditor.$$.fragment);
    			t1 = space();
    			create_component(blockdropzone.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(blockeditor, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(blockdropzone, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*index*/ ctx[5] === 0) if_block.p(ctx, dirty);
    			const blockeditor_changes = {};
    			if (dirty & /*$EditableDocumentStore, zone*/ 3) blockeditor_changes.component = /*component*/ ctx[3];
    			if (dirty & /*zone*/ 1) blockeditor_changes.zone = /*zone*/ ctx[0];
    			blockeditor.$set(blockeditor_changes);
    			const blockdropzone_changes = {};
    			if (dirty & /*zone*/ 1) blockdropzone_changes.zone = /*zone*/ ctx[0];

    			if (dirty & /*$EditableDocumentStore, zone*/ 3) blockdropzone_changes.order = typeof /*component*/ ctx[3].order === "number"
    			? /*component*/ ctx[3].order + 1
    			: 1;

    			blockdropzone.$set(blockdropzone_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(blockeditor.$$.fragment, local);
    			transition_in(blockdropzone.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(blockeditor.$$.fragment, local);
    			transition_out(blockdropzone.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(blockeditor, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(blockdropzone, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$a.name,
    		type: "each",
    		source: "(51:4) {#each [...$EditableDocumentStore.document.content[zone]].sort((c1, c2) => {         if(c1.order > c2.order)             return 1;         if(c1.order < c2.order)             return -1;         return 0;     }) as component, index}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$n(ctx) {
    	let show_if;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$d, create_else_block$4];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (dirty & /*$EditableDocumentStore, zone*/ 3) show_if = !!(/*$EditableDocumentStore*/ ctx[1] && /*$EditableDocumentStore*/ ctx[1].document && /*$EditableDocumentStore*/ ctx[1].document.content && /*$EditableDocumentStore*/ ctx[1].document.content[/*zone*/ ctx[0]] && Array.isArray(/*$EditableDocumentStore*/ ctx[1].document.content[/*zone*/ ctx[0]]) && /*$EditableDocumentStore*/ ctx[1].document.content[/*zone*/ ctx[0]].length > 0);
    		if (show_if) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx, -1);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$2();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx, dirty);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const func = (c1, c2) => {
    	if (c1.order > c2.order) return 1;
    	if (c1.order < c2.order) return -1;
    	return 0;
    };

    function instance$n($$self, $$props, $$invalidate) {
    	let $EditableDocumentStore;
    	validate_store(EditableDocumentStore, "EditableDocumentStore");
    	component_subscribe($$self, EditableDocumentStore, $$value => $$invalidate(1, $EditableDocumentStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ContentDocumentEditorZoneStackLayout", slots, []);
    	let { zone } = $$props;

    	function onDropComponent(event) {
    		event = event.detail;
    		if (event.target) event.target.classList.remove("on-hover");

    		const newBlock = {
    			order: typeof event.target.getAttribute("data-order") === "string"
    			? parseInt(event.target.getAttribute("data-order"))
    			: 0,
    			type: event.dataTransfer.getData("constructorType"),
    			properties: {}
    		};

    		const zone = event.target.getAttribute("data-zone");

    		EditableDocumentStore.update(eds => {
    			if (!Array.isArray(eds.document.content[zone])) {
    				eds.document.content[zone] = [];
    			}

    			eds.document.content[zone].sort((c1, c2) => {
    				if (c1.order > c2.order) return 1;
    				if (c1.order < c2.order) return -1;
    				return 0;
    			});

    			eds.document.content[zone].splice(newBlock.order, 0, newBlock);

    			for (let index = 0; index < eds.document.content[zone].length; index++) {
    				eds.document.content[zone][index].order = index;
    			}

    			return eds;
    		});
    	}

    	afterUpdate(() => {
    		console.log(`after update in zone ${zone}`);
    		console.log($EditableDocumentStore);
    		console.log("#");
    	});

    	const writable_props = ["zone"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$c.warn(`<ContentDocumentEditorZoneStackLayout> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("zone" in $$props) $$invalidate(0, zone = $$props.zone);
    	};

    	$$self.$capture_state = () => ({
    		EditableDocumentStore,
    		BlockDropZone,
    		BlockEditor,
    		afterUpdate,
    		zone,
    		onDropComponent,
    		$EditableDocumentStore
    	});

    	$$self.$inject_state = $$props => {
    		if ("zone" in $$props) $$invalidate(0, zone = $$props.zone);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [zone, $EditableDocumentStore, onDropComponent];
    }

    class ContentDocumentEditorZoneStackLayout extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$n, create_fragment$n, safe_not_equal, { zone: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ContentDocumentEditorZoneStackLayout",
    			options,
    			id: create_fragment$n.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*zone*/ ctx[0] === undefined && !("zone" in props)) {
    			console_1$c.warn("<ContentDocumentEditorZoneStackLayout> was created without expected prop 'zone'");
    		}
    	}

    	get zone() {
    		throw new Error("<ContentDocumentEditorZoneStackLayout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set zone(value) {
    		throw new Error("<ContentDocumentEditorZoneStackLayout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Documents/ContentDocumentEditor.svelte generated by Svelte v3.38.2 */

    const { console: console_1$b } = globals;
    const file$m = "src/components/Documents/ContentDocumentEditor.svelte";

    function get_each_context$9(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[22] = list[i];
    	return child_ctx;
    }

    // (255:12) {#if constructorMetadata.title}
    function create_if_block_8(ctx) {
    	let div;
    	let mounted;
    	let dispose;

    	function dragstart_handler(...args) {
    		return /*dragstart_handler*/ ctx[7](/*constructorMetadata*/ ctx[22], ...args);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "draggable", "true");
    			attr_dev(div, "class", "content-button " + /*constructorMetadata*/ ctx[22].cssClasses + " svelte-1qrx6yd");
    			attr_dev(div, "title", /*constructorMetadata*/ ctx[22].title);
    			add_location(div, file$m, 255, 16, 6868);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (!mounted) {
    				dispose = listen_dev(div, "dragstart", dragstart_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8.name,
    		type: "if",
    		source: "(255:12) {#if constructorMetadata.title}",
    		ctx
    	});

    	return block;
    }

    // (254:8) {#each globalContentContainerFactory.getConstructors() as constructorMetadata}
    function create_each_block$9(ctx) {
    	let if_block_anchor;
    	let if_block = /*constructorMetadata*/ ctx[22].title && create_if_block_8(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*constructorMetadata*/ ctx[22].title) if_block.p(ctx, dirty);
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$9.name,
    		type: "each",
    		source: "(254:8) {#each globalContentContainerFactory.getConstructors() as constructorMetadata}",
    		ctx
    	});

    	return block;
    }

    // (269:8) {#if $EditableDocumentStore.document}
    function create_if_block_3$3(ctx) {
    	let t0;
    	let div0;
    	let button0;
    	let i0;
    	let t1;
    	let button1;
    	let i1;
    	let t2;
    	let div7;
    	let div2;
    	let h50;
    	let t3;
    	let div1;
    	let button2;
    	let i2;
    	let button2_class_value;
    	let t4;
    	let button3;
    	let i3;
    	let t5;
    	let header;
    	let current_block_type_index;
    	let if_block1;
    	let header_class_value;
    	let t6;
    	let div4;
    	let h51;
    	let t7;
    	let div3;
    	let button4;
    	let i4;
    	let button4_class_value;
    	let t8;
    	let button5;
    	let i5;
    	let button5_class_value;
    	let t9;
    	let main;
    	let current_block_type_index_1;
    	let if_block2;
    	let main_class_value;
    	let t10;
    	let div6;
    	let h52;
    	let t11;
    	let div5;
    	let button6;
    	let i6;
    	let button6_class_value;
    	let t12;
    	let button7;
    	let i7;
    	let button7_class_value;
    	let t13;
    	let footer;
    	let current_block_type_index_2;
    	let if_block3;
    	let footer_class_value;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = typeof /*$EditableDocumentStore*/ ctx[1].document.content.globalStyle === "string" && create_if_block_7$1(ctx);
    	const if_block_creators = [create_if_block_6$1, create_else_block_3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$EditableDocumentStore*/ ctx[1].document.content.layout && /*$EditableDocumentStore*/ ctx[1].document.content.layout.headers && /*$EditableDocumentStore*/ ctx[1].document.content.layout.headers.type === "grid") return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	const if_block_creators_1 = [create_if_block_5$1, create_else_block_2];
    	const if_blocks_1 = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*$EditableDocumentStore*/ ctx[1].document.content.layout && /*$EditableDocumentStore*/ ctx[1].document.content.layout.bodies && /*$EditableDocumentStore*/ ctx[1].document.content.layout.bodies.type === "grid") return 0;
    		return 1;
    	}

    	current_block_type_index_1 = select_block_type_1(ctx);
    	if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
    	const if_block_creators_2 = [create_if_block_4$2, create_else_block_1$1];
    	const if_blocks_2 = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*$EditableDocumentStore*/ ctx[1].document.content.layout && /*$EditableDocumentStore*/ ctx[1].document.content.layout.footers && /*$EditableDocumentStore*/ ctx[1].document.content.layout.footers.type === "grid") return 0;
    		return 1;
    	}

    	current_block_type_index_2 = select_block_type_2(ctx);
    	if_block3 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div0 = element("div");
    			button0 = element("button");
    			i0 = element("i");
    			t1 = space();
    			button1 = element("button");
    			i1 = element("i");
    			t2 = space();
    			div7 = element("div");
    			div2 = element("div");
    			h50 = element("h5");
    			t3 = text("En tête ");
    			div1 = element("div");
    			button2 = element("button");
    			i2 = element("i");
    			t4 = space();
    			button3 = element("button");
    			i3 = element("i");
    			t5 = space();
    			header = element("header");
    			if_block1.c();
    			t6 = space();
    			div4 = element("div");
    			h51 = element("h5");
    			t7 = text("Corps ");
    			div3 = element("div");
    			button4 = element("button");
    			i4 = element("i");
    			t8 = space();
    			button5 = element("button");
    			i5 = element("i");
    			t9 = space();
    			main = element("main");
    			if_block2.c();
    			t10 = space();
    			div6 = element("div");
    			h52 = element("h5");
    			t11 = text("Pied de page ");
    			div5 = element("div");
    			button6 = element("button");
    			i6 = element("i");
    			t12 = space();
    			button7 = element("button");
    			i7 = element("i");
    			t13 = space();
    			footer = element("footer");
    			if_block3.c();
    			attr_dev(i0, "class", "fas fa-save");
    			add_location(i0, file$m, 274, 20, 7854);
    			attr_dev(button0, "class", "toolbar-button svelte-1qrx6yd");
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "title", "Enregistrer");
    			add_location(button0, file$m, 273, 16, 7744);
    			attr_dev(i1, "class", "fas fa-cogs");
    			add_location(i1, file$m, 282, 20, 8314);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "toolbar-button svelte-1qrx6yd");
    			attr_dev(button1, "title", "Options du document");
    			add_location(button1, file$m, 276, 16, 7924);
    			attr_dev(div0, "class", "documentEditorMenuBar svelte-1qrx6yd");
    			add_location(div0, file$m, 272, 12, 7692);
    			attr_dev(i2, "class", "fas fa-layer-group");
    			add_location(i2, file$m, 314, 28, 10300);
    			attr_dev(button2, "id", "change-layout-headers-stack");
    			attr_dev(button2, "type", "button");

    			attr_dev(button2, "class", button2_class_value = "toolbar-button\n                        " + (/*$EditableDocumentStore*/ ctx[1].document.content.layout && /*$EditableDocumentStore*/ ctx[1].document.content.layout.headers && /*$EditableDocumentStore*/ ctx[1].document.content.layout.headers.type === "stack" || !/*$EditableDocumentStore*/ ctx[1].document.content.layout || !/*$EditableDocumentStore*/ ctx[1].document.content.layout.headers
    			? "active-layout"
    			: "") + " svelte-1qrx6yd");

    			attr_dev(button2, "title", "Mise en page colonne");
    			add_location(button2, file$m, 288, 24, 8572);
    			attr_dev(i3, "class", "fas fa-th-large");
    			add_location(i3, file$m, 335, 28, 11715);
    			attr_dev(button3, "id", "change-layout-headers-grid");
    			attr_dev(button3, "type", "button");

    			attr_dev(button3, "class", "toolbar-button " + (/*getZoneLayout*/ ctx[4]("headers") === "grid" || !/*getZoneLayout*/ ctx[4]("headers")
    			? "active-layout"
    			: "") + " svelte-1qrx6yd");

    			attr_dev(button3, "title", "Mise en page grille");
    			add_location(button3, file$m, 316, 24, 10393);
    			attr_dev(div1, "class", "section-layout svelte-1qrx6yd");
    			add_location(div1, file$m, 287, 32, 8519);
    			attr_dev(h50, "class", "svelte-1qrx6yd");
    			add_location(h50, file$m, 287, 20, 8507);
    			attr_dev(header, "id", "document-headers");

    			attr_dev(header, "class", header_class_value = "document-section document-headers " + (/*$BlockEditorComponentStore*/ ctx[2].zone === "headers"
    			? "reduced"
    			: "") + "\n                         " + (/*$EditableDocumentStore*/ ctx[1].document.content.layout && /*$EditableDocumentStore*/ ctx[1].document.content.layout.headers && /*$EditableDocumentStore*/ ctx[1].document.content.layout.headers.type === "grid"
    			? "container"
    			: "") + " svelte-1qrx6yd");

    			add_location(header, file$m, 338, 20, 11833);
    			attr_dev(div2, "id", "headers");
    			attr_dev(div2, "class", "section svelte-1qrx6yd");
    			add_location(div2, file$m, 286, 16, 8451);
    			attr_dev(i4, "class", "fas fa-layer-group");
    			add_location(i4, file$m, 382, 28, 14789);
    			attr_dev(button4, "id", "change-layout-bodies-stack");
    			attr_dev(button4, "type", "button");

    			attr_dev(button4, "class", button4_class_value = "toolbar-button\n                        " + (/*$EditableDocumentStore*/ ctx[1].document.content.layout && /*$EditableDocumentStore*/ ctx[1].document.content.layout.bodies && /*$EditableDocumentStore*/ ctx[1].document.content.layout.bodies.type === "stack" || !/*$EditableDocumentStore*/ ctx[1].document.content.layout || !/*$EditableDocumentStore*/ ctx[1].document.content.layout.bodies
    			? "active-layout"
    			: "") + " svelte-1qrx6yd");

    			attr_dev(button4, "title", "Mise en page colonne");
    			add_location(button4, file$m, 357, 24, 13085);
    			attr_dev(i5, "class", "fas fa-th-large");
    			add_location(i5, file$m, 406, 28, 16394);
    			attr_dev(button5, "id", "change-layout-bodies-grid");
    			attr_dev(button5, "type", "button");

    			attr_dev(button5, "class", button5_class_value = "toolbar-button " + (/*$EditableDocumentStore*/ ctx[1].document.content.layout && /*$EditableDocumentStore*/ ctx[1].document.content.layout.bodies && /*$EditableDocumentStore*/ ctx[1].document.content.layout.bodies.type === "grid"
    			? "active-layout"
    			: "") + " svelte-1qrx6yd");

    			attr_dev(button5, "title", "Mise en page grille");
    			add_location(button5, file$m, 384, 24, 14882);
    			attr_dev(div3, "class", "section-layout svelte-1qrx6yd");
    			add_location(div3, file$m, 356, 30, 13032);
    			attr_dev(h51, "class", "svelte-1qrx6yd");
    			add_location(h51, file$m, 356, 20, 13022);
    			attr_dev(main, "id", "document-bodies");

    			attr_dev(main, "class", main_class_value = "document-section document-main " + (/*$BlockEditorComponentStore*/ ctx[2].zone === "bodies"
    			? "reduced"
    			: "") + "\n                    " + (/*$EditableDocumentStore*/ ctx[1].document.content.layout && /*$EditableDocumentStore*/ ctx[1].document.content.layout.bodies && /*$EditableDocumentStore*/ ctx[1].document.content.layout.bodies.type === "grid"
    			? "container"
    			: "") + " svelte-1qrx6yd");

    			add_location(main, file$m, 409, 20, 16512);
    			attr_dev(div4, "id", "bodies");
    			attr_dev(div4, "class", "section svelte-1qrx6yd");
    			add_location(div4, file$m, 355, 16, 12968);
    			attr_dev(i6, "class", "fas fa-layer-group");
    			add_location(i6, file$m, 454, 28, 19499);
    			attr_dev(button6, "id", "change-layout-footers-stack");
    			attr_dev(button6, "type", "button");

    			attr_dev(button6, "class", button6_class_value = "toolbar-button\n                        " + (/*$EditableDocumentStore*/ ctx[1].document.content.layout && /*$EditableDocumentStore*/ ctx[1].document.content.layout.footers && /*$EditableDocumentStore*/ ctx[1].document.content.layout.footers.type === "stack" || !/*$EditableDocumentStore*/ ctx[1].document.content.layout || !/*$EditableDocumentStore*/ ctx[1].document.content.layout.footers
    			? "active-layout"
    			: "") + " svelte-1qrx6yd");

    			attr_dev(button6, "title", "Mise en page colonne");
    			add_location(button6, file$m, 428, 24, 17755);
    			attr_dev(i7, "class", "fas fa-th-large");
    			add_location(i7, file$m, 478, 28, 21122);
    			attr_dev(button7, "id", "change-layout-footers-grid");
    			attr_dev(button7, "type", "button");

    			attr_dev(button7, "class", button7_class_value = "toolbar-button " + (/*$EditableDocumentStore*/ ctx[1].document.content.layout && /*$EditableDocumentStore*/ ctx[1].document.content.layout.footers && /*$EditableDocumentStore*/ ctx[1].document.content.layout.footers.type === "grid"
    			? "active-layout"
    			: "") + " svelte-1qrx6yd");

    			attr_dev(button7, "title", "Mise en page grille");
    			add_location(button7, file$m, 456, 24, 19592);
    			attr_dev(div5, "class", "section-layout svelte-1qrx6yd");
    			add_location(div5, file$m, 427, 37, 17702);
    			attr_dev(h52, "class", "svelte-1qrx6yd");
    			add_location(h52, file$m, 427, 20, 17685);
    			attr_dev(footer, "id", "document-footers");

    			attr_dev(footer, "class", footer_class_value = "document-section document-footer " + (/*$BlockEditorComponentStore*/ ctx[2].zone === "footers"
    			? "reduced"
    			: "") + "\n                    " + (/*$EditableDocumentStore*/ ctx[1].document.content.layout && /*$EditableDocumentStore*/ ctx[1].document.content.layout.footers && /*$EditableDocumentStore*/ ctx[1].document.content.layout.footers.type === "grid"
    			? "container"
    			: "") + " svelte-1qrx6yd");

    			add_location(footer, file$m, 481, 20, 21236);
    			attr_dev(div6, "id", "footers");
    			attr_dev(div6, "class", "section svelte-1qrx6yd");
    			add_location(div6, file$m, 426, 16, 17630);
    			attr_dev(div7, "class", "documentEditorContent svelte-1qrx6yd");
    			add_location(div7, file$m, 285, 12, 8399);
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div0, anchor);
    			append_dev(div0, button0);
    			append_dev(button0, i0);
    			append_dev(div0, t1);
    			append_dev(div0, button1);
    			append_dev(button1, i1);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div2);
    			append_dev(div2, h50);
    			append_dev(h50, t3);
    			append_dev(h50, div1);
    			append_dev(div1, button2);
    			append_dev(button2, i2);
    			append_dev(div1, t4);
    			append_dev(div1, button3);
    			append_dev(button3, i3);
    			append_dev(div2, t5);
    			append_dev(div2, header);
    			if_blocks[current_block_type_index].m(header, null);
    			append_dev(div7, t6);
    			append_dev(div7, div4);
    			append_dev(div4, h51);
    			append_dev(h51, t7);
    			append_dev(h51, div3);
    			append_dev(div3, button4);
    			append_dev(button4, i4);
    			append_dev(div3, t8);
    			append_dev(div3, button5);
    			append_dev(button5, i5);
    			append_dev(div4, t9);
    			append_dev(div4, main);
    			if_blocks_1[current_block_type_index_1].m(main, null);
    			append_dev(div7, t10);
    			append_dev(div7, div6);
    			append_dev(div6, h52);
    			append_dev(h52, t11);
    			append_dev(h52, div5);
    			append_dev(div5, button6);
    			append_dev(button6, i6);
    			append_dev(div5, t12);
    			append_dev(div5, button7);
    			append_dev(button7, i7);
    			append_dev(div6, t13);
    			append_dev(div6, footer);
    			if_blocks_2[current_block_type_index_2].m(footer, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*saveDocument*/ ctx[3], false, false, false),
    					listen_dev(button1, "click", /*click_handler*/ ctx[8], false, false, false),
    					listen_dev(button2, "click", /*click_handler_1*/ ctx[9], false, false, false),
    					listen_dev(button3, "click", /*click_handler_2*/ ctx[10], false, false, false),
    					listen_dev(button4, "click", /*click_handler_3*/ ctx[11], false, false, false),
    					listen_dev(button5, "click", /*click_handler_4*/ ctx[12], false, false, false),
    					listen_dev(button6, "click", /*click_handler_5*/ ctx[13], false, false, false),
    					listen_dev(button7, "click", /*click_handler_6*/ ctx[14], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (typeof /*$EditableDocumentStore*/ ctx[1].document.content.globalStyle === "string") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_7$1(ctx);
    					if_block0.c();
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (!current || dirty & /*$EditableDocumentStore*/ 2 && button2_class_value !== (button2_class_value = "toolbar-button\n                        " + (/*$EditableDocumentStore*/ ctx[1].document.content.layout && /*$EditableDocumentStore*/ ctx[1].document.content.layout.headers && /*$EditableDocumentStore*/ ctx[1].document.content.layout.headers.type === "stack" || !/*$EditableDocumentStore*/ ctx[1].document.content.layout || !/*$EditableDocumentStore*/ ctx[1].document.content.layout.headers
    			? "active-layout"
    			: "") + " svelte-1qrx6yd")) {
    				attr_dev(button2, "class", button2_class_value);
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(header, null);
    			}

    			if (!current || dirty & /*$BlockEditorComponentStore, $EditableDocumentStore*/ 6 && header_class_value !== (header_class_value = "document-section document-headers " + (/*$BlockEditorComponentStore*/ ctx[2].zone === "headers"
    			? "reduced"
    			: "") + "\n                         " + (/*$EditableDocumentStore*/ ctx[1].document.content.layout && /*$EditableDocumentStore*/ ctx[1].document.content.layout.headers && /*$EditableDocumentStore*/ ctx[1].document.content.layout.headers.type === "grid"
    			? "container"
    			: "") + " svelte-1qrx6yd")) {
    				attr_dev(header, "class", header_class_value);
    			}

    			if (!current || dirty & /*$EditableDocumentStore*/ 2 && button4_class_value !== (button4_class_value = "toolbar-button\n                        " + (/*$EditableDocumentStore*/ ctx[1].document.content.layout && /*$EditableDocumentStore*/ ctx[1].document.content.layout.bodies && /*$EditableDocumentStore*/ ctx[1].document.content.layout.bodies.type === "stack" || !/*$EditableDocumentStore*/ ctx[1].document.content.layout || !/*$EditableDocumentStore*/ ctx[1].document.content.layout.bodies
    			? "active-layout"
    			: "") + " svelte-1qrx6yd")) {
    				attr_dev(button4, "class", button4_class_value);
    			}

    			if (!current || dirty & /*$EditableDocumentStore*/ 2 && button5_class_value !== (button5_class_value = "toolbar-button " + (/*$EditableDocumentStore*/ ctx[1].document.content.layout && /*$EditableDocumentStore*/ ctx[1].document.content.layout.bodies && /*$EditableDocumentStore*/ ctx[1].document.content.layout.bodies.type === "grid"
    			? "active-layout"
    			: "") + " svelte-1qrx6yd")) {
    				attr_dev(button5, "class", button5_class_value);
    			}

    			let previous_block_index_1 = current_block_type_index_1;
    			current_block_type_index_1 = select_block_type_1(ctx);

    			if (current_block_type_index_1 !== previous_block_index_1) {
    				group_outros();

    				transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
    					if_blocks_1[previous_block_index_1] = null;
    				});

    				check_outros();
    				if_block2 = if_blocks_1[current_block_type_index_1];

    				if (!if_block2) {
    					if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
    					if_block2.c();
    				}

    				transition_in(if_block2, 1);
    				if_block2.m(main, null);
    			}

    			if (!current || dirty & /*$BlockEditorComponentStore, $EditableDocumentStore*/ 6 && main_class_value !== (main_class_value = "document-section document-main " + (/*$BlockEditorComponentStore*/ ctx[2].zone === "bodies"
    			? "reduced"
    			: "") + "\n                    " + (/*$EditableDocumentStore*/ ctx[1].document.content.layout && /*$EditableDocumentStore*/ ctx[1].document.content.layout.bodies && /*$EditableDocumentStore*/ ctx[1].document.content.layout.bodies.type === "grid"
    			? "container"
    			: "") + " svelte-1qrx6yd")) {
    				attr_dev(main, "class", main_class_value);
    			}

    			if (!current || dirty & /*$EditableDocumentStore*/ 2 && button6_class_value !== (button6_class_value = "toolbar-button\n                        " + (/*$EditableDocumentStore*/ ctx[1].document.content.layout && /*$EditableDocumentStore*/ ctx[1].document.content.layout.footers && /*$EditableDocumentStore*/ ctx[1].document.content.layout.footers.type === "stack" || !/*$EditableDocumentStore*/ ctx[1].document.content.layout || !/*$EditableDocumentStore*/ ctx[1].document.content.layout.footers
    			? "active-layout"
    			: "") + " svelte-1qrx6yd")) {
    				attr_dev(button6, "class", button6_class_value);
    			}

    			if (!current || dirty & /*$EditableDocumentStore*/ 2 && button7_class_value !== (button7_class_value = "toolbar-button " + (/*$EditableDocumentStore*/ ctx[1].document.content.layout && /*$EditableDocumentStore*/ ctx[1].document.content.layout.footers && /*$EditableDocumentStore*/ ctx[1].document.content.layout.footers.type === "grid"
    			? "active-layout"
    			: "") + " svelte-1qrx6yd")) {
    				attr_dev(button7, "class", button7_class_value);
    			}

    			let previous_block_index_2 = current_block_type_index_2;
    			current_block_type_index_2 = select_block_type_2(ctx);

    			if (current_block_type_index_2 !== previous_block_index_2) {
    				group_outros();

    				transition_out(if_blocks_2[previous_block_index_2], 1, 1, () => {
    					if_blocks_2[previous_block_index_2] = null;
    				});

    				check_outros();
    				if_block3 = if_blocks_2[current_block_type_index_2];

    				if (!if_block3) {
    					if_block3 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);
    					if_block3.c();
    				}

    				transition_in(if_block3, 1);
    				if_block3.m(footer, null);
    			}

    			if (!current || dirty & /*$BlockEditorComponentStore, $EditableDocumentStore*/ 6 && footer_class_value !== (footer_class_value = "document-section document-footer " + (/*$BlockEditorComponentStore*/ ctx[2].zone === "footers"
    			? "reduced"
    			: "") + "\n                    " + (/*$EditableDocumentStore*/ ctx[1].document.content.layout && /*$EditableDocumentStore*/ ctx[1].document.content.layout.footers && /*$EditableDocumentStore*/ ctx[1].document.content.layout.footers.type === "grid"
    			? "container"
    			: "") + " svelte-1qrx6yd")) {
    				attr_dev(footer, "class", footer_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div7);
    			if_blocks[current_block_type_index].d();
    			if_blocks_1[current_block_type_index_1].d();
    			if_blocks_2[current_block_type_index_2].d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$3.name,
    		type: "if",
    		source: "(269:8) {#if $EditableDocumentStore.document}",
    		ctx
    	});

    	return block;
    }

    // (270:12) {#if typeof $EditableDocumentStore.document.content.globalStyle === "string"}
    function create_if_block_7$1(ctx) {
    	let html_tag;
    	let raw_value = Helpers.styleOpeningLabel + /*$EditableDocumentStore*/ ctx[1].document.content.globalStyle + Helpers.styleClosingLabel + "";
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_anchor = empty$2();
    			html_tag = new HtmlTag(html_anchor);
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(raw_value, target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$EditableDocumentStore*/ 2 && raw_value !== (raw_value = Helpers.styleOpeningLabel + /*$EditableDocumentStore*/ ctx[1].document.content.globalStyle + Helpers.styleClosingLabel + "")) html_tag.p(raw_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$1.name,
    		type: "if",
    		source: "(270:12) {#if typeof $EditableDocumentStore.document.content.globalStyle === \\\"string\\\"}",
    		ctx
    	});

    	return block;
    }

    // (351:20) {:else}
    function create_else_block_3(ctx) {
    	let contentdocumenteditorzonestacklayout;
    	let current;

    	contentdocumenteditorzonestacklayout = new ContentDocumentEditorZoneStackLayout({
    			props: { zone: "headers" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(contentdocumenteditorzonestacklayout.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(contentdocumenteditorzonestacklayout, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(contentdocumenteditorzonestacklayout.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(contentdocumenteditorzonestacklayout.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(contentdocumenteditorzonestacklayout, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_3.name,
    		type: "else",
    		source: "(351:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (347:20) {#if $EditableDocumentStore.document.content.layout &&                     $EditableDocumentStore.document.content.layout.headers &&                     $EditableDocumentStore.document.content.layout.headers.type === 'grid'}
    function create_if_block_6$1(ctx) {
    	let contentdocumenteditorzonegridlayout;
    	let current;

    	contentdocumenteditorzonegridlayout = new ContentDocumentEditorZoneGridLayout({
    			props: { zone: "headers" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(contentdocumenteditorzonegridlayout.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(contentdocumenteditorzonegridlayout, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(contentdocumenteditorzonegridlayout.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(contentdocumenteditorzonegridlayout.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(contentdocumenteditorzonegridlayout, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$1.name,
    		type: "if",
    		source: "(347:20) {#if $EditableDocumentStore.document.content.layout &&                     $EditableDocumentStore.document.content.layout.headers &&                     $EditableDocumentStore.document.content.layout.headers.type === 'grid'}",
    		ctx
    	});

    	return block;
    }

    // (422:24) {:else}
    function create_else_block_2(ctx) {
    	let contentdocumenteditorzonestacklayout;
    	let current;

    	contentdocumenteditorzonestacklayout = new ContentDocumentEditorZoneStackLayout({
    			props: { zone: "bodies" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(contentdocumenteditorzonestacklayout.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(contentdocumenteditorzonestacklayout, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(contentdocumenteditorzonestacklayout.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(contentdocumenteditorzonestacklayout.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(contentdocumenteditorzonestacklayout, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2.name,
    		type: "else",
    		source: "(422:24) {:else}",
    		ctx
    	});

    	return block;
    }

    // (418:24) {#if $EditableDocumentStore.document.content.layout &&                              $EditableDocumentStore.document.content.layout.bodies &&                              $EditableDocumentStore.document.content.layout.bodies.type === 'grid'}
    function create_if_block_5$1(ctx) {
    	let contentdocumenteditorzonegridlayout;
    	let current;

    	contentdocumenteditorzonegridlayout = new ContentDocumentEditorZoneGridLayout({
    			props: { zone: "bodies" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(contentdocumenteditorzonegridlayout.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(contentdocumenteditorzonegridlayout, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(contentdocumenteditorzonegridlayout.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(contentdocumenteditorzonegridlayout.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(contentdocumenteditorzonegridlayout, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$1.name,
    		type: "if",
    		source: "(418:24) {#if $EditableDocumentStore.document.content.layout &&                              $EditableDocumentStore.document.content.layout.bodies &&                              $EditableDocumentStore.document.content.layout.bodies.type === 'grid'}",
    		ctx
    	});

    	return block;
    }

    // (494:24) {:else}
    function create_else_block_1$1(ctx) {
    	let contentdocumenteditorzonestacklayout;
    	let current;

    	contentdocumenteditorzonestacklayout = new ContentDocumentEditorZoneStackLayout({
    			props: { zone: "footers" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(contentdocumenteditorzonestacklayout.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(contentdocumenteditorzonestacklayout, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(contentdocumenteditorzonestacklayout.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(contentdocumenteditorzonestacklayout.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(contentdocumenteditorzonestacklayout, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$1.name,
    		type: "else",
    		source: "(494:24) {:else}",
    		ctx
    	});

    	return block;
    }

    // (490:24) {#if $EditableDocumentStore.document.content.layout &&                         $EditableDocumentStore.document.content.layout.footers &&                         $EditableDocumentStore.document.content.layout.footers.type === 'grid'}
    function create_if_block_4$2(ctx) {
    	let contentdocumenteditorzonegridlayout;
    	let current;

    	contentdocumenteditorzonegridlayout = new ContentDocumentEditorZoneGridLayout({
    			props: { zone: "footers" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(contentdocumenteditorzonegridlayout.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(contentdocumenteditorzonegridlayout, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(contentdocumenteditorzonegridlayout.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(contentdocumenteditorzonegridlayout.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(contentdocumenteditorzonegridlayout, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$2.name,
    		type: "if",
    		source: "(490:24) {#if $EditableDocumentStore.document.content.layout &&                         $EditableDocumentStore.document.content.layout.footers &&                         $EditableDocumentStore.document.content.layout.footers.type === 'grid'}",
    		ctx
    	});

    	return block;
    }

    // (507:12) {#if $BlockEditorComponentStore.layout}
    function create_if_block_2$4(ctx) {
    	let label0;
    	let t1;
    	let div1;
    	let div0;
    	let label1;
    	let t3;
    	let input0;
    	let input0_value_value;
    	let t4;
    	let label2;
    	let t6;
    	let input1;
    	let input1_value_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			label0 = element("label");
    			label0.textContent = "Options de grille";
    			t1 = space();
    			div1 = element("div");
    			div0 = element("div");
    			label1 = element("label");
    			label1.textContent = "ligne";
    			t3 = space();
    			input0 = element("input");
    			t4 = space();
    			label2 = element("label");
    			label2.textContent = "Colonne";
    			t6 = space();
    			input1 = element("input");
    			attr_dev(label0, "for", "grid-options");
    			add_location(label0, file$m, 507, 16, 22714);
    			attr_dev(label1, "for", "row");
    			add_location(label1, file$m, 510, 24, 22875);
    			attr_dev(input0, "id", "row");
    			attr_dev(input0, "type", "number");
    			attr_dev(input0, "class", "form-control-sm");
    			input0.value = input0_value_value = /*$BlockEditorComponentStore*/ ctx[2].component.properties.row;
    			add_location(input0, file$m, 511, 24, 22930);
    			attr_dev(label2, "for", "column");
    			add_location(label2, file$m, 518, 24, 23490);
    			attr_dev(input1, "id", "column");
    			attr_dev(input1, "type", "number");
    			attr_dev(input1, "class", "form-control-sm");
    			input1.value = input1_value_value = /*$BlockEditorComponentStore*/ ctx[2].component.properties.col;
    			add_location(input1, file$m, 519, 24, 23550);
    			attr_dev(div0, "class", "form-group svelte-1qrx6yd");
    			add_location(div0, file$m, 509, 20, 22826);
    			attr_dev(div1, "id", "grid-options");
    			attr_dev(div1, "class", "svelte-1qrx6yd");
    			add_location(div1, file$m, 508, 16, 22782);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, label1);
    			append_dev(div0, t3);
    			append_dev(div0, input0);
    			append_dev(div0, t4);
    			append_dev(div0, label2);
    			append_dev(div0, t6);
    			append_dev(div0, input1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "blur", /*blur_handler*/ ctx[15], false, false, false),
    					listen_dev(input1, "blur", /*blur_handler_1*/ ctx[16], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$BlockEditorComponentStore*/ 4 && input0_value_value !== (input0_value_value = /*$BlockEditorComponentStore*/ ctx[2].component.properties.row)) {
    				prop_dev(input0, "value", input0_value_value);
    			}

    			if (dirty & /*$BlockEditorComponentStore*/ 4 && input1_value_value !== (input1_value_value = /*$BlockEditorComponentStore*/ ctx[2].component.properties.col)) {
    				prop_dev(input1, "value", input1_value_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$4.name,
    		type: "if",
    		source: "(507:12) {#if $BlockEditorComponentStore.layout}",
    		ctx
    	});

    	return block;
    }

    // (531:12) {#if $BlockEditorComponentStore.component}
    function create_if_block$c(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$8, create_else_block$3];
    	const if_blocks = [];

    	function select_block_type_3(ctx, dirty) {
    		if (globalContentContainerFactory.registeredConstructors[/*$BlockEditorComponentStore*/ ctx[2].component.type].editorConstructor) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_3(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_3(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$c.name,
    		type: "if",
    		source: "(531:12) {#if $BlockEditorComponentStore.component}",
    		ctx
    	});

    	return block;
    }

    // (535:16) {:else}
    function create_else_block$3(ctx) {
    	let contentdefaulteditor;
    	let current;

    	contentdefaulteditor = new ContentDefaultEditor({
    			props: {
    				component: /*$BlockEditorComponentStore*/ ctx[2].component
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(contentdefaulteditor.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(contentdefaulteditor, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const contentdefaulteditor_changes = {};
    			if (dirty & /*$BlockEditorComponentStore*/ 4) contentdefaulteditor_changes.component = /*$BlockEditorComponentStore*/ ctx[2].component;
    			contentdefaulteditor.$set(contentdefaulteditor_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(contentdefaulteditor.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(contentdefaulteditor.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(contentdefaulteditor, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(535:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (532:16) {#if globalContentContainerFactory.registeredConstructors[$BlockEditorComponentStore.component.type].editorConstructor}
    function create_if_block_1$8(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = globalContentContainerFactory.registeredConstructors[/*$BlockEditorComponentStore*/ ctx[2].component.type].editorConstructor;

    	function switch_props(ctx) {
    		return {
    			props: {
    				properties: /*$BlockEditorComponentStore*/ ctx[2].component.properties
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty & /*$BlockEditorComponentStore*/ 4) switch_instance_changes.properties = /*$BlockEditorComponentStore*/ ctx[2].component.properties;

    			if (switch_value !== (switch_value = globalContentContainerFactory.registeredConstructors[/*$BlockEditorComponentStore*/ ctx[2].component.type].editorConstructor)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$8.name,
    		type: "if",
    		source: "(532:16) {#if globalContentContainerFactory.registeredConstructors[$BlockEditorComponentStore.component.type].editorConstructor}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$m(ctx) {
    	let main;
    	let div0;
    	let t0;
    	let div1;
    	let t1;
    	let div4;
    	let h40;
    	let t3;
    	let div2;
    	let i0;
    	let t4;
    	let div3;
    	let t5;
    	let div4_class_value;
    	let t6;
    	let div10;
    	let h41;
    	let t8;
    	let div5;
    	let i1;
    	let t9;
    	let div7;
    	let div6;
    	let label0;
    	let t11;
    	let select;
    	let option0;
    	let option1;
    	let option2;
    	let select_value_value;
    	let t15;
    	let div8;
    	let label1;
    	let t17;
    	let highlightededitor0;
    	let t18;
    	let div9;
    	let label2;
    	let t20;
    	let highlightededitor1;
    	let div10_class_value;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = globalContentContainerFactory.getConstructors();
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
    	}

    	let if_block0 = /*$EditableDocumentStore*/ ctx[1].document && create_if_block_3$3(ctx);
    	let if_block1 = /*$BlockEditorComponentStore*/ ctx[2].layout && create_if_block_2$4(ctx);
    	let if_block2 = /*$BlockEditorComponentStore*/ ctx[2].component && create_if_block$c(ctx);

    	highlightededitor0 = new HighlightedEditor({
    			props: {
    				id: "globalStyle",
    				content: /*$EditableDocumentStore*/ ctx[1].document.content.globalStyle
    				? /*$EditableDocumentStore*/ ctx[1].document.content.globalStyle
    				: "",
    				onChange: /*func*/ ctx[19]
    			},
    			$$inline: true
    		});

    	highlightededitor1 = new HighlightedEditor({
    			props: {
    				id: "style",
    				content: /*$EditableDocumentStore*/ ctx[1].document.style
    				? /*$EditableDocumentStore*/ ctx[1].document.style
    				: "",
    				onChange: /*func_1*/ ctx[20]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			main = element("main");
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t0 = space();
    			div1 = element("div");
    			if (if_block0) if_block0.c();
    			t1 = space();
    			div4 = element("div");
    			h40 = element("h4");
    			h40.textContent = "Propriétés";
    			t3 = space();
    			div2 = element("div");
    			i0 = element("i");
    			t4 = space();
    			div3 = element("div");
    			if (if_block1) if_block1.c();
    			t5 = space();
    			if (if_block2) if_block2.c();
    			t6 = space();
    			div10 = element("div");
    			h41 = element("h4");
    			h41.textContent = "Propriétés du Document";
    			t8 = space();
    			div5 = element("div");
    			i1 = element("i");
    			t9 = space();
    			div7 = element("div");
    			div6 = element("div");
    			label0 = element("label");
    			label0.textContent = "Visibilité";
    			t11 = space();
    			select = element("select");
    			option0 = element("option");
    			option0.textContent = "Privé";
    			option1 = element("option");
    			option1.textContent = "Protégé";
    			option2 = element("option");
    			option2.textContent = "Public";
    			t15 = space();
    			div8 = element("div");
    			label1 = element("label");
    			label1.textContent = "Global Style :";
    			t17 = space();
    			create_component(highlightededitor0.$$.fragment);
    			t18 = space();
    			div9 = element("div");
    			label2 = element("label");
    			label2.textContent = "Style :";
    			t20 = space();
    			create_component(highlightededitor1.$$.fragment);
    			attr_dev(div0, "id", "toolbox");
    			attr_dev(div0, "class", "svelte-1qrx6yd");
    			add_location(div0, file$m, 252, 4, 6702);
    			attr_dev(div1, "id", "document");
    			attr_dev(div1, "class", "container-content svelte-1qrx6yd");
    			add_location(div1, file$m, 267, 4, 7348);
    			attr_dev(h40, "class", "svelte-1qrx6yd");
    			add_location(h40, file$m, 503, 8, 22476);
    			attr_dev(i0, "class", "fal fa-window-close");
    			add_location(i0, file$m, 504, 69, 22567);
    			attr_dev(div2, "class", "close svelte-1qrx6yd");
    			add_location(div2, file$m, 504, 8, 22506);
    			attr_dev(div3, "class", "editor-content svelte-1qrx6yd");
    			add_location(div3, file$m, 505, 8, 22617);

    			attr_dev(div4, "class", div4_class_value = "editor-panel " + (/*$BlockEditorComponentStore*/ ctx[2].component
    			? ""
    			: "hidden") + " svelte-1qrx6yd");

    			add_location(div4, file$m, 502, 4, 22390);
    			attr_dev(h41, "class", "svelte-1qrx6yd");
    			add_location(h41, file$m, 542, 8, 24945);
    			attr_dev(i1, "class", "fal fa-window-close");
    			add_location(i1, file$m, 545, 7, 25074);
    			attr_dev(div5, "class", "close svelte-1qrx6yd");
    			add_location(div5, file$m, 543, 8, 24986);
    			attr_dev(label0, "for", "documentVisibility");
    			add_location(label0, file$m, 548, 16, 25206);
    			option0.__value = "private";
    			option0.value = option0.__value;
    			add_location(option0, file$m, 557, 20, 25926);
    			option1.__value = "protected";
    			option1.value = option1.__value;
    			add_location(option1, file$m, 558, 20, 25986);
    			option2.__value = "public";
    			option2.value = option2.__value;
    			add_location(option2, file$m, 559, 20, 26050);
    			attr_dev(select, "class", "form-select");
    			attr_dev(select, "id", "documentVisibility");
    			attr_dev(select, "name", "documentVisibility");
    			select.required = true;
    			attr_dev(select, "title", "Un document privé n'est accessible et visible que par ses lecteurs et les administrateurs");
    			add_location(select, file$m, 549, 16, 25273);
    			attr_dev(div6, "class", "visibility svelte-1qrx6yd");
    			add_location(div6, file$m, 547, 12, 25165);
    			attr_dev(div7, "class", "editor-content svelte-1qrx6yd");
    			add_location(div7, file$m, 546, 8, 25124);
    			attr_dev(label1, "for", "globalStyle");
    			add_location(label1, file$m, 564, 12, 26196);
    			attr_dev(div8, "class", "global-style svelte-1qrx6yd");
    			add_location(div8, file$m, 563, 8, 26157);
    			attr_dev(label2, "for", "style");
    			add_location(label2, file$m, 575, 12, 26741);
    			attr_dev(div9, "class", "style svelte-1qrx6yd");
    			add_location(div9, file$m, 574, 8, 26709);
    			attr_dev(div10, "class", div10_class_value = "editor-panel " + (/*editDocumentGlobalProperties*/ ctx[0] ? "" : "hidden") + " svelte-1qrx6yd");
    			add_location(div10, file$m, 541, 4, 24867);
    			attr_dev(main, "class", "editor-main svelte-1qrx6yd");
    			add_location(main, file$m, 251, 0, 6671);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div0, null);
    			}

    			append_dev(main, t0);
    			append_dev(main, div1);
    			if (if_block0) if_block0.m(div1, null);
    			append_dev(main, t1);
    			append_dev(main, div4);
    			append_dev(div4, h40);
    			append_dev(div4, t3);
    			append_dev(div4, div2);
    			append_dev(div2, i0);
    			append_dev(div4, t4);
    			append_dev(div4, div3);
    			if (if_block1) if_block1.m(div3, null);
    			append_dev(div3, t5);
    			if (if_block2) if_block2.m(div3, null);
    			append_dev(main, t6);
    			append_dev(main, div10);
    			append_dev(div10, h41);
    			append_dev(div10, t8);
    			append_dev(div10, div5);
    			append_dev(div5, i1);
    			append_dev(div10, t9);
    			append_dev(div10, div7);
    			append_dev(div7, div6);
    			append_dev(div6, label0);
    			append_dev(div6, t11);
    			append_dev(div6, select);
    			append_dev(select, option0);
    			append_dev(select, option1);
    			append_dev(select, option2);
    			select_option(select, /*$EditableDocumentStore*/ ctx[1].document.visibility);
    			append_dev(div10, t15);
    			append_dev(div10, div8);
    			append_dev(div8, label1);
    			append_dev(div8, t17);
    			mount_component(highlightededitor0, div8, null);
    			append_dev(div10, t18);
    			append_dev(div10, div9);
    			append_dev(div9, label2);
    			append_dev(div9, t20);
    			mount_component(highlightededitor1, div9, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div2, "click", /*resetBlockEditorComponentStore*/ ctx[6], false, false, false),
    					listen_dev(div5, "click", /*click_handler_7*/ ctx[17], false, false, false),
    					listen_dev(select, "blur", /*blur_handler_2*/ ctx[18], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*globalContentContainerFactory*/ 0) {
    				each_value = globalContentContainerFactory.getConstructors();
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$9(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$9(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div0, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (/*$EditableDocumentStore*/ ctx[1].document) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*$EditableDocumentStore*/ 2) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_3$3(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div1, null);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*$BlockEditorComponentStore*/ ctx[2].layout) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_2$4(ctx);
    					if_block1.c();
    					if_block1.m(div3, t5);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (/*$BlockEditorComponentStore*/ ctx[2].component) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*$BlockEditorComponentStore*/ 4) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block$c(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div3, null);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*$BlockEditorComponentStore*/ 4 && div4_class_value !== (div4_class_value = "editor-panel " + (/*$BlockEditorComponentStore*/ ctx[2].component
    			? ""
    			: "hidden") + " svelte-1qrx6yd")) {
    				attr_dev(div4, "class", div4_class_value);
    			}

    			if (!current || dirty & /*$EditableDocumentStore*/ 2 && select_value_value !== (select_value_value = /*$EditableDocumentStore*/ ctx[1].document.visibility)) {
    				select_option(select, /*$EditableDocumentStore*/ ctx[1].document.visibility);
    			}

    			const highlightededitor0_changes = {};

    			if (dirty & /*$EditableDocumentStore*/ 2) highlightededitor0_changes.content = /*$EditableDocumentStore*/ ctx[1].document.content.globalStyle
    			? /*$EditableDocumentStore*/ ctx[1].document.content.globalStyle
    			: "";

    			if (dirty & /*$EditableDocumentStore*/ 2) highlightededitor0_changes.onChange = /*func*/ ctx[19];
    			highlightededitor0.$set(highlightededitor0_changes);
    			const highlightededitor1_changes = {};

    			if (dirty & /*$EditableDocumentStore*/ 2) highlightededitor1_changes.content = /*$EditableDocumentStore*/ ctx[1].document.style
    			? /*$EditableDocumentStore*/ ctx[1].document.style
    			: "";

    			if (dirty & /*$EditableDocumentStore*/ 2) highlightededitor1_changes.onChange = /*func_1*/ ctx[20];
    			highlightededitor1.$set(highlightededitor1_changes);

    			if (!current || dirty & /*editDocumentGlobalProperties*/ 1 && div10_class_value !== (div10_class_value = "editor-panel " + (/*editDocumentGlobalProperties*/ ctx[0] ? "" : "hidden") + " svelte-1qrx6yd")) {
    				attr_dev(div10, "class", div10_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block2);
    			transition_in(highlightededitor0.$$.fragment, local);
    			transition_in(highlightededitor1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block2);
    			transition_out(highlightededitor0.$$.fragment, local);
    			transition_out(highlightededitor1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_each(each_blocks, detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			destroy_component(highlightededitor0);
    			destroy_component(highlightededitor1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let $EditableDocumentStore;
    	let $BlockEditorComponentStore;
    	validate_store(EditableDocumentStore, "EditableDocumentStore");
    	component_subscribe($$self, EditableDocumentStore, $$value => $$invalidate(1, $EditableDocumentStore = $$value));
    	validate_store(BlockEditorComponentStore, "BlockEditorComponentStore");
    	component_subscribe($$self, BlockEditorComponentStore, $$value => $$invalidate(2, $BlockEditorComponentStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ContentDocumentEditor", slots, []);
    	let editDocumentGlobalProperties;
    	let refresh = new Date();

    	async function saveDocument() {
    		const services = await dist$1.getBackendClient();
    		await services.documentService.updateDocument($EditableDocumentStore.document);
    	}

    	function getZoneLayout(zone) {
    		const layout = $EditableDocumentStore.document.content.layout && $EditableDocumentStore.document.content.layout[zone] && $EditableDocumentStore.document.content.layout[zone].type
    		? $EditableDocumentStore.document.content.layout[zone].type
    		: "";

    		console.log(`layout for zone ${zone} : ${layout}`);
    		return layout;
    	}

    	function reorderRow() {
    		const row = $EditableDocumentStore.document.content[$BlockEditorComponentStore.zone].filter(component => component.properties.row === $BlockEditorComponentStore.component.properties.row);
    		row.splice(row.indexOf($BlockEditorComponentStore.component), 1);
    		row.splice($BlockEditorComponentStore.component.properties.col, 0, $BlockEditorComponentStore.component);

    		for (let colIndex = 0; colIndex < row.length; colIndex++) {
    			row[colIndex].properties.col = colIndex;
    		}
    	}

    	onMount(() => {
    		document.querySelector(".app-viewport > div.container-content > main").classList.remove("document-section", "document-main");
    	});

    	afterUpdate(() => {
    		document.querySelector(".app-viewport > div.container-content > main").classList.remove("document-section", "document-main");
    	});

    	function resetBlockEditorComponentStore() {
    		set_store_value(BlockEditorComponentStore, $BlockEditorComponentStore.component = undefined, $BlockEditorComponentStore);
    		set_store_value(BlockEditorComponentStore, $BlockEditorComponentStore.zone = undefined, $BlockEditorComponentStore);
    		set_store_value(BlockEditorComponentStore, $BlockEditorComponentStore.layout = undefined, $BlockEditorComponentStore);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$b.warn(`<ContentDocumentEditor> was created with unknown prop '${key}'`);
    	});

    	const dragstart_handler = (constructorMetadata, event) => {
    		event.dataTransfer.moveEffect = "copy";
    		event.dataTransfer.setData("constructorType", constructorMetadata.type);
    	};

    	const click_handler = () => {
    		set_store_value(BlockEditorComponentStore, $BlockEditorComponentStore.component = undefined, $BlockEditorComponentStore);
    		set_store_value(BlockEditorComponentStore, $BlockEditorComponentStore.zone = undefined, $BlockEditorComponentStore);
    		set_store_value(BlockEditorComponentStore, $BlockEditorComponentStore.layout = undefined, $BlockEditorComponentStore);
    		$$invalidate(0, editDocumentGlobalProperties = true);
    	};

    	const click_handler_1 = () => {
    		document.querySelector("#headers > h5 > .section-layout > button.active-layout").classList.remove("active-layout");

    		if (!$EditableDocumentStore.document.content.layout) {
    			set_store_value(EditableDocumentStore, $EditableDocumentStore.document.content.layout = {}, $EditableDocumentStore);
    		}

    		if (!$EditableDocumentStore.document.content.layout.headers) {
    			set_store_value(EditableDocumentStore, $EditableDocumentStore.document.content.layout.headers = { type: "stack" }, $EditableDocumentStore);
    		} else {
    			set_store_value(EditableDocumentStore, $EditableDocumentStore.document.content.layout.headers.type = "stack", $EditableDocumentStore);
    		}

    		document.getElementById("change-layout-headers-stack").classList.add("active-layout");
    		Helpers.updateEditableDocumentStore();
    	};

    	const click_handler_2 = () => {
    		document.querySelector("#headers > h5 > .section-layout > button.active-layout").classList.remove("active-layout");

    		if (!$EditableDocumentStore.document.content.layout) {
    			set_store_value(EditableDocumentStore, $EditableDocumentStore.document.content.layout = {}, $EditableDocumentStore);
    		}

    		if (!$EditableDocumentStore.document.content.layout.headers) {
    			set_store_value(EditableDocumentStore, $EditableDocumentStore.document.content.layout.headers = { type: "grid" }, $EditableDocumentStore);
    		} else {
    			set_store_value(EditableDocumentStore, $EditableDocumentStore.document.content.layout.headers.type = "grid", $EditableDocumentStore);
    		}

    		document.getElementById("change-layout-headers-grid").classList.add("active-layout");
    		Helpers.updateEditableDocumentStore();
    	};

    	const click_handler_3 = () => {
    		document.querySelector("#bodies > h5 > .section-layout > button.active-layout").classList.remove("active-layout");

    		if (!$EditableDocumentStore.document.content.layout) {
    			set_store_value(EditableDocumentStore, $EditableDocumentStore.document.content.layout = {}, $EditableDocumentStore);
    		}

    		if (!$EditableDocumentStore.document.content.layout.bodies) {
    			set_store_value(EditableDocumentStore, $EditableDocumentStore.document.content.layout.bodies = { type: "stack" }, $EditableDocumentStore);
    		} else {
    			set_store_value(EditableDocumentStore, $EditableDocumentStore.document.content.layout.bodies.type = "stack", $EditableDocumentStore);
    		}

    		document.getElementById("change-layout-bodies-stack").classList.add("active-layout");
    		Helpers.updateEditableDocumentStore();
    	};

    	const click_handler_4 = () => {
    		document.querySelector("#bodies > h5 > .section-layout > button.active-layout").classList.remove("active-layout");

    		if (!$EditableDocumentStore.document.content.layout) {
    			set_store_value(EditableDocumentStore, $EditableDocumentStore.document.content.layout = {}, $EditableDocumentStore);
    		}

    		if (!$EditableDocumentStore.document.content.layout.bodies) {
    			set_store_value(EditableDocumentStore, $EditableDocumentStore.document.content.layout.bodies = { type: "grid" }, $EditableDocumentStore);
    		} else {
    			set_store_value(EditableDocumentStore, $EditableDocumentStore.document.content.layout.bodies.type = "grid", $EditableDocumentStore);
    		}

    		document.getElementById("change-layout-bodies-grid").classList.add("active-layout");
    		Helpers.updateEditableDocumentStore();
    	};

    	const click_handler_5 = () => {
    		document.querySelector("#footers > h5 > .section-layout > button.active-layout").classList.remove("active-layout");

    		if (!$EditableDocumentStore.document.content.layout) {
    			set_store_value(EditableDocumentStore, $EditableDocumentStore.document.content.layout = {}, $EditableDocumentStore);
    		}

    		if (!$EditableDocumentStore.document.content.layout.footers) {
    			set_store_value(EditableDocumentStore, $EditableDocumentStore.document.content.layout.footers = { type: "stack" }, $EditableDocumentStore);
    		} else {
    			set_store_value(EditableDocumentStore, $EditableDocumentStore.document.content.layout.footers.type = "stack", $EditableDocumentStore);
    		}

    		document.getElementById("change-layout-footers-stack").classList.add("active-layout");
    		Helpers.updateEditableDocumentStore();
    	};

    	const click_handler_6 = () => {
    		document.querySelector("#footers > h5 > .section-layout > button.active-layout").classList.remove("active-layout");

    		if (!$EditableDocumentStore.document.content.layout) {
    			set_store_value(EditableDocumentStore, $EditableDocumentStore.document.content.layout = {}, $EditableDocumentStore);
    		}

    		if (!$EditableDocumentStore.document.content.layout.footers) {
    			set_store_value(EditableDocumentStore, $EditableDocumentStore.document.content.layout.footers = { type: "grid" }, $EditableDocumentStore);
    		} else {
    			set_store_value(EditableDocumentStore, $EditableDocumentStore.document.content.layout.footers.type = "grid", $EditableDocumentStore);
    		}

    		document.getElementById("change-layout-footers-grid").classList.add("active-layout");
    		Helpers.updateEditableDocumentStore();
    	};

    	const blur_handler = event => {
    		const input = event.currentTarget;
    		set_store_value(BlockEditorComponentStore, $BlockEditorComponentStore.component.properties.row = input.value ? parseInt(input.value) : 0, $BlockEditorComponentStore);
    		reorderRow();
    		BlockEditorComponentStore.update(becs => becs);
    		EditableDocumentStore.update(ecs => ecs);
    	};

    	const blur_handler_1 = event => {
    		const input = event.currentTarget;
    		set_store_value(BlockEditorComponentStore, $BlockEditorComponentStore.component.properties.col = input.value ? parseInt(input.value) : 0, $BlockEditorComponentStore);
    		reorderRow();
    		BlockEditorComponentStore.update(becs => becs);
    		EditableDocumentStore.update(ecs => ecs);
    	};

    	const click_handler_7 = () => {
    		$$invalidate(0, editDocumentGlobalProperties = false);
    	};

    	const blur_handler_2 = () => {
    		const visibility = document.getElementById("documentVisibility");
    		visibility.title = Helpers.visibilityTooltips[visibility.value];
    		set_store_value(EditableDocumentStore, $EditableDocumentStore.document.visibility = visibility.value, $EditableDocumentStore);
    	};

    	const func = newStyle => {
    		set_store_value(EditableDocumentStore, $EditableDocumentStore.document.content.globalStyle = newStyle, $EditableDocumentStore);
    		Helpers.updateEditableDocumentStore();
    	};

    	const func_1 = newStyle => {
    		set_store_value(EditableDocumentStore, $EditableDocumentStore.document.style = newStyle, $EditableDocumentStore);
    		Helpers.updateEditableDocumentStore();
    	};

    	$$self.$capture_state = () => ({
    		getBackendClient: dist$1.getBackendClient,
    		EditableDocumentStore,
    		globalContentContainerFactory,
    		ContentDefaultEditor,
    		Helpers,
    		BlockEditorComponentStore,
    		ContentDocumentEditorZoneGridLayout,
    		ContentDocumentEditorZoneStackLayout,
    		HighlightedEditor,
    		onMount,
    		afterUpdate,
    		editDocumentGlobalProperties,
    		refresh,
    		saveDocument,
    		getZoneLayout,
    		reorderRow,
    		resetBlockEditorComponentStore,
    		$EditableDocumentStore,
    		$BlockEditorComponentStore
    	});

    	$$self.$inject_state = $$props => {
    		if ("editDocumentGlobalProperties" in $$props) $$invalidate(0, editDocumentGlobalProperties = $$props.editDocumentGlobalProperties);
    		if ("refresh" in $$props) refresh = $$props.refresh;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		editDocumentGlobalProperties,
    		$EditableDocumentStore,
    		$BlockEditorComponentStore,
    		saveDocument,
    		getZoneLayout,
    		reorderRow,
    		resetBlockEditorComponentStore,
    		dragstart_handler,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		click_handler_4,
    		click_handler_5,
    		click_handler_6,
    		blur_handler,
    		blur_handler_1,
    		click_handler_7,
    		blur_handler_2,
    		func,
    		func_1
    	];
    }

    class ContentDocumentEditor extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$m, create_fragment$m, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ContentDocumentEditor",
    			options,
    			id: create_fragment$m.name
    		});
    	}
    }

    /* src/components/ContentTitle.svelte generated by Svelte v3.38.2 */
    const file$l = "src/components/ContentTitle.svelte";

    // (21:4) {:else}
    function create_else_block$2(ctx) {
    	let h1;

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			add_location(h1, file$l, 21, 8, 630);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    		},
    		p: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(21:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (16:4) {#if properties}
    function create_if_block$b(ctx) {
    	let t;
    	let h1;

    	let raw_value = (/*properties*/ ctx[0].title
    	? /*properties*/ ctx[0].title
    	: "") + "";

    	let h1_style_value;
    	let if_block = typeof /*properties*/ ctx[0].globalStyle === "string" && create_if_block_1$7(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();
    			h1 = element("h1");

    			attr_dev(h1, "style", h1_style_value = /*properties*/ ctx[0].style
    			? /*properties*/ ctx[0].style
    			: "");

    			add_location(h1, file$l, 19, 8, 509);
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, h1, anchor);
    			h1.innerHTML = raw_value;
    		},
    		p: function update(ctx, dirty) {
    			if (typeof /*properties*/ ctx[0].globalStyle === "string") {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$7(ctx);
    					if_block.c();
    					if_block.m(t.parentNode, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*properties*/ 1 && raw_value !== (raw_value = (/*properties*/ ctx[0].title
    			? /*properties*/ ctx[0].title
    			: "") + "")) h1.innerHTML = raw_value;
    			if (dirty & /*properties*/ 1 && h1_style_value !== (h1_style_value = /*properties*/ ctx[0].style
    			? /*properties*/ ctx[0].style
    			: "")) {
    				attr_dev(h1, "style", h1_style_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(h1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$b.name,
    		type: "if",
    		source: "(16:4) {#if properties}",
    		ctx
    	});

    	return block;
    }

    // (17:8) {#if typeof properties.globalStyle === "string"}
    function create_if_block_1$7(ctx) {
    	let html_tag;
    	let raw_value = Helpers.styleOpeningLabel + /*properties*/ ctx[0].globalStyle + Helpers.styleClosingLabel + "";
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_anchor = empty$2();
    			html_tag = new HtmlTag(html_anchor);
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(raw_value, target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*properties*/ 1 && raw_value !== (raw_value = Helpers.styleOpeningLabel + /*properties*/ ctx[0].globalStyle + Helpers.styleClosingLabel + "")) html_tag.p(raw_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$7.name,
    		type: "if",
    		source: "(17:8) {#if typeof properties.globalStyle === \\\"string\\\"}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$l(ctx) {
    	let div;
    	let div_class_value;

    	function select_block_type(ctx, dirty) {
    		if (/*properties*/ ctx[0]) return create_if_block$b;
    		return create_else_block$2;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();

    			attr_dev(div, "class", div_class_value = "nodecms-title " + (/*properties*/ ctx[0].classes
    			? /*properties*/ ctx[0].classes
    			: "") + " svelte-4yl3ax");

    			add_location(div, file$l, 14, 0, 238);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_block.m(div, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div, null);
    				}
    			}

    			if (dirty & /*properties*/ 1 && div_class_value !== (div_class_value = "nodecms-title " + (/*properties*/ ctx[0].classes
    			? /*properties*/ ctx[0].classes
    			: "") + " svelte-4yl3ax")) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ContentTitle", slots, []);
    	let { properties } = $$props;
    	const writable_props = ["properties"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ContentTitle> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("properties" in $$props) $$invalidate(0, properties = $$props.properties);
    	};

    	$$self.$capture_state = () => ({ Helpers, properties });

    	$$self.$inject_state = $$props => {
    		if ("properties" in $$props) $$invalidate(0, properties = $$props.properties);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [properties];
    }

    class ContentTitle extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$l, create_fragment$l, safe_not_equal, { properties: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ContentTitle",
    			options,
    			id: create_fragment$l.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*properties*/ ctx[0] === undefined && !("properties" in props)) {
    			console.warn("<ContentTitle> was created without expected prop 'properties'");
    		}
    	}

    	get properties() {
    		throw new Error("<ContentTitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set properties(value) {
    		throw new Error("<ContentTitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    class AllMedia {
        constructor() {
            this.media = [];
        }
    }
    const AllMediaStores = writable(new AllMedia());

    /* src/components/Media/MediaSearchBar.svelte generated by Svelte v3.38.2 */

    const { console: console_1$a } = globals;
    const file$k = "src/components/Media/MediaSearchBar.svelte";

    function create_fragment$k(ctx) {
    	let div;
    	let input;
    	let t;
    	let button;
    	let i;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			input = element("input");
    			t = space();
    			button = element("button");
    			i = element("i");
    			attr_dev(input, "class", "media-search-bar svelte-1jq3grx");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "id", "search-media-keyword");
    			attr_dev(input, "placeholder", "Taper votre recherche");
    			add_location(input, file$k, 112, 4, 3456);
    			attr_dev(i, "class", "fas fa-search");
    			add_location(i, file$k, 118, 57, 3688);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "class", "do-search btn btn-dark svelte-1jq3grx");
    			add_location(button, file$k, 118, 4, 3635);
    			attr_dev(div, "class", "media-search-bar-container svelte-1jq3grx");
    			add_location(div, file$k, 111, 0, 3411);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, input);
    			append_dev(div, t);
    			append_dev(div, button);
    			append_dev(button, i);

    			if (!mounted) {
    				dispose = listen_dev(input, "keyup", /*onKeyUp*/ ctx[0], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$2,
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("MediaSearchBar", slots, []);
    	const dispatch = createEventDispatcher();
    	const searchMedia = _.debounce(debounceSearchMedia, 1000);

    	async function debounceSearchMedia() {
    		const services = await getBackendClient();
    		const results = [];
    		const searchBar = document.getElementById("search-media-keyword");

    		try {
    			if (searchBar.value) {
    				const searchPromises = [];

    				for (const keyword of searchBar.value.split(" ")) {
    					searchPromises.push(services.mediaService.getMediaMetadata(keyword));
    					searchPromises.push(services.mediaService.findMedia({ label: keyword }));
    				}

    				searchPromises.push(services.mediaService.findMedia({ tags: searchBar.value.split(" ") }));
    				const searchResults = await Promise.all(searchPromises);

    				const pushFoundMedia = media => {
    					if (media && results.findIndex(m => m.id === media.id) < 0) {
    						results.push(media);
    					}
    				};

    				for (const result of searchResults) {
    					if (Array.isArray(result)) {
    						for (const m of result) {
    							pushFoundMedia(m);
    						}
    					} else {
    						pushFoundMedia(result);
    					}
    				}

    				if (results.length > 0) {
    					AllMediaStores.update(ams => {
    						ams.media = results;
    						return ams;
    					});
    				}
    			} else {
    				AllMediaStores.update(ams => {
    					ams.media = [];
    					return ams;
    				});
    			}
    		} catch(error) {
    			globalFEService.getService("displayError").displayError("Erreur pendant la recherche", error.message);
    		} finally {
    			dispatch("search-ended");
    		}
    	}

    	onMount(() => {
    		console.log("mounting search bar");
    	});

    	onDestroy(() => {
    		AllMediaStores.update(ams => {
    			ams.media = [];
    			return ams;
    		});
    	});

    	function onKeyUp() {
    		dispatch("search-started");

    		AllMediaStores.update(ams => {
    			ams.media = [];
    			return ams;
    		});

    		searchMedia();
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$a.warn(`<MediaSearchBar> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		AllMediaStores,
    		createEventDispatcher,
    		onMount,
    		onDestroy,
    		_,
    		dispatch,
    		searchMedia,
    		debounceSearchMedia,
    		onKeyUp
    	});

    	return [onKeyUp];
    }

    class MediaSearchBar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$k, create_fragment$k, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MediaSearchBar",
    			options,
    			id: create_fragment$k.name
    		});
    	}
    }

    class ShowUploadModal {
        constructor() {
            this.shown = false;
            this.newId = v4();
        }
    }
    const ShowUploadModalStore = writable(new ShowUploadModal());

    /* src/components/Media/UploadMediaModal.svelte generated by Svelte v3.38.2 */
    const file$j = "src/components/Media/UploadMediaModal.svelte";

    // (133:4) {#if $ShowUploadModalStore.shown}
    function create_if_block$a(ctx) {
    	let div16;
    	let style;
    	let t1;
    	let div15;
    	let div14;
    	let div0;
    	let h5;
    	let t3;
    	let button0;
    	let span0;
    	let t5;
    	let div10;
    	let div9;
    	let div2;
    	let label0;
    	let t7;
    	let input0;
    	let input0_value_value;
    	let t8;
    	let div1;
    	let t10;
    	let div4;
    	let label1;
    	let t12;
    	let input1;
    	let t13;
    	let div3;
    	let t15;
    	let div5;
    	let label2;
    	let t17;
    	let select;
    	let option0;
    	let option1;
    	let t20;
    	let div7;
    	let label3;
    	let t22;
    	let input2;
    	let t23;
    	let div6;
    	let t25;
    	let div8;
    	let label4;
    	let t27;
    	let input3;
    	let t28;
    	let div13;
    	let div12;
    	let div11;
    	let t29;
    	let button1;
    	let span1;
    	let span2;
    	let div16_transition;
    	let current;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div16 = element("div");
    			style = element("style");
    			style.textContent = "label {\n                text-align: start;\n            }";
    			t1 = space();
    			div15 = element("div");
    			div14 = element("div");
    			div0 = element("div");
    			h5 = element("h5");
    			h5.textContent = "Upload un Media";
    			t3 = space();
    			button0 = element("button");
    			span0 = element("span");
    			span0.textContent = "×";
    			t5 = space();
    			div10 = element("div");
    			div9 = element("div");
    			div2 = element("div");
    			label0 = element("label");
    			label0.textContent = "Clé";
    			t7 = space();
    			input0 = element("input");
    			t8 = space();
    			div1 = element("div");
    			div1.textContent = "La clé ne peut pas être vide et doit être unique.";
    			t10 = space();
    			div4 = element("div");
    			label1 = element("label");
    			label1.textContent = "Label";
    			t12 = space();
    			input1 = element("input");
    			t13 = space();
    			div3 = element("div");
    			div3.textContent = "Le label ne peut pas être vide.";
    			t15 = space();
    			div5 = element("div");
    			label2 = element("label");
    			label2.textContent = "Visibilité";
    			t17 = space();
    			select = element("select");
    			option0 = element("option");
    			option0.textContent = "Protégé";
    			option1 = element("option");
    			option1.textContent = "Public";
    			t20 = space();
    			div7 = element("div");
    			label3 = element("label");
    			label3.textContent = "Fichier";
    			t22 = space();
    			input2 = element("input");
    			t23 = space();
    			div6 = element("div");
    			div6.textContent = "Un fichier a uploader doit être sélectionné.";
    			t25 = space();
    			div8 = element("div");
    			label4 = element("label");
    			label4.textContent = "Tags";
    			t27 = space();
    			input3 = element("input");
    			t28 = space();
    			div13 = element("div");
    			div12 = element("div");
    			div11 = element("div");
    			t29 = space();
    			button1 = element("button");
    			span1 = element("span");
    			span2 = element("span");
    			span2.textContent = "Ajouter le Média";
    			add_location(style, file$j, 137, 8, 4590);
    			attr_dev(h5, "id", "upload-media-modal-title");
    			attr_dev(h5, "class", "modal-title");
    			add_location(h5, file$j, 146, 20, 4845);
    			attr_dev(span0, "aria-hidden", "true");
    			add_location(span0, file$j, 151, 24, 5200);
    			attr_dev(button0, "id", "upload-media-close");
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "close");
    			attr_dev(button0, "data-dismiss", "modal");
    			attr_dev(button0, "aria-label", "Close");
    			add_location(button0, file$j, 147, 20, 4940);
    			attr_dev(div0, "class", "modal-header");
    			add_location(div0, file$j, 145, 16, 4798);
    			attr_dev(label0, "for", "mediaKey");
    			add_location(label0, file$j, 157, 28, 5463);
    			attr_dev(input0, "class", "form-control");
    			attr_dev(input0, "id", "mediaKey");
    			attr_dev(input0, "name", "mediaKey");
    			attr_dev(input0, "type", "text");
    			input0.required = true;
    			input0.value = input0_value_value = /*$ShowUploadModalStore*/ ctx[0].newId;
    			add_location(input0, file$j, 158, 28, 5525);
    			attr_dev(div1, "class", "invalid-feedback");
    			add_location(div1, file$j, 162, 28, 5810);
    			attr_dev(div2, "class", "mb-3");
    			add_location(div2, file$j, 156, 24, 5416);
    			attr_dev(label1, "for", "mediaLabel");
    			add_location(label1, file$j, 167, 28, 6061);
    			attr_dev(input1, "class", "form-control");
    			attr_dev(input1, "id", "mediaLabel");
    			attr_dev(input1, "name", "mediaLabel");
    			attr_dev(input1, "type", "text");
    			input1.required = true;
    			add_location(input1, file$j, 168, 28, 6127);
    			attr_dev(div3, "class", "invalid-feedback");
    			add_location(div3, file$j, 172, 28, 6378);
    			attr_dev(div4, "class", "mb-3");
    			add_location(div4, file$j, 166, 24, 6014);
    			attr_dev(label2, "for", "mediaVisibility");
    			add_location(label2, file$j, 177, 28, 6610);
    			option0.__value = "protected";
    			option0.value = option0.__value;
    			add_location(option0, file$j, 181, 32, 6961);
    			option1.__value = "public";
    			option1.value = option1.__value;
    			add_location(option1, file$j, 182, 32, 7037);
    			attr_dev(select, "class", "form-select");
    			attr_dev(select, "id", "mediaVisibility");
    			attr_dev(select, "name", "mediaVisibility");
    			select.required = true;
    			attr_dev(select, "title", "Un media protégé n'est accessible et visible que par des utilisateurs identifiés");
    			add_location(select, file$j, 178, 28, 6686);
    			attr_dev(div5, "class", "mb-3");
    			add_location(div5, file$j, 176, 24, 6563);
    			attr_dev(label3, "for", "mediaFile");
    			add_location(label3, file$j, 186, 28, 7216);
    			attr_dev(input2, "type", "file");
    			attr_dev(input2, "accept", dist$1.MediaService.AuthorizedMimeTypes.join(","));
    			attr_dev(input2, "id", "mediaFile");
    			attr_dev(input2, "name", "mediaFile");
    			add_location(input2, file$j, 187, 28, 7283);
    			attr_dev(div6, "class", "invalid-feedback");
    			add_location(div6, file$j, 190, 28, 7518);
    			attr_dev(div7, "class", "mb-3");
    			add_location(div7, file$j, 185, 24, 7169);
    			attr_dev(label4, "for", "mediaTags");
    			add_location(label4, file$j, 195, 28, 7763);
    			attr_dev(input3, "type", "text");
    			attr_dev(input3, "class", "form-control");
    			attr_dev(input3, "id", "mediaTags");
    			attr_dev(input3, "name", "mediaTags");
    			add_location(input3, file$j, 196, 28, 7827);
    			attr_dev(div8, "class", "mb-3");
    			add_location(div8, file$j, 194, 24, 7716);
    			attr_dev(div9, "id", "upload-media-form");
    			attr_dev(div9, "class", "");
    			add_location(div9, file$j, 155, 20, 5354);
    			attr_dev(div10, "class", "modal-body");
    			add_location(div10, file$j, 154, 16, 5309);
    			attr_dev(div11, "id", "error-uploading-media-content");
    			add_location(div11, file$j, 204, 24, 8230);
    			attr_dev(div12, "id", "error-uploading-media");
    			attr_dev(div12, "class", "alert alert-danger fade");
    			add_location(div12, file$j, 203, 20, 8141);
    			attr_dev(span1, "id", "uploading-media-loading");
    			attr_dev(span1, "class", "spinner-border svelte-1tkumtz");
    			add_location(span1, file$j, 207, 24, 8457);
    			attr_dev(span2, "id", "do-upload-media-text");
    			add_location(span2, file$j, 207, 89, 8522);
    			attr_dev(button1, "id", "do-upload-media");
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn action btn-danger ");
    			button1.disabled = true;
    			add_location(button1, file$j, 206, 20, 8324);
    			attr_dev(div13, "class", "modal-footer modal-footer-upload-footer");
    			add_location(div13, file$j, 202, 16, 8067);
    			attr_dev(div14, "class", "modal-content");
    			add_location(div14, file$j, 144, 12, 4754);
    			attr_dev(div15, "class", "modal-dialog modal-dialog-centered");
    			add_location(div15, file$j, 143, 8, 4693);
    			attr_dev(div16, "id", "upload-media-modal");
    			attr_dev(div16, "class", "modal fade svelte-1tkumtz");
    			attr_dev(div16, "data-keyboard", "false");
    			toggle_class(div16, "show", /*$ShowUploadModalStore*/ ctx[0].shown);
    			add_location(div16, file$j, 133, 8, 4384);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div16, anchor);
    			append_dev(div16, style);
    			append_dev(div16, t1);
    			append_dev(div16, div15);
    			append_dev(div15, div14);
    			append_dev(div14, div0);
    			append_dev(div0, h5);
    			append_dev(div0, t3);
    			append_dev(div0, button0);
    			append_dev(button0, span0);
    			append_dev(div14, t5);
    			append_dev(div14, div10);
    			append_dev(div10, div9);
    			append_dev(div9, div2);
    			append_dev(div2, label0);
    			append_dev(div2, t7);
    			append_dev(div2, input0);
    			append_dev(div2, t8);
    			append_dev(div2, div1);
    			append_dev(div9, t10);
    			append_dev(div9, div4);
    			append_dev(div4, label1);
    			append_dev(div4, t12);
    			append_dev(div4, input1);
    			append_dev(div4, t13);
    			append_dev(div4, div3);
    			append_dev(div9, t15);
    			append_dev(div9, div5);
    			append_dev(div5, label2);
    			append_dev(div5, t17);
    			append_dev(div5, select);
    			append_dev(select, option0);
    			append_dev(select, option1);
    			append_dev(div9, t20);
    			append_dev(div9, div7);
    			append_dev(div7, label3);
    			append_dev(div7, t22);
    			append_dev(div7, input2);
    			append_dev(div7, t23);
    			append_dev(div7, div6);
    			append_dev(div9, t25);
    			append_dev(div9, div8);
    			append_dev(div8, label4);
    			append_dev(div8, t27);
    			append_dev(div8, input3);
    			append_dev(div14, t28);
    			append_dev(div14, div13);
    			append_dev(div13, div12);
    			append_dev(div12, div11);
    			append_dev(div13, t29);
    			append_dev(div13, button1);
    			append_dev(button1, span1);
    			append_dev(button1, span2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[2], false, false, false),
    					listen_dev(input0, "change", onKeyOrLabelChange$1, false, false, false),
    					listen_dev(input1, "change", onKeyOrLabelChange$1, false, false, false),
    					listen_dev(input2, "change", validateUploadForm$1, false, false, false),
    					listen_dev(button1, "click", /*doUploadMedia*/ ctx[1], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*$ShowUploadModalStore*/ 1 && input0_value_value !== (input0_value_value = /*$ShowUploadModalStore*/ ctx[0].newId) && input0.value !== input0_value_value) {
    				prop_dev(input0, "value", input0_value_value);
    			}

    			if (dirty & /*$ShowUploadModalStore*/ 1) {
    				toggle_class(div16, "show", /*$ShowUploadModalStore*/ ctx[0].shown);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!div16_transition) div16_transition = create_bidirectional_transition(div16, fly, { y: -250, duration: 500 }, true);
    				div16_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!div16_transition) div16_transition = create_bidirectional_transition(div16, fly, { y: -250, duration: 500 }, false);
    			div16_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div16);
    			if (detaching && div16_transition) div16_transition.end();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(133:4) {#if $ShowUploadModalStore.shown}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$j(ctx) {
    	let div;
    	let current;
    	let if_block = /*$ShowUploadModalStore*/ ctx[0].shown && create_if_block$a(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "id", "upload-media-background");
    			attr_dev(div, "class", "modal-background svelte-1tkumtz");
    			toggle_class(div, "show", /*$ShowUploadModalStore*/ ctx[0].shown);
    			add_location(div, file$j, 131, 0, 4237);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$ShowUploadModalStore*/ ctx[0].shown) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$ShowUploadModalStore*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$a(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*$ShowUploadModalStore*/ 1) {
    				toggle_class(div, "show", /*$ShowUploadModalStore*/ ctx[0].shown);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    async function validateUploadForm$1() {
    	const services = await getBackendClient();
    	const key = document.getElementById("mediaKey");
    	const label = document.getElementById("mediaLabel");
    	const mediaFile = document.getElementById("mediaFile");
    	let isInvalid = false;

    	if (!key.value || await services.mediaService.mediaExists(key.value)) {
    		key.classList.remove("is-valid");
    		key.classList.add("is-invalid");
    		isInvalid = true;
    	} else {
    		key.classList.remove("is-invalid");
    		key.classList.add("is-valid");
    	}

    	if (!label.value) {
    		label.classList.remove("is-valid");
    		label.classList.add("is-invalid");
    		isInvalid = true;
    	} else {
    		label.classList.add("is-valid");
    		label.classList.remove("is-invalid");
    	}

    	if (mediaFile.files.length === 0) {
    		mediaFile.classList.add("is-invalid");
    		mediaFile.classList.remove("is-valid");
    		isInvalid = true;
    	} else {
    		mediaFile.classList.add("is-valid");
    		mediaFile.classList.remove("is-invalid");
    	}

    	if (isInvalid) {
    		document.getElementById("do-upload-media").setAttribute("disabled", "");
    	} else {
    		document.getElementById("do-upload-media").removeAttribute("disabled");
    	}
    }

    async function onKeyOrLabelChange$1(event) {
    	const key = document.getElementById("mediaKey");
    	const label = document.getElementById("mediaLabel");

    	if (!key.value && label.value) {
    		key.value = label.value;
    	}

    	if (!label.value && key.value) {
    		label.value = key.value;
    	}

    	await validateUploadForm$1();
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let $ShowUploadModalStore;
    	validate_store(ShowUploadModalStore, "ShowUploadModalStore");
    	component_subscribe($$self, ShowUploadModalStore, $$value => $$invalidate(0, $ShowUploadModalStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("UploadMediaModal", slots, []);

    	async function doUploadMedia() {
    		document.getElementById("uploading-media-loading").classList.add("show");
    		document.getElementById("do-upload-media-text").innerText = "Uploading ...";
    		document.getElementById("do-upload-media").setAttribute("disabled", "");
    		document.getElementById("error-uploading-media").classList.remove("show");
    		let closeAfterAction = true;

    		try {
    			const services = await getBackendClient();
    			await services.mediaService.createMedia(document.getElementById("mediaFile").files[0], document.getElementById("mediaKey").value, document.getElementById("mediaLabel").value, document.getElementById("mediaVisibility").value, document.getElementById("mediaTags").value.split(" "));
    		} catch(error) {
    			document.getElementById("error-uploading-media-content").innerText = error.message;
    			document.getElementById("do-upload-media-text").innerText = "Upload Media";
    			document.getElementById("error-uploading-media").classList.add("show");
    			await validateUploadForm$1();
    			closeAfterAction = false;
    		} finally {
    			document.getElementById("uploading-media-loading").classList.remove("show");

    			if (closeAfterAction) {
    				document.getElementById("do-upload-media-text").innerText = "Upload OK";

    				window.setTimeout(
    					() => {
    						ShowUploadModalStore.set(new ShowUploadModal());
    					},
    					2000
    				);
    			}
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<UploadMediaModal> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		ShowUploadModalStore.set(new ShowUploadModal());
    	};

    	$$self.$capture_state = () => ({
    		MediaService: dist$1.MediaService,
    		ShowUploadModalStore,
    		ShowUploadModal,
    		fly,
    		doUploadMedia,
    		validateUploadForm: validateUploadForm$1,
    		onKeyOrLabelChange: onKeyOrLabelChange$1,
    		$ShowUploadModalStore
    	});

    	return [$ShowUploadModalStore, doUploadMedia, click_handler];
    }

    class UploadMediaModal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$j, create_fragment$j, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "UploadMediaModal",
    			options,
    			id: create_fragment$j.name
    		});
    	}
    }

    /* src/components/Editors/EntityEditors/MultiStringEditor.svelte generated by Svelte v3.38.2 */

    const { console: console_1$9 } = globals;
    const file$i = "src/components/Editors/EntityEditors/MultiStringEditor.svelte";

    function get_each_context$8(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    // (80:4) {#each stringArray as element}
    function create_each_block$8(ctx) {
    	let div;
    	let t_value = /*element*/ ctx[4] + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "multi-string-element svelte-1k6ryj5");
    			add_location(div, file$i, 80, 8, 2544);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*stringArray*/ 1 && t_value !== (t_value = /*element*/ ctx[4] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$8.name,
    		type: "each",
    		source: "(80:4) {#each stringArray as element}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$i(ctx) {
    	let div1;
    	let t0;
    	let div0;
    	let mounted;
    	let dispose;
    	let each_value = /*stringArray*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t0 = space();
    			div0 = element("div");
    			div0.textContent = " ";
    			attr_dev(div0, "class", "new-element svelte-1k6ryj5");
    			attr_dev(div0, "contenteditable", "true");
    			add_location(div0, file$i, 82, 4, 2610);
    			attr_dev(div1, "class", "multi-string-container svelte-1k6ryj5");
    			add_location(div1, file$i, 78, 0, 2464);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			append_dev(div1, t0);
    			append_dev(div1, div0);

    			if (!mounted) {
    				dispose = listen_dev(div0, "blur", /*onNewElement*/ ctx[1], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*stringArray*/ 1) {
    				each_value = /*stringArray*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$8(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$8(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div1, t0);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("MultiStringEditor", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	const dispatch = createEventDispatcher();
    	let { stringArray } = $$props;

    	//TODO : create a multistring input to manage
    	function onNewElement(event) {
    		return __awaiter(this, void 0, void 0, function* () {
    			const element = event.target;
    			const newValues = element.innerText.split(",");
    			let hasNew = false;

    			for (let newValue of newValues) {
    				if (newValue && newValue.trim() !== "" && element.innerHTML != "&nbsp") {
    					console.log(`#${newValue}#`);
    					stringArray.push(newValue.trim());
    					hasNew = true;
    				}
    			}

    			if (hasNew) dispatch("blur");
    			element.innerHTML = "&nbsp;";
    		});
    	}

    	const writable_props = ["stringArray"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$9.warn(`<MultiStringEditor> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("stringArray" in $$props) $$invalidate(0, stringArray = $$props.stringArray);
    	};

    	$$self.$capture_state = () => ({
    		__awaiter,
    		createEventDispatcher,
    		dispatch,
    		stringArray,
    		onNewElement
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("stringArray" in $$props) $$invalidate(0, stringArray = $$props.stringArray);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [stringArray, onNewElement];
    }

    class MultiStringEditor extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$i, create_fragment$i, safe_not_equal, { stringArray: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MultiStringEditor",
    			options,
    			id: create_fragment$i.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*stringArray*/ ctx[0] === undefined && !("stringArray" in props)) {
    			console_1$9.warn("<MultiStringEditor> was created without expected prop 'stringArray'");
    		}
    	}

    	get stringArray() {
    		throw new Error("<MultiStringEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set stringArray(value) {
    		throw new Error("<MultiStringEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Media/ContentAllMediaContainer.svelte generated by Svelte v3.38.2 */
    const file$h = "src/components/Media/ContentAllMediaContainer.svelte";

    function get_each_context$7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	return child_ctx;
    }

    // (319:12) {#each $AllMediaStores.media as media}
    function create_each_block$7(ctx) {
    	let div;
    	let switch_instance;
    	let t;
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = Helpers.getAttachmentComponent(/*media*/ ctx[10].mediaType);

    	function switch_props(ctx) {
    		return {
    			props: { attachment: /*media*/ ctx[10].key },
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	function click_handler() {
    		return /*click_handler*/ ctx[5](/*media*/ ctx[10]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			t = space();
    			attr_dev(div, "class", "media-container svelte-iwueg6");
    			add_location(div, file$h, 319, 16, 9651);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, div, null);
    			}

    			append_dev(div, t);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const switch_instance_changes = {};
    			if (dirty & /*$AllMediaStores*/ 2) switch_instance_changes.attachment = /*media*/ ctx[10].key;

    			if (switch_value !== (switch_value = Helpers.getAttachmentComponent(/*media*/ ctx[10].mediaType))) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div, t);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (switch_instance) destroy_component(switch_instance);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$7.name,
    		type: "each",
    		source: "(319:12) {#each $AllMediaStores.media as media}",
    		ctx
    	});

    	return block;
    }

    // (348:16) {#if mediaToEdit}
    function create_if_block_2$3(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Helpers.getAttachmentComponent(/*mediaToEdit*/ ctx[0].mediaType);

    	function switch_props(ctx) {
    		return {
    			props: { attachment: /*mediaToEdit*/ ctx[0].key },
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty & /*mediaToEdit*/ 1) switch_instance_changes.attachment = /*mediaToEdit*/ ctx[0].key;

    			if (switch_value !== (switch_value = Helpers.getAttachmentComponent(/*mediaToEdit*/ ctx[0].mediaType))) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$3.name,
    		type: "if",
    		source: "(348:16) {#if mediaToEdit}",
    		ctx
    	});

    	return block;
    }

    // (360:24) {#if mediaToEdit}
    function create_if_block_1$6(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			input = element("input");
    			attr_dev(input, "class", "form-control");
    			attr_dev(input, "id", "media-label-for-update");
    			attr_dev(input, "name", "media-label-for-update");
    			attr_dev(input, "type", "text");
    			input.required = true;
    			add_location(input, file$h, 360, 24, 11282);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*mediaToEdit*/ ctx[0].label);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(input, "change", validateUpdateForm, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*mediaToEdit*/ 1 && input.value !== /*mediaToEdit*/ ctx[0].label) {
    				set_input_value(input, /*mediaToEdit*/ ctx[0].label);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$6.name,
    		type: "if",
    		source: "(360:24) {#if mediaToEdit}",
    		ctx
    	});

    	return block;
    }

    // (384:24) {#if mediaToEdit}
    function create_if_block$9(ctx) {
    	let multistringeditor;
    	let updating_stringArray;
    	let current;

    	function multistringeditor_stringArray_binding(value) {
    		/*multistringeditor_stringArray_binding*/ ctx[7](value);
    	}

    	let multistringeditor_props = {};

    	if (/*mediaToEdit*/ ctx[0].tags !== void 0) {
    		multistringeditor_props.stringArray = /*mediaToEdit*/ ctx[0].tags;
    	}

    	multistringeditor = new MultiStringEditor({
    			props: multistringeditor_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind$2(multistringeditor, "stringArray", multistringeditor_stringArray_binding));
    	multistringeditor.$on("blur", /*blur_handler*/ ctx[8]);

    	const block = {
    		c: function create() {
    			create_component(multistringeditor.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(multistringeditor, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const multistringeditor_changes = {};

    			if (!updating_stringArray && dirty & /*mediaToEdit*/ 1) {
    				updating_stringArray = true;
    				multistringeditor_changes.stringArray = /*mediaToEdit*/ ctx[0].tags;
    				add_flush_callback(() => updating_stringArray = false);
    			}

    			multistringeditor.$set(multistringeditor_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(multistringeditor.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(multistringeditor.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(multistringeditor, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(384:24) {#if mediaToEdit}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$h(ctx) {
    	let main;
    	let div0;
    	let ul;
    	let li;
    	let i;
    	let span0;
    	let t1;
    	let div4;
    	let mediasearchbar;
    	let t2;
    	let div2;
    	let span1;
    	let t4;
    	let div1;
    	let span2;
    	let span3;
    	let span4;
    	let t8;
    	let div3;
    	let t9;
    	let uploadmediamodal;
    	let t10;
    	let div19;
    	let style;
    	let t12;
    	let div18;
    	let div17;
    	let div5;
    	let h5;
    	let t14;
    	let button0;
    	let span5;
    	let t16;
    	let div13;
    	let t17;
    	let div12;
    	let div7;
    	let label0;
    	let t19;
    	let div6;
    	let t20;
    	let div9;
    	let label1;
    	let t22;
    	let t23;
    	let div8;
    	let t25;
    	let div10;
    	let label2;
    	let t27;
    	let select;
    	let option0;
    	let option1;
    	let t30;
    	let div11;
    	let label3;
    	let t32;
    	let t33;
    	let div16;
    	let div15;
    	let div14;
    	let t34;
    	let button1;
    	let span6;
    	let span7;
    	let current;
    	let mounted;
    	let dispose;
    	mediasearchbar = new MediaSearchBar({ $$inline: true });
    	mediasearchbar.$on("search-started", onSearchStarted$1);
    	mediasearchbar.$on("search-ended", onSearchEnded$1);
    	let each_value = /*$AllMediaStores*/ ctx[1].media;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	uploadmediamodal = new UploadMediaModal({ $$inline: true });
    	let if_block0 = /*mediaToEdit*/ ctx[0] && create_if_block_2$3(ctx);
    	let if_block1 = /*mediaToEdit*/ ctx[0] && create_if_block_1$6(ctx);
    	let if_block2 = /*mediaToEdit*/ ctx[0] && create_if_block$9(ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			div0 = element("div");
    			ul = element("ul");
    			li = element("li");
    			i = element("i");
    			span0 = element("span");
    			span0.textContent = "Téléverser un media";
    			t1 = space();
    			div4 = element("div");
    			create_component(mediasearchbar.$$.fragment);
    			t2 = space();
    			div2 = element("div");
    			span1 = element("span");
    			span1.textContent = "Recherche en cours";
    			t4 = space();
    			div1 = element("div");
    			span2 = element("span");
    			span2.textContent = ".";
    			span3 = element("span");
    			span3.textContent = ".";
    			span4 = element("span");
    			span4.textContent = ".";
    			t8 = space();
    			div3 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t9 = space();
    			create_component(uploadmediamodal.$$.fragment);
    			t10 = space();
    			div19 = element("div");
    			style = element("style");
    			style.textContent = "label {\n            text-align: start;\n        }";
    			t12 = space();
    			div18 = element("div");
    			div17 = element("div");
    			div5 = element("div");
    			h5 = element("h5");
    			h5.textContent = "Upload un Media";
    			t14 = space();
    			button0 = element("button");
    			span5 = element("span");
    			span5.textContent = "×";
    			t16 = space();
    			div13 = element("div");
    			if (if_block0) if_block0.c();
    			t17 = space();
    			div12 = element("div");
    			div7 = element("div");
    			label0 = element("label");
    			label0.textContent = "Clé";
    			t19 = space();
    			div6 = element("div");
    			t20 = space();
    			div9 = element("div");
    			label1 = element("label");
    			label1.textContent = "Label";
    			t22 = space();
    			if (if_block1) if_block1.c();
    			t23 = space();
    			div8 = element("div");
    			div8.textContent = "Le label ne peut pas être vide.";
    			t25 = space();
    			div10 = element("div");
    			label2 = element("label");
    			label2.textContent = "Visibilité";
    			t27 = space();
    			select = element("select");
    			option0 = element("option");
    			option0.textContent = "Protégé";
    			option1 = element("option");
    			option1.textContent = "Public";
    			t30 = space();
    			div11 = element("div");
    			label3 = element("label");
    			label3.textContent = "Tags";
    			t32 = space();
    			if (if_block2) if_block2.c();
    			t33 = space();
    			div16 = element("div");
    			div15 = element("div");
    			div14 = element("div");
    			t34 = space();
    			button1 = element("button");
    			span6 = element("span");
    			span7 = element("span");
    			span7.textContent = "Enregistrer";
    			attr_dev(i, "class", "fas fa-2x fa-upload");
    			add_location(i, file$h, 301, 16, 9008);
    			attr_dev(span0, "class", "svelte-iwueg6");
    			add_location(span0, file$h, 301, 51, 9043);
    			attr_dev(li, "class", "media-action list-group-item list-group-item-dark list-group-item-action svelte-iwueg6");
    			add_location(li, file$h, 300, 12, 8879);
    			attr_dev(ul, "class", "list-group");
    			add_location(ul, file$h, 299, 8, 8843);
    			attr_dev(div0, "class", "media-menu svelte-iwueg6");
    			add_location(div0, file$h, 298, 4, 8810);
    			add_location(span1, file$h, 311, 12, 9342);
    			attr_dev(span2, "class", "first-point svelte-iwueg6");
    			add_location(span2, file$h, 313, 16, 9408);
    			attr_dev(span3, "class", "second-point svelte-iwueg6");
    			add_location(span3, file$h, 313, 50, 9442);
    			attr_dev(span4, "class", "third-point svelte-iwueg6");
    			add_location(span4, file$h, 313, 85, 9477);
    			add_location(div1, file$h, 312, 12, 9386);
    			attr_dev(div2, "class", "searching svelte-iwueg6");
    			add_location(div2, file$h, 310, 8, 9306);
    			attr_dev(div3, "class", "all-media-list svelte-iwueg6");
    			add_location(div3, file$h, 317, 8, 9555);
    			attr_dev(div4, "class", "all-media svelte-iwueg6");
    			add_location(div4, file$h, 305, 4, 9123);
    			attr_dev(main, "class", "all-media-panel svelte-iwueg6");
    			add_location(main, file$h, 297, 0, 8775);
    			add_location(style, file$h, 332, 4, 10072);
    			attr_dev(h5, "id", "create-channel-modal-title");
    			attr_dev(h5, "class", "modal-title");
    			add_location(h5, file$h, 341, 16, 10295);
    			attr_dev(span5, "aria-hidden", "true");
    			add_location(span5, file$h, 343, 20, 10501);
    			attr_dev(button0, "id", "ErrorClose");
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "close");
    			attr_dev(button0, "data-dismiss", "modal");
    			attr_dev(button0, "aria-label", "Close");
    			add_location(button0, file$h, 342, 16, 10388);
    			attr_dev(div5, "class", "modal-header");
    			add_location(div5, file$h, 340, 12, 10252);
    			attr_dev(label0, "for", "media-key-for-update");
    			add_location(label0, file$h, 354, 24, 10968);
    			attr_dev(div6, "id", "media-key-for-update");
    			add_location(div6, file$h, 355, 24, 11038);
    			attr_dev(div7, "class", "mb-3 svelte-iwueg6");
    			add_location(div7, file$h, 353, 20, 10925);
    			attr_dev(label1, "for", "media-label-for-update");
    			add_location(label1, file$h, 358, 24, 11166);
    			attr_dev(div8, "class", "invalid-feedback");
    			add_location(div8, file$h, 368, 24, 11691);
    			attr_dev(div9, "class", "mb-3 svelte-iwueg6");
    			add_location(div9, file$h, 357, 20, 11123);
    			attr_dev(label2, "for", "mediaVisibility");
    			add_location(label2, file$h, 373, 24, 11903);
    			option0.__value = "protected";
    			option0.value = option0.__value;
    			add_location(option0, file$h, 377, 28, 12262);
    			option1.__value = "public";
    			option1.value = option1.__value;
    			add_location(option1, file$h, 378, 28, 12334);
    			attr_dev(select, "class", "form-select");
    			attr_dev(select, "id", "media-visibility-for-update");
    			attr_dev(select, "name", "media-visibility-for-update");
    			select.required = true;
    			attr_dev(select, "title", "Un media protégé n'est accessible et visible que par des utilisateurs identifiés");
    			add_location(select, file$h, 374, 24, 11975);
    			attr_dev(div10, "class", "mb-3 svelte-iwueg6");
    			add_location(div10, file$h, 372, 20, 11860);
    			attr_dev(label3, "for", "mediaTags");
    			add_location(label3, file$h, 382, 24, 12497);
    			attr_dev(div11, "class", "mb-3 svelte-iwueg6");
    			add_location(div11, file$h, 381, 20, 12454);
    			attr_dev(div12, "id", "edit-media-form");
    			attr_dev(div12, "class", " svelte-iwueg6");
    			add_location(div12, file$h, 352, 16, 10869);
    			attr_dev(div13, "class", "modal-body");
    			add_location(div13, file$h, 346, 12, 10598);
    			attr_dev(div14, "id", "error-updating-media-content");
    			add_location(div14, file$h, 393, 20, 13052);
    			attr_dev(div15, "id", "error-updating-media");
    			attr_dev(div15, "class", "alert alert-danger fade svelte-iwueg6");
    			add_location(div15, file$h, 392, 16, 12968);
    			attr_dev(span6, "id", "update-media-loading");
    			attr_dev(span6, "class", "spinner-border svelte-iwueg6");
    			add_location(span6, file$h, 396, 20, 13257);
    			attr_dev(span7, "id", "do-update-media-text");
    			add_location(span7, file$h, 396, 82, 13319);
    			attr_dev(button1, "id", "do-update-media");
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn action btn-danger ");
    			add_location(button1, file$h, 395, 16, 13137);
    			attr_dev(div16, "class", "modal-footer modal-footer-update-footer svelte-iwueg6");
    			add_location(div16, file$h, 391, 12, 12898);
    			attr_dev(div17, "class", "modal-content");
    			add_location(div17, file$h, 339, 8, 10212);
    			attr_dev(div18, "class", "modal-dialog modal-dialog-centered");
    			add_location(div18, file$h, 338, 4, 10155);
    			attr_dev(div19, "id", "edit-media-modal");
    			attr_dev(div19, "class", "modal fade");
    			attr_dev(div19, "data-keyboard", "false");
    			add_location(div19, file$h, 331, 0, 9999);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div0);
    			append_dev(div0, ul);
    			append_dev(ul, li);
    			append_dev(li, i);
    			append_dev(li, span0);
    			append_dev(main, t1);
    			append_dev(main, div4);
    			mount_component(mediasearchbar, div4, null);
    			append_dev(div4, t2);
    			append_dev(div4, div2);
    			append_dev(div2, span1);
    			append_dev(div2, t4);
    			append_dev(div2, div1);
    			append_dev(div1, span2);
    			append_dev(div1, span3);
    			append_dev(div1, span4);
    			append_dev(div4, t8);
    			append_dev(div4, div3);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div3, null);
    			}

    			insert_dev(target, t9, anchor);
    			mount_component(uploadmediamodal, target, anchor);
    			insert_dev(target, t10, anchor);
    			insert_dev(target, div19, anchor);
    			append_dev(div19, style);
    			append_dev(div19, t12);
    			append_dev(div19, div18);
    			append_dev(div18, div17);
    			append_dev(div17, div5);
    			append_dev(div5, h5);
    			append_dev(div5, t14);
    			append_dev(div5, button0);
    			append_dev(button0, span5);
    			append_dev(div17, t16);
    			append_dev(div17, div13);
    			if (if_block0) if_block0.m(div13, null);
    			append_dev(div13, t17);
    			append_dev(div13, div12);
    			append_dev(div12, div7);
    			append_dev(div7, label0);
    			append_dev(div7, t19);
    			append_dev(div7, div6);
    			append_dev(div12, t20);
    			append_dev(div12, div9);
    			append_dev(div9, label1);
    			append_dev(div9, t22);
    			if (if_block1) if_block1.m(div9, null);
    			append_dev(div9, t23);
    			append_dev(div9, div8);
    			append_dev(div12, t25);
    			append_dev(div12, div10);
    			append_dev(div10, label2);
    			append_dev(div10, t27);
    			append_dev(div10, select);
    			append_dev(select, option0);
    			append_dev(select, option1);
    			append_dev(div12, t30);
    			append_dev(div12, div11);
    			append_dev(div11, label3);
    			append_dev(div11, t32);
    			if (if_block2) if_block2.m(div11, null);
    			append_dev(div17, t33);
    			append_dev(div17, div16);
    			append_dev(div16, div15);
    			append_dev(div15, div14);
    			append_dev(div16, t34);
    			append_dev(div16, button1);
    			append_dev(button1, span6);
    			append_dev(button1, span7);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(li, "click", /*showUploadMedia*/ ctx[2], false, false, false),
    					listen_dev(button1, "click", /*doUpdateMedia*/ ctx[4], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*displayMediaEdit, $AllMediaStores, Helpers*/ 10) {
    				each_value = /*$AllMediaStores*/ ctx[1].media;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$7(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$7(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div3, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (/*mediaToEdit*/ ctx[0]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*mediaToEdit*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_2$3(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div13, t17);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*mediaToEdit*/ ctx[0]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_1$6(ctx);
    					if_block1.c();
    					if_block1.m(div9, t23);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (/*mediaToEdit*/ ctx[0]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*mediaToEdit*/ 1) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block$9(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div11, null);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mediasearchbar.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(uploadmediamodal.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mediasearchbar.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(uploadmediamodal.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(mediasearchbar);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t9);
    			destroy_component(uploadmediamodal, detaching);
    			if (detaching) detach_dev(t10);
    			if (detaching) detach_dev(div19);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    async function onKeyOrLabelChange(event) {
    	const key = document.getElementById("mediaKey");
    	const label = document.getElementById("mediaLabel");

    	if (!key.value && label.value) {
    		key.value = label.value;
    	}

    	if (!label.value && key.value) {
    		label.value = key.value;
    	}

    	await validateUploadForm();
    }

    async function validateUploadForm() {
    	const services = await getBackendClient();
    	const key = document.getElementById("mediaKey");
    	const label = document.getElementById("mediaLabel");
    	const mediaFile = document.getElementById("mediaFile");
    	let isInvalid = false;

    	if (!key.value || await services.mediaService.mediaExists(key.value)) {
    		key.classList.remove("is-valid");
    		key.classList.add("is-invalid");
    		isInvalid = true;
    	} else {
    		key.classList.remove("is-invalid");
    		key.classList.add("is-valid");
    	}

    	if (!label.value) {
    		label.classList.remove("is-valid");
    		label.classList.add("is-invalid");
    		isInvalid = true;
    	} else {
    		label.classList.add("is-valid");
    		label.classList.remove("is-invalid");
    	}

    	if (mediaFile.files.length === 0) {
    		mediaFile.classList.add("is-invalid");
    		mediaFile.classList.remove("is-valid");
    		isInvalid = true;
    	} else {
    		mediaFile.classList.add("is-valid");
    		mediaFile.classList.remove("is-invalid");
    	}

    	if (isInvalid) {
    		document.getElementById("do-upload-media").setAttribute("disabled", "");
    	} else {
    		document.getElementById("do-upload-media").removeAttribute("disabled");
    	}
    }

    function onSearchStarted$1() {
    	document.querySelector(".searching").classList.add("show");
    }

    function onSearchEnded$1() {
    	document.querySelector(".searching").classList.remove("show");
    }

    async function validateUpdateForm() {
    	const label = document.getElementById("media-label-for-update");
    	let isInvalid = false;

    	if (!label.value) {
    		label.classList.remove("is-valid");
    		label.classList.add("is-invalid");
    		isInvalid = true;
    	} else {
    		label.classList.add("is-valid");
    		label.classList.remove("is-invalid");
    	}

    	if (isInvalid) {
    		document.getElementById("do-update-media").setAttribute("disabled", "");
    	} else {
    		document.getElementById("do-update-media").removeAttribute("disabled");
    	}
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let $AllMediaStores;
    	validate_store(AllMediaStores, "AllMediaStores");
    	component_subscribe($$self, AllMediaStores, $$value => $$invalidate(1, $AllMediaStores = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ContentAllMediaContainer", slots, []);
    	let mediaToEdit;

    	onMount(() => {
    		const updateModal = jQuery("#edit-media-modal");

    		updateModal.on("hidden.bs.modal", () => {
    			document.getElementById("media-label-for-update").value = "";
    			document.getElementById("media-key-for-update").value = "";
    			document.getElementById("media-visibility-for-update").value = "protected";
    			document.getElementById("do-update-media-text").innerText = "Enregistrer";
    			document.getElementById("do-update-media").removeAttribute("disabled");
    			$$invalidate(0, mediaToEdit = undefined);
    		});
    	});

    	afterUpdate(() => {
    		if (mediaToEdit) {
    			document.getElementById("media-key-for-update").innerText = mediaToEdit.key;
    			document.getElementById("media-label-for-update").value = mediaToEdit.label;
    			document.getElementById("media-visibility-for-update").value = mediaToEdit.visibility;
    			jQuery("#edit-media-modal").modal("show");
    		}
    	});

    	function showUploadMedia(event) {
    		ShowUploadModalStore.update(ums => {
    			ums.shown = true;
    			return ums;
    		});
    	}

    	async function doUploadMedia() {
    		ShowUploadModalStore.update(ums => {
    			ums.shown = true;
    			return ums;
    		});
    	}

    	async function displayMediaEdit(mediaKey) {
    		$$invalidate(0, mediaToEdit = $AllMediaStores.media.find(m => m.key === mediaKey));
    	}

    	async function doUpdateMedia() {
    		document.getElementById("update-media-loading").classList.add("show");
    		document.getElementById("do-update-media-text").innerText = "En cours ...";
    		document.getElementById("do-update-media").setAttribute("disabled", "");
    		document.getElementById("error-updating-media").classList.remove("show");
    		let closeAfterAction = true;

    		try {
    			const services = await getBackendClient();
    			await services.mediaService.updateMedia(document.getElementById("media-key-for-update").innerText, document.getElementById("media-label-for-update").value, document.getElementById("media-visibility-for-update").value, mediaToEdit.tags);
    		} catch(error) {
    			document.getElementById("error-updating-media-content").innerText = error.message;
    			document.getElementById("do-update-media-text").innerText = "Enregistrer";
    			document.getElementById("error-updating-media").classList.add("show");
    			await validateUpdateForm();
    			closeAfterAction = false;
    		} finally {
    			document.getElementById("update-media-loading").classList.remove("show");

    			if (closeAfterAction) {
    				document.getElementById("do-update-media-text").innerText = "Enregistrement OK";

    				window.setTimeout(
    					() => {
    						jQuery("#edit-media-modal").modal("hide");
    						$$invalidate(0, mediaToEdit = undefined);
    					},
    					2000
    				);
    			}
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ContentAllMediaContainer> was created with unknown prop '${key}'`);
    	});

    	const click_handler = media => displayMediaEdit(media.key);

    	function input_input_handler() {
    		mediaToEdit.label = this.value;
    		$$invalidate(0, mediaToEdit);
    	}

    	function multistringeditor_stringArray_binding(value) {
    		if ($$self.$$.not_equal(mediaToEdit.tags, value)) {
    			mediaToEdit.tags = value;
    			$$invalidate(0, mediaToEdit);
    		}
    	}

    	const blur_handler = () => {
    		$$invalidate(0, mediaToEdit);
    	};

    	$$self.$capture_state = () => ({
    		AllMediaStores,
    		MediaService: dist$1.MediaService,
    		Helpers,
    		onMount,
    		afterUpdate,
    		uuid: v4,
    		_,
    		MediaSearchBar,
    		UploadMediaModal,
    		ShowUploadModalStore,
    		MultiStringEditor,
    		mediaToEdit,
    		showUploadMedia,
    		onKeyOrLabelChange,
    		validateUploadForm,
    		doUploadMedia,
    		onSearchStarted: onSearchStarted$1,
    		onSearchEnded: onSearchEnded$1,
    		displayMediaEdit,
    		validateUpdateForm,
    		doUpdateMedia,
    		$AllMediaStores
    	});

    	$$self.$inject_state = $$props => {
    		if ("mediaToEdit" in $$props) $$invalidate(0, mediaToEdit = $$props.mediaToEdit);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		mediaToEdit,
    		$AllMediaStores,
    		showUploadMedia,
    		displayMediaEdit,
    		doUpdateMedia,
    		click_handler,
    		input_input_handler,
    		multistringeditor_stringArray_binding,
    		blur_handler
    	];
    }

    class ContentAllMediaContainer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$h, create_fragment$h, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ContentAllMediaContainer",
    			options,
    			id: create_fragment$h.name
    		});
    	}
    }

    /* src/components/ContentMediaContainer.svelte generated by Svelte v3.38.2 */

    const { console: console_1$8 } = globals;
    const file$g = "src/components/ContentMediaContainer.svelte";

    // (22:4) {#if properties.globalStyle}
    function create_if_block_1$5(ctx) {
    	let html_tag;
    	let raw_value = Helpers.styleOpeningLabel + /*properties*/ ctx[0].globalStyle + Helpers.styleClosingLabel + "";
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_anchor = empty$2();
    			html_tag = new HtmlTag(html_anchor);
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(raw_value, target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*properties*/ 1 && raw_value !== (raw_value = Helpers.styleOpeningLabel + /*properties*/ ctx[0].globalStyle + Helpers.styleClosingLabel + "")) html_tag.p(raw_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(22:4) {#if properties.globalStyle}",
    		ctx
    	});

    	return block;
    }

    // (27:4) {#if properties.content}
    function create_if_block$8(ctx) {
    	let html_tag;
    	let raw_value = /*properties*/ ctx[0].content + "";
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_anchor = empty$2();
    			html_tag = new HtmlTag(html_anchor);
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(raw_value, target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*properties*/ 1 && raw_value !== (raw_value = /*properties*/ ctx[0].content + "")) html_tag.p(raw_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(27:4) {#if properties.content}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$g(ctx) {
    	let main;
    	let t0;
    	let switch_instance;
    	let t1;
    	let main_style_value;
    	let current;
    	let if_block0 = /*properties*/ ctx[0].globalStyle && create_if_block_1$5(ctx);
    	var switch_value = Helpers.getAttachmentComponent(/*properties*/ ctx[0].mediaType);

    	function switch_props(ctx) {
    		return {
    			props: { attachment: /*properties*/ ctx[0].key },
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	let if_block1 = /*properties*/ ctx[0].content && create_if_block$8(ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			t1 = space();
    			if (if_block1) if_block1.c();
    			attr_dev(main, "style", main_style_value = /*properties*/ ctx[0].style);
    			attr_dev(main, "class", "svelte-b1d1z1");
    			add_location(main, file$g, 20, 0, 333);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			if (if_block0) if_block0.m(main, null);
    			append_dev(main, t0);

    			if (switch_instance) {
    				mount_component(switch_instance, main, null);
    			}

    			append_dev(main, t1);
    			if (if_block1) if_block1.m(main, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*properties*/ ctx[0].globalStyle) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_1$5(ctx);
    					if_block0.c();
    					if_block0.m(main, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			const switch_instance_changes = {};
    			if (dirty & /*properties*/ 1) switch_instance_changes.attachment = /*properties*/ ctx[0].key;

    			if (switch_value !== (switch_value = Helpers.getAttachmentComponent(/*properties*/ ctx[0].mediaType))) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, main, t1);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}

    			if (/*properties*/ ctx[0].content) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$8(ctx);
    					if_block1.c();
    					if_block1.m(main, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (!current || dirty & /*properties*/ 1 && main_style_value !== (main_style_value = /*properties*/ ctx[0].style)) {
    				attr_dev(main, "style", main_style_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if (if_block0) if_block0.d();
    			if (switch_instance) destroy_component(switch_instance);
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ContentMediaContainer", slots, []);
    	let { properties } = $$props;

    	onMount(() => {
    		console.log(properties);
    	});

    	const writable_props = ["properties"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$8.warn(`<ContentMediaContainer> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("properties" in $$props) $$invalidate(0, properties = $$props.properties);
    	};

    	$$self.$capture_state = () => ({ Helpers, onMount, properties });

    	$$self.$inject_state = $$props => {
    		if ("properties" in $$props) $$invalidate(0, properties = $$props.properties);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [properties];
    }

    class ContentMediaContainer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$g, create_fragment$g, safe_not_equal, { properties: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ContentMediaContainer",
    			options,
    			id: create_fragment$g.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*properties*/ ctx[0] === undefined && !("properties" in props)) {
    			console_1$8.warn("<ContentMediaContainer> was created without expected prop 'properties'");
    		}
    	}

    	get properties() {
    		throw new Error("<ContentMediaContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set properties(value) {
    		throw new Error("<ContentMediaContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Editors/ContentMediaContainerEditor.svelte generated by Svelte v3.38.2 */

    const { console: console_1$7 } = globals;

    const file$f = "src/components/Editors/ContentMediaContainerEditor.svelte";

    function get_each_context$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	return child_ctx;
    }

    // (223:16) {#each $AllMediaStores.media as media}
    function create_each_block$6(ctx) {
    	let div;
    	let switch_instance;
    	let t;
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = Helpers.getAttachmentComponent(/*media*/ ctx[8].mediaType);

    	function switch_props(ctx) {
    		return {
    			props: { attachment: /*media*/ ctx[8].key },
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    		switch_instance.$on("click", /*onMediaClick*/ ctx[4]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			t = space();
    			attr_dev(div, "class", "media-container svelte-1ea73p2");
    			toggle_class(div, "selected", /*media*/ ctx[8].key === /*properties*/ ctx[0].key);
    			add_location(div, file$f, 223, 20, 6359);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, div, null);
    			}

    			append_dev(div, t);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*onMediaClick*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty & /*$AllMediaStores*/ 2) switch_instance_changes.attachment = /*media*/ ctx[8].key;

    			if (switch_value !== (switch_value = Helpers.getAttachmentComponent(/*media*/ ctx[8].mediaType))) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					switch_instance.$on("click", /*onMediaClick*/ ctx[4]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div, t);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}

    			if (dirty & /*$AllMediaStores, properties*/ 3) {
    				toggle_class(div, "selected", /*media*/ ctx[8].key === /*properties*/ ctx[0].key);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (switch_instance) destroy_component(switch_instance);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$6.name,
    		type: "each",
    		source: "(223:16) {#each $AllMediaStores.media as media}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$f(ctx) {
    	let div10;
    	let div5;
    	let label0;
    	let t1;
    	let div0;
    	let switch_instance;
    	let t2;
    	let button;
    	let i;
    	let t4;
    	let div4;
    	let mediasearchbar;
    	let t5;
    	let div3;
    	let div2;
    	let span0;
    	let t7;
    	let div1;
    	let span1;
    	let span2;
    	let span3;
    	let t11;
    	let t12;
    	let div6;
    	let label1;
    	let t14;
    	let highlightededitor0;
    	let t15;
    	let div7;
    	let label2;
    	let t17;
    	let highlightededitor1;
    	let t18;
    	let div9;
    	let label3;
    	let t19;
    	let t20;
    	let div8;
    	let t21;
    	let uploadmediamodal;
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = Helpers.getAttachmentComponent(/*properties*/ ctx[0].mediaType);

    	function switch_props(ctx) {
    		return {
    			props: { attachment: /*properties*/ ctx[0].key },
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	mediasearchbar = new MediaSearchBar({ $$inline: true });
    	mediasearchbar.$on("search-started", onSearchStarted);
    	mediasearchbar.$on("search-ended", onSearchEnded);
    	let each_value = /*$AllMediaStores*/ ctx[1].media;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	highlightededitor0 = new HighlightedEditor({
    			props: {
    				id: "globalStyle",
    				content: /*properties*/ ctx[0].globalStyle
    				? /*properties*/ ctx[0].globalStyle
    				: "",
    				onChange: /*func*/ ctx[6]
    			},
    			$$inline: true
    		});

    	highlightededitor1 = new HighlightedEditor({
    			props: {
    				id: `style-${/*id*/ ctx[2]}`,
    				content: /*properties*/ ctx[0].style
    				? /*properties*/ ctx[0].style
    				: "",
    				onChange: /*func_1*/ ctx[7]
    			},
    			$$inline: true
    		});

    	uploadmediamodal = new UploadMediaModal({ $$inline: true });

    	const block = {
    		c: function create() {
    			div10 = element("div");
    			div5 = element("div");
    			label0 = element("label");
    			label0.textContent = "Media :";
    			t1 = space();
    			div0 = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			t2 = space();
    			button = element("button");
    			i = element("i");
    			i.textContent = "Ajouter un média";
    			t4 = space();
    			div4 = element("div");
    			create_component(mediasearchbar.$$.fragment);
    			t5 = space();
    			div3 = element("div");
    			div2 = element("div");
    			span0 = element("span");
    			span0.textContent = "Recherche en cours";
    			t7 = space();
    			div1 = element("div");
    			span1 = element("span");
    			span1.textContent = ".";
    			span2 = element("span");
    			span2.textContent = ".";
    			span3 = element("span");
    			span3.textContent = ".";
    			t11 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t12 = space();
    			div6 = element("div");
    			label1 = element("label");
    			label1.textContent = "Global Style :";
    			t14 = space();
    			create_component(highlightededitor0.$$.fragment);
    			t15 = space();
    			div7 = element("div");
    			label2 = element("label");
    			label2.textContent = "Style :";
    			t17 = space();
    			create_component(highlightededitor1.$$.fragment);
    			t18 = space();
    			div9 = element("div");
    			label3 = element("label");
    			t19 = text("Contenu HTML :");
    			t20 = space();
    			div8 = element("div");
    			t21 = space();
    			create_component(uploadmediamodal.$$.fragment);
    			attr_dev(label0, "for", "media");
    			attr_dev(label0, "class", "svelte-1ea73p2");
    			add_location(label0, file$f, 203, 8, 5294);
    			attr_dev(div0, "id", "media");
    			attr_dev(div0, "class", "current-media svelte-1ea73p2");
    			add_location(div0, file$f, 204, 8, 5337);
    			attr_dev(i, "class", "fas fa-plus-circle");
    			add_location(i, file$f, 211, 15, 5739);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "class", "btn btn-secondary");
    			add_location(button, file$f, 207, 8, 5523);
    			add_location(span0, file$f, 217, 20, 6048);
    			attr_dev(span1, "class", "first-point svelte-1ea73p2");
    			add_location(span1, file$f, 219, 24, 6130);
    			attr_dev(span2, "class", "second-point svelte-1ea73p2");
    			add_location(span2, file$f, 219, 58, 6164);
    			attr_dev(span3, "class", "third-point svelte-1ea73p2");
    			add_location(span3, file$f, 219, 93, 6199);
    			add_location(div1, file$f, 218, 20, 6100);
    			attr_dev(div2, "class", "searching svelte-1ea73p2");
    			add_location(div2, file$f, 216, 16, 6004);
    			attr_dev(div3, "class", "all-media-list svelte-1ea73p2");
    			add_location(div3, file$f, 215, 12, 5959);
    			attr_dev(div4, "id", "media-select-zone");
    			attr_dev(div4, "class", "svelte-1ea73p2");
    			add_location(div4, file$f, 212, 8, 5803);
    			attr_dev(div5, "class", "media svelte-1ea73p2");
    			add_location(div5, file$f, 202, 4, 5266);
    			attr_dev(label1, "for", "globalStyle");
    			attr_dev(label1, "class", "svelte-1ea73p2");
    			add_location(label1, file$f, 232, 8, 6741);
    			attr_dev(div6, "class", "global-style");
    			add_location(div6, file$f, 231, 4, 6706);
    			attr_dev(label2, "for", "style");
    			attr_dev(label2, "class", "svelte-1ea73p2");
    			add_location(label2, file$f, 243, 8, 7137);
    			attr_dev(div7, "class", "style");
    			add_location(div7, file$f, 242, 4, 7109);
    			attr_dev(label3, "for", "content-" + /*id*/ ctx[2]);
    			attr_dev(label3, "class", "svelte-1ea73p2");
    			add_location(label3, file$f, 254, 8, 7506);
    			attr_dev(div8, "id", "content-" + /*id*/ ctx[2]);
    			attr_dev(div8, "class", "svelte-1ea73p2");
    			add_location(div8, file$f, 255, 8, 7563);
    			attr_dev(div9, "class", "content svelte-1ea73p2");
    			add_location(div9, file$f, 253, 4, 7476);
    			attr_dev(div10, "class", "media-editor svelte-1ea73p2");
    			add_location(div10, file$f, 201, 0, 5235);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div10, anchor);
    			append_dev(div10, div5);
    			append_dev(div5, label0);
    			append_dev(div5, t1);
    			append_dev(div5, div0);

    			if (switch_instance) {
    				mount_component(switch_instance, div0, null);
    			}

    			append_dev(div5, t2);
    			append_dev(div5, button);
    			append_dev(button, i);
    			append_dev(div5, t4);
    			append_dev(div5, div4);
    			mount_component(mediasearchbar, div4, null);
    			append_dev(div4, t5);
    			append_dev(div4, div3);
    			append_dev(div3, div2);
    			append_dev(div2, span0);
    			append_dev(div2, t7);
    			append_dev(div2, div1);
    			append_dev(div1, span1);
    			append_dev(div1, span2);
    			append_dev(div1, span3);
    			append_dev(div3, t11);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div3, null);
    			}

    			append_dev(div10, t12);
    			append_dev(div10, div6);
    			append_dev(div6, label1);
    			append_dev(div6, t14);
    			mount_component(highlightededitor0, div6, null);
    			append_dev(div10, t15);
    			append_dev(div10, div7);
    			append_dev(div7, label2);
    			append_dev(div7, t17);
    			mount_component(highlightededitor1, div7, null);
    			append_dev(div10, t18);
    			append_dev(div10, div9);
    			append_dev(div9, label3);
    			append_dev(label3, t19);
    			append_dev(div9, t20);
    			append_dev(div9, div8);
    			insert_dev(target, t21, anchor);
    			mount_component(uploadmediamodal, target, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*properties*/ 1) switch_instance_changes.attachment = /*properties*/ ctx[0].key;

    			if (switch_value !== (switch_value = Helpers.getAttachmentComponent(/*properties*/ ctx[0].mediaType))) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div0, null);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}

    			if (dirty & /*$AllMediaStores, properties, onMediaClick, Helpers*/ 19) {
    				each_value = /*$AllMediaStores*/ ctx[1].media;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$6(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$6(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div3, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			const highlightededitor0_changes = {};

    			if (dirty & /*properties*/ 1) highlightededitor0_changes.content = /*properties*/ ctx[0].globalStyle
    			? /*properties*/ ctx[0].globalStyle
    			: "";

    			if (dirty & /*properties*/ 1) highlightededitor0_changes.onChange = /*func*/ ctx[6];
    			highlightededitor0.$set(highlightededitor0_changes);
    			const highlightededitor1_changes = {};

    			if (dirty & /*properties*/ 1) highlightededitor1_changes.content = /*properties*/ ctx[0].style
    			? /*properties*/ ctx[0].style
    			: "";

    			if (dirty & /*properties*/ 1) highlightededitor1_changes.onChange = /*func_1*/ ctx[7];
    			highlightededitor1.$set(highlightededitor1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			transition_in(mediasearchbar.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(highlightededitor0.$$.fragment, local);
    			transition_in(highlightededitor1.$$.fragment, local);
    			transition_in(uploadmediamodal.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			transition_out(mediasearchbar.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(highlightededitor0.$$.fragment, local);
    			transition_out(highlightededitor1.$$.fragment, local);
    			transition_out(uploadmediamodal.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div10);
    			if (switch_instance) destroy_component(switch_instance);
    			destroy_component(mediasearchbar);
    			destroy_each(each_blocks, detaching);
    			destroy_component(highlightededitor0);
    			destroy_component(highlightededitor1);
    			if (detaching) detach_dev(t21);
    			destroy_component(uploadmediamodal, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function onSearchStarted() {
    	document.querySelector(".searching").classList.add("show");
    }

    function onSearchEnded() {
    	document.querySelector(".searching").classList.remove("show");
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let $AllMediaStores;
    	validate_store(AllMediaStores, "AllMediaStores");
    	component_subscribe($$self, AllMediaStores, $$value => $$invalidate(1, $AllMediaStores = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ContentMediaContainerEditor", slots, []);
    	let { properties } = $$props;
    	let id = v4();

    	onMount(() => {
    		console.log(properties);

    		window.setTimeout(() => {
    			const contentText = document.getElementById(`content-${id}`);
    			console.log(contentText);

    			const editor = new Editor({
    					target: contentText,
    					props: {
    						actions: ["b", "i", "u", "strike", "ul", "ol", "viewHtml"],
    						html: properties.content
    					}
    				});

    			editor.$on("change", e => {
    				$$invalidate(0, properties.content = editor.getHtml(), properties);
    				updateEds();
    			});

    			window.setTimeout(() => {
    				document.querySelector("button[title=\"View HTML\"]").click();
    			});
    		});
    	});

    	onDestroy(() => {
    		AllMediaStores.media = [];
    	});

    	function updateEds() {
    		EditableDocumentStore.update(eds => {
    			return eds;
    		});
    	}

    	async function onMediaClick(event) {
    		const services = await getBackendClient();

    		if (event.detail && event.detail.target && event.detail.target.getAttribute("data-media-key")) {
    			console.log("updating media");
    			const mediaMetadata = await services.mediaService.getMediaMetadata(event.detail.target.getAttribute("data-media-key"));
    			console.log(mediaMetadata);

    			if (mediaMetadata && mediaMetadata.key !== properties.key) {
    				$$invalidate(0, properties.key = mediaMetadata.key, properties);
    				$$invalidate(0, properties.mediaType = mediaMetadata.mediaType, properties);
    				$$invalidate(0, properties);
    				updateEds();
    			}
    		}
    	}

    	const writable_props = ["properties"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$7.warn(`<ContentMediaContainerEditor> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		const show = new ShowUploadModal();
    		show.shown = true;
    		ShowUploadModalStore.set(show);
    	};

    	const func = newStyle => {
    		$$invalidate(0, properties.globalStyle = newStyle, properties);
    		updateEds();
    	};

    	const func_1 = newStyle => {
    		$$invalidate(0, properties.style = newStyle, properties);
    		updateEds();
    	};

    	$$self.$$set = $$props => {
    		if ("properties" in $$props) $$invalidate(0, properties = $$props.properties);
    	};

    	$$self.$capture_state = () => ({
    		Editor,
    		uuid: v4,
    		onMount,
    		onDestroy,
    		EditableDocumentStore,
    		HighlightedEditor,
    		MediaSearchBar,
    		AllMediaStores,
    		Helpers,
    		UploadMediaModal,
    		ShowUploadModalStore,
    		ShowUploadModal,
    		properties,
    		id,
    		updateEds,
    		onSearchStarted,
    		onSearchEnded,
    		onMediaClick,
    		$AllMediaStores
    	});

    	$$self.$inject_state = $$props => {
    		if ("properties" in $$props) $$invalidate(0, properties = $$props.properties);
    		if ("id" in $$props) $$invalidate(2, id = $$props.id);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		properties,
    		$AllMediaStores,
    		id,
    		updateEds,
    		onMediaClick,
    		click_handler,
    		func,
    		func_1
    	];
    }

    class ContentMediaContainerEditor extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$f, create_fragment$f, safe_not_equal, { properties: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ContentMediaContainerEditor",
    			options,
    			id: create_fragment$f.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*properties*/ ctx[0] === undefined && !("properties" in props)) {
    			console_1$7.warn("<ContentMediaContainerEditor> was created without expected prop 'properties'");
    		}
    	}

    	get properties() {
    		throw new Error("<ContentMediaContainerEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set properties(value) {
    		throw new Error("<ContentMediaContainerEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Editors/ContentImageContainerEditor.svelte generated by Svelte v3.38.2 */

    const { console: console_1$6 } = globals;
    const file$e = "src/components/Editors/ContentImageContainerEditor.svelte";

    function create_fragment$e(ctx) {
    	let div0;
    	let label0;
    	let t0;
    	let t1;
    	let input0;
    	let input0_value_value;
    	let t2;
    	let div1;
    	let label1;
    	let t4;
    	let input1;
    	let t5;
    	let div2;
    	let label2;
    	let t6;
    	let t7;
    	let highlightededitor0;
    	let t8;
    	let div3;
    	let label3;
    	let t9;
    	let t10;
    	let highlightededitor1;
    	let t11;
    	let div5;
    	let label4;
    	let t12;
    	let t13;
    	let div4;
    	let current;
    	let mounted;
    	let dispose;

    	highlightededitor0 = new HighlightedEditor({
    			props: {
    				id: `style-${/*id*/ ctx[1]}`,
    				content: /*properties*/ ctx[0].style
    				? /*properties*/ ctx[0].style
    				: "",
    				onChange: /*func*/ ctx[5]
    			},
    			$$inline: true
    		});

    	highlightededitor1 = new HighlightedEditor({
    			props: {
    				id: `global-style-${/*id*/ ctx[1]}`,
    				content: /*properties*/ ctx[0].globalStyle
    				? /*properties*/ ctx[0].innerStyle
    				: "",
    				onChange: /*func_1*/ ctx[6]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			label0 = element("label");
    			t0 = text("Url");
    			t1 = space();
    			input0 = element("input");
    			t2 = space();
    			div1 = element("div");
    			label1 = element("label");
    			label1.textContent = "CSS Classes :";
    			t4 = space();
    			input1 = element("input");
    			t5 = space();
    			div2 = element("div");
    			label2 = element("label");
    			t6 = text("Style :");
    			t7 = space();
    			create_component(highlightededitor0.$$.fragment);
    			t8 = space();
    			div3 = element("div");
    			label3 = element("label");
    			t9 = text("Global Style :");
    			t10 = space();
    			create_component(highlightededitor1.$$.fragment);
    			t11 = space();
    			div5 = element("div");
    			label4 = element("label");
    			t12 = text("Texte :");
    			t13 = space();
    			div4 = element("div");
    			attr_dev(label0, "for", "uri-" + /*id*/ ctx[1]);
    			attr_dev(label0, "class", "svelte-1u9ur0u");
    			add_location(label0, file$e, 61, 4, 1519);
    			attr_dev(input0, "id", "uri-" + /*id*/ ctx[1]);

    			input0.value = input0_value_value = /*properties*/ ctx[0].uri
    			? /*properties*/ ctx[0].uri
    			: "";

    			attr_dev(input0, "type", "url");
    			attr_dev(input0, "class", "form-control");
    			attr_dev(input0, "placeholder", "Taper l'url de l'image");
    			add_location(input0, file$e, 62, 4, 1557);
    			attr_dev(div0, "class", "url");
    			add_location(div0, file$e, 60, 0, 1497);
    			attr_dev(label1, "for", "classes");
    			attr_dev(label1, "class", "svelte-1u9ur0u");
    			add_location(label1, file$e, 69, 4, 1868);
    			attr_dev(input1, "id", "classes");
    			attr_dev(input1, "type", "text");
    			attr_dev(input1, "class", "form-control");
    			attr_dev(input1, "placeholder", "Taper le nom des classes css séparées par un espace");
    			add_location(input1, file$e, 70, 4, 1915);
    			attr_dev(div1, "class", "classes");
    			add_location(div1, file$e, 68, 0, 1842);
    			attr_dev(label2, "for", `style-${/*id*/ ctx[1]}`);
    			attr_dev(label2, "class", "svelte-1u9ur0u");
    			add_location(label2, file$e, 73, 4, 2098);
    			attr_dev(div2, "class", "style");
    			add_location(div2, file$e, 72, 0, 2074);
    			attr_dev(label3, "for", `global-style-${/*id*/ ctx[1]}`);
    			attr_dev(label3, "class", "svelte-1u9ur0u");
    			add_location(label3, file$e, 84, 4, 2437);
    			attr_dev(div3, "class", "style");
    			add_location(div3, file$e, 83, 0, 2413);
    			attr_dev(label4, "for", "content-" + /*id*/ ctx[1]);
    			attr_dev(label4, "class", "svelte-1u9ur0u");
    			add_location(label4, file$e, 95, 4, 2816);
    			attr_dev(div4, "id", "content-" + /*id*/ ctx[1]);
    			add_location(div4, file$e, 96, 4, 2862);
    			attr_dev(div5, "class", "content svelte-1u9ur0u");
    			add_location(div5, file$e, 94, 0, 2790);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, label0);
    			append_dev(label0, t0);
    			append_dev(div0, t1);
    			append_dev(div0, input0);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, label1);
    			append_dev(div1, t4);
    			append_dev(div1, input1);
    			set_input_value(input1, /*properties*/ ctx[0].classes);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, label2);
    			append_dev(label2, t6);
    			append_dev(div2, t7);
    			mount_component(highlightededitor0, div2, null);
    			insert_dev(target, t8, anchor);
    			insert_dev(target, div3, anchor);
    			append_dev(div3, label3);
    			append_dev(label3, t9);
    			append_dev(div3, t10);
    			mount_component(highlightededitor1, div3, null);
    			insert_dev(target, t11, anchor);
    			insert_dev(target, div5, anchor);
    			append_dev(div5, label4);
    			append_dev(label4, t12);
    			append_dev(div5, t13);
    			append_dev(div5, div4);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "blur", /*blur_handler*/ ctx[3], false, false, false),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[4])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*properties*/ 1 && input0_value_value !== (input0_value_value = /*properties*/ ctx[0].uri
    			? /*properties*/ ctx[0].uri
    			: "")) {
    				prop_dev(input0, "value", input0_value_value);
    			}

    			if (dirty & /*properties*/ 1 && input1.value !== /*properties*/ ctx[0].classes) {
    				set_input_value(input1, /*properties*/ ctx[0].classes);
    			}

    			const highlightededitor0_changes = {};

    			if (dirty & /*properties*/ 1) highlightededitor0_changes.content = /*properties*/ ctx[0].style
    			? /*properties*/ ctx[0].style
    			: "";

    			if (dirty & /*properties*/ 1) highlightededitor0_changes.onChange = /*func*/ ctx[5];
    			highlightededitor0.$set(highlightededitor0_changes);
    			const highlightededitor1_changes = {};

    			if (dirty & /*properties*/ 1) highlightededitor1_changes.content = /*properties*/ ctx[0].globalStyle
    			? /*properties*/ ctx[0].innerStyle
    			: "";

    			if (dirty & /*properties*/ 1) highlightededitor1_changes.onChange = /*func_1*/ ctx[6];
    			highlightededitor1.$set(highlightededitor1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(highlightededitor0.$$.fragment, local);
    			transition_in(highlightededitor1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(highlightededitor0.$$.fragment, local);
    			transition_out(highlightededitor1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(div2);
    			destroy_component(highlightededitor0);
    			if (detaching) detach_dev(t8);
    			if (detaching) detach_dev(div3);
    			destroy_component(highlightededitor1);
    			if (detaching) detach_dev(t11);
    			if (detaching) detach_dev(div5);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let $ComponentEditorStore;
    	validate_store(ComponentEditorStore, "ComponentEditorStore");
    	component_subscribe($$self, ComponentEditorStore, $$value => $$invalidate(7, $ComponentEditorStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ContentImageContainerEditor", slots, []);
    	let { properties } = $$props;
    	let id = v4();

    	onMount(() => {
    		if (!properties.uri) {
    			$$invalidate(0, properties.uri = "", properties);
    			$$invalidate(0, properties);
    		}

    		window.setTimeout(() => {
    			const contentText = document.getElementById(`content-${id}`);
    			console.log(contentText);

    			const editor = new Editor({
    					target: contentText,
    					props: {
    						actions: ["b", "i", "u", "strike", "ul", "ol", "viewHtml"],
    						html: properties.content
    					}
    				});

    			editor.$on("change", e => {
    				$$invalidate(0, properties.content = editor.getHtml(), properties);
    				updateEds();
    			});
    		});
    	});

    	function updateEds() {
    		EditableDocumentStore.update(eds => {
    			return eds;
    		});
    	}

    	afterUpdate(() => {
    		console.log("editor updated");
    	});

    	const writable_props = ["properties"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$6.warn(`<ContentImageContainerEditor> was created with unknown prop '${key}'`);
    	});

    	const blur_handler = () => {
    		$$invalidate(0, properties.uri = document.getElementById(`uri-${id}`).value, properties);
    		updateEds();
    	};

    	function input1_input_handler() {
    		properties.classes = this.value;
    		$$invalidate(0, properties);
    	}

    	const func = newStyle => {
    		$$invalidate(0, properties.style = newStyle, properties);
    		updateEds();
    	};

    	const func_1 = newStyle => {
    		$$invalidate(0, properties.globalStyle = newStyle, properties);
    		updateEds();
    	};

    	$$self.$$set = $$props => {
    		if ("properties" in $$props) $$invalidate(0, properties = $$props.properties);
    	};

    	$$self.$capture_state = () => ({
    		Editor,
    		uuid: v4,
    		onMount,
    		afterUpdate,
    		EditableDocumentStore,
    		ComponentEditorStore,
    		HighlightedEditor,
    		properties,
    		id,
    		updateEds,
    		$ComponentEditorStore
    	});

    	$$self.$inject_state = $$props => {
    		if ("properties" in $$props) $$invalidate(0, properties = $$props.properties);
    		if ("id" in $$props) $$invalidate(1, id = $$props.id);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [properties, id, updateEds, blur_handler, input1_input_handler, func, func_1];
    }

    class ContentImageContainerEditor extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$e, create_fragment$e, safe_not_equal, { properties: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ContentImageContainerEditor",
    			options,
    			id: create_fragment$e.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*properties*/ ctx[0] === undefined && !("properties" in props)) {
    			console_1$6.warn("<ContentImageContainerEditor> was created without expected prop 'properties'");
    		}
    	}

    	get properties() {
    		throw new Error("<ContentImageContainerEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set properties(value) {
    		throw new Error("<ContentImageContainerEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Editors/ContentTitleContainerEditor.svelte generated by Svelte v3.38.2 */

    const { console: console_1$5 } = globals;
    const file$d = "src/components/Editors/ContentTitleContainerEditor.svelte";

    function create_fragment$d(ctx) {
    	let div0;
    	let label0;
    	let t1;
    	let input;
    	let t2;
    	let div1;
    	let label1;
    	let t3;
    	let t4;
    	let highlightededitor0;
    	let t5;
    	let div2;
    	let label2;
    	let t6;
    	let t7;
    	let highlightededitor1;
    	let t8;
    	let div4;
    	let label3;
    	let t9;
    	let t10;
    	let div3;
    	let current;
    	let mounted;
    	let dispose;

    	highlightededitor0 = new HighlightedEditor({
    			props: {
    				id: `style-${/*id*/ ctx[1]}`,
    				content: /*properties*/ ctx[0].style
    				? /*properties*/ ctx[0].style
    				: "",
    				onChange: /*func*/ ctx[4]
    			},
    			$$inline: true
    		});

    	highlightededitor1 = new HighlightedEditor({
    			props: {
    				id: `global-style-${/*id*/ ctx[1]}`,
    				content: /*properties*/ ctx[0].globalStyle
    				? /*properties*/ ctx[0].innerStyle
    				: "",
    				onChange: /*func_1*/ ctx[5]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			label0 = element("label");
    			label0.textContent = "CSS Classes :";
    			t1 = space();
    			input = element("input");
    			t2 = space();
    			div1 = element("div");
    			label1 = element("label");
    			t3 = text("Container Style :");
    			t4 = space();
    			create_component(highlightededitor0.$$.fragment);
    			t5 = space();
    			div2 = element("div");
    			label2 = element("label");
    			t6 = text("Global Style :");
    			t7 = space();
    			create_component(highlightededitor1.$$.fragment);
    			t8 = space();
    			div4 = element("div");
    			label3 = element("label");
    			t9 = text("Texte :");
    			t10 = space();
    			div3 = element("div");
    			attr_dev(label0, "for", "classes");
    			attr_dev(label0, "class", "svelte-1u9ur0u");
    			add_location(label0, file$d, 57, 4, 1443);
    			attr_dev(input, "id", "classes");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "class", "form-control");
    			attr_dev(input, "placeholder", "Taper le nom des classes css séparées par un espace");
    			add_location(input, file$d, 58, 4, 1490);
    			attr_dev(div0, "class", "");
    			add_location(div0, file$d, 56, 0, 1424);
    			attr_dev(label1, "for", `style-${/*id*/ ctx[1]}`);
    			attr_dev(label1, "class", "svelte-1u9ur0u");
    			add_location(label1, file$d, 61, 4, 1673);
    			attr_dev(div1, "class", "style");
    			add_location(div1, file$d, 60, 0, 1649);
    			attr_dev(label2, "for", `global-style-${/*id*/ ctx[1]}`);
    			attr_dev(label2, "class", "svelte-1u9ur0u");
    			add_location(label2, file$d, 72, 4, 2022);
    			attr_dev(div2, "class", "style");
    			add_location(div2, file$d, 71, 0, 1998);
    			attr_dev(label3, "for", "content-" + /*id*/ ctx[1]);
    			attr_dev(label3, "class", "svelte-1u9ur0u");
    			add_location(label3, file$d, 83, 4, 2401);
    			attr_dev(div3, "id", "content-" + /*id*/ ctx[1]);
    			add_location(div3, file$d, 84, 4, 2447);
    			attr_dev(div4, "class", "content svelte-1u9ur0u");
    			add_location(div4, file$d, 82, 0, 2375);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, label0);
    			append_dev(div0, t1);
    			append_dev(div0, input);
    			set_input_value(input, /*properties*/ ctx[0].classes);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, label1);
    			append_dev(label1, t3);
    			append_dev(div1, t4);
    			mount_component(highlightededitor0, div1, null);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, label2);
    			append_dev(label2, t6);
    			append_dev(div2, t7);
    			mount_component(highlightededitor1, div2, null);
    			insert_dev(target, t8, anchor);
    			insert_dev(target, div4, anchor);
    			append_dev(div4, label3);
    			append_dev(label3, t9);
    			append_dev(div4, t10);
    			append_dev(div4, div3);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(input, "input", /*input_input_handler*/ ctx[3]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*properties*/ 1 && input.value !== /*properties*/ ctx[0].classes) {
    				set_input_value(input, /*properties*/ ctx[0].classes);
    			}

    			const highlightededitor0_changes = {};

    			if (dirty & /*properties*/ 1) highlightededitor0_changes.content = /*properties*/ ctx[0].style
    			? /*properties*/ ctx[0].style
    			: "";

    			if (dirty & /*properties*/ 1) highlightededitor0_changes.onChange = /*func*/ ctx[4];
    			highlightededitor0.$set(highlightededitor0_changes);
    			const highlightededitor1_changes = {};

    			if (dirty & /*properties*/ 1) highlightededitor1_changes.content = /*properties*/ ctx[0].globalStyle
    			? /*properties*/ ctx[0].innerStyle
    			: "";

    			if (dirty & /*properties*/ 1) highlightededitor1_changes.onChange = /*func_1*/ ctx[5];
    			highlightededitor1.$set(highlightededitor1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(highlightededitor0.$$.fragment, local);
    			transition_in(highlightededitor1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(highlightededitor0.$$.fragment, local);
    			transition_out(highlightededitor1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div1);
    			destroy_component(highlightededitor0);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(div2);
    			destroy_component(highlightededitor1);
    			if (detaching) detach_dev(t8);
    			if (detaching) detach_dev(div4);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let $ComponentEditorStore;
    	validate_store(ComponentEditorStore, "ComponentEditorStore");
    	component_subscribe($$self, ComponentEditorStore, $$value => $$invalidate(6, $ComponentEditorStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ContentTitleContainerEditor", slots, []);
    	let { properties } = $$props;
    	let id = v4();

    	afterUpdate(() => {
    		console.log("editor updated");
    	});

    	onMount(() => {
    		window.setTimeout(() => {
    			const contentText = document.getElementById(`content-${id}`);
    			console.log(contentText);

    			const editor = new Editor({
    					target: contentText,
    					props: {
    						actions: [
    							"left",
    							"center",
    							"right",
    							"justify",
    							"b",
    							"i",
    							"u",
    							"strike",
    							"ul",
    							"ol",
    							"a",
    							"viewHtml"
    						],
    						html: properties.title
    					}
    				});

    			editor.$on("change", e => {
    				$$invalidate(0, properties.title = editor.getHtml(), properties);
    				updateEds();
    			});
    		});
    	});

    	function updateEds() {
    		EditableDocumentStore.update(eds => {
    			return eds;
    		});
    	}

    	const writable_props = ["properties"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$5.warn(`<ContentTitleContainerEditor> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		properties.classes = this.value;
    		$$invalidate(0, properties);
    	}

    	const func = newStyle => {
    		$$invalidate(0, properties.style = newStyle, properties);
    		updateEds();
    	};

    	const func_1 = newStyle => {
    		$$invalidate(0, properties.globalStyle = newStyle, properties);
    		updateEds();
    	};

    	$$self.$$set = $$props => {
    		if ("properties" in $$props) $$invalidate(0, properties = $$props.properties);
    	};

    	$$self.$capture_state = () => ({
    		Editor,
    		uuid: v4,
    		onMount,
    		afterUpdate,
    		EditableDocumentStore,
    		ComponentEditorStore,
    		HighlightedEditor,
    		properties,
    		id,
    		updateEds,
    		$ComponentEditorStore
    	});

    	$$self.$inject_state = $$props => {
    		if ("properties" in $$props) $$invalidate(0, properties = $$props.properties);
    		if ("id" in $$props) $$invalidate(1, id = $$props.id);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [properties, id, updateEds, input_input_handler, func, func_1];
    }

    class ContentTitleContainerEditor extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$d, create_fragment$d, safe_not_equal, { properties: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ContentTitleContainerEditor",
    			options,
    			id: create_fragment$d.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*properties*/ ctx[0] === undefined && !("properties" in props)) {
    			console_1$5.warn("<ContentTitleContainerEditor> was created without expected prop 'properties'");
    		}
    	}

    	get properties() {
    		throw new Error("<ContentTitleContainerEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set properties(value) {
    		throw new Error("<ContentTitleContainerEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    class ShowModalUserEvent {
        constructor() {
            const today = new Date();
            this.shown = false;
            this.startDate = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0);
            this.endDate = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 23, 59);
        }
    }
    const ShowCreateUserEventStore = writable(new ShowModalUserEvent());
    const ShowUpdateUserEventStore = writable(new ShowModalUserEvent());

    /* src/components/UserEvents/CreateUserEventModal.svelte generated by Svelte v3.38.2 */

    const { console: console_1$4 } = globals;
    const file$c = "src/components/UserEvents/CreateUserEventModal.svelte";

    // (232:4) {#if $ShowCreateUserEventStore.shown}
    function create_if_block$7(ctx) {
    	let div24;
    	let style;
    	let t1;
    	let div23;
    	let div22;
    	let div0;
    	let h5;
    	let t3;
    	let button0;
    	let span0;
    	let t5;
    	let div18;
    	let div17;
    	let div3;
    	let label0;
    	let t7;
    	let div2;
    	let input0;
    	let t8;
    	let input1;
    	let t9;
    	let div1;
    	let t11;
    	let div6;
    	let label1;
    	let t13;
    	let div5;
    	let input2;
    	let t14;
    	let input3;
    	let t15;
    	let div4;
    	let t17;
    	let div9;
    	let div7;
    	let label2;
    	let t19;
    	let input4;
    	let t20;
    	let div8;
    	let label3;
    	let t22;
    	let input5;
    	let t23;
    	let div10;
    	let label4;
    	let t25;
    	let textarea;
    	let t26;
    	let div13;
    	let label5;
    	let t28;
    	let div12;
    	let input6;
    	let t29;
    	let button1;
    	let i;
    	let t30;
    	let div11;
    	let button2;
    	let t32;
    	let div14;
    	let label6;
    	let t34;
    	let select0;
    	let option0;
    	let t35;
    	let option1;
    	let t36;
    	let t37;
    	let div15;
    	let label7;
    	let t39;
    	let select1;
    	let option2;
    	let option3;
    	let t42;
    	let div16;
    	let label8;
    	let t44;
    	let input7;
    	let t45;
    	let div21;
    	let div20;
    	let div19;
    	let t46;
    	let button3;
    	let span1;
    	let span2;
    	let div24_transition;
    	let current;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div24 = element("div");
    			style = element("style");
    			style.textContent = "label {\n                    text-align: start;\n                }";
    			t1 = space();
    			div23 = element("div");
    			div22 = element("div");
    			div0 = element("div");
    			h5 = element("h5");
    			h5.textContent = "Créer un évènement";
    			t3 = space();
    			button0 = element("button");
    			span0 = element("span");
    			span0.textContent = "×";
    			t5 = space();
    			div18 = element("div");
    			div17 = element("div");
    			div3 = element("div");
    			label0 = element("label");
    			label0.textContent = "Début";
    			t7 = space();
    			div2 = element("div");
    			input0 = element("input");
    			t8 = space();
    			input1 = element("input");
    			t9 = space();
    			div1 = element("div");
    			div1.textContent = "La date de début ne peut pas être vide et doit être inférieur à la date de fin.";
    			t11 = space();
    			div6 = element("div");
    			label1 = element("label");
    			label1.textContent = "Fin";
    			t13 = space();
    			div5 = element("div");
    			input2 = element("input");
    			t14 = space();
    			input3 = element("input");
    			t15 = space();
    			div4 = element("div");
    			div4.textContent = "La date de fin ne peut pas être vide et doit être supérieur à la date de début.";
    			t17 = space();
    			div9 = element("div");
    			div7 = element("div");
    			label2 = element("label");
    			label2.textContent = "Label";
    			t19 = space();
    			input4 = element("input");
    			t20 = space();
    			div8 = element("div");
    			label3 = element("label");
    			label3.textContent = "Couleur";
    			t22 = space();
    			input5 = element("input");
    			t23 = space();
    			div10 = element("div");
    			label4 = element("label");
    			label4.textContent = "Description";
    			t25 = space();
    			textarea = element("textarea");
    			t26 = space();
    			div13 = element("div");
    			label5 = element("label");
    			label5.textContent = "Catégorie";
    			t28 = space();
    			div12 = element("div");
    			input6 = element("input");
    			t29 = space();
    			button1 = element("button");
    			i = element("i");
    			t30 = space();
    			div11 = element("div");
    			button2 = element("button");
    			button2.textContent = "Vacances";
    			t32 = space();
    			div14 = element("div");
    			label6 = element("label");
    			label6.textContent = "Visibilité";
    			t34 = space();
    			select0 = element("select");
    			option0 = element("option");
    			t35 = text("Protégé");
    			option1 = element("option");
    			t36 = text("Privé");
    			t37 = space();
    			div15 = element("div");
    			label7 = element("label");
    			label7.textContent = "Disponibilité";
    			t39 = space();
    			select1 = element("select");
    			option2 = element("option");
    			option2.textContent = "Occupé";
    			option3 = element("option");
    			option3.textContent = "Disponible";
    			t42 = space();
    			div16 = element("div");
    			label8 = element("label");
    			label8.textContent = "Localisation";
    			t44 = space();
    			input7 = element("input");
    			t45 = space();
    			div21 = element("div");
    			div20 = element("div");
    			div19 = element("div");
    			t46 = space();
    			button3 = element("button");
    			span1 = element("span");
    			span2 = element("span");
    			span2.textContent = "Enregistrer";
    			add_location(style, file$c, 236, 12, 7989);
    			attr_dev(h5, "id", "create-user-event-modal-title");
    			attr_dev(h5, "class", "modal-title");
    			add_location(h5, file$c, 245, 24, 8285);
    			attr_dev(span0, "aria-hidden", "true");
    			add_location(span0, file$c, 250, 28, 8668);
    			attr_dev(button0, "id", "create-user-event-close");
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "close");
    			attr_dev(button0, "data-dismiss", "modal");
    			attr_dev(button0, "aria-label", "Close");
    			add_location(button0, file$c, 246, 24, 8392);
    			attr_dev(div0, "class", "modal-header");
    			add_location(div0, file$c, 244, 20, 8234);
    			attr_dev(label0, "for", "user-event-start-date-field");
    			add_location(label0, file$c, 256, 32, 8960);
    			attr_dev(input0, "class", "form-control datetime svelte-4i0taq");
    			attr_dev(input0, "id", "user-event-start-date");
    			attr_dev(input0, "name", "user-event-start-date");
    			attr_dev(input0, "type", "date");
    			input0.required = true;
    			add_location(input0, file$c, 258, 36, 9141);
    			attr_dev(input1, "class", "form-control datetime svelte-4i0taq");
    			attr_dev(input1, "id", "user-event-start-time");
    			attr_dev(input1, "name", "user-event-start-time");
    			attr_dev(input1, "type", "time");
    			input1.required = true;
    			add_location(input1, file$c, 264, 36, 9556);
    			attr_dev(div1, "class", "invalid-feedback");
    			add_location(div1, file$c, 270, 36, 9971);
    			attr_dev(div2, "id", "user-event-start-date-field");
    			attr_dev(div2, "class", "date-field svelte-4i0taq");
    			add_location(div2, file$c, 257, 32, 9047);
    			attr_dev(div3, "class", "mb-3 svelte-4i0taq");
    			add_location(div3, file$c, 255, 28, 8909);
    			attr_dev(label1, "for", "user-event-end-date-field");
    			add_location(label1, file$c, 276, 32, 10318);
    			attr_dev(input2, "class", "form-control datetime svelte-4i0taq");
    			attr_dev(input2, "id", "user-event-end-date");
    			attr_dev(input2, "name", "user-event-end-date");
    			attr_dev(input2, "type", "date");
    			input2.required = true;
    			add_location(input2, file$c, 278, 36, 10493);
    			attr_dev(input3, "class", "form-control datetime svelte-4i0taq");
    			attr_dev(input3, "id", "user-event-end-time");
    			attr_dev(input3, "name", "user-event-end-time");
    			attr_dev(input3, "type", "time");
    			input3.required = true;
    			add_location(input3, file$c, 285, 36, 10944);
    			attr_dev(div4, "class", "invalid-feedback");
    			add_location(div4, file$c, 292, 36, 11395);
    			attr_dev(div5, "id", "user-event-end-date-field");
    			attr_dev(div5, "class", "date-field svelte-4i0taq");
    			add_location(div5, file$c, 277, 32, 10401);
    			attr_dev(div6, "class", "mb-3 svelte-4i0taq");
    			add_location(div6, file$c, 275, 28, 10267);
    			attr_dev(label2, "for", "user-event-label");
    			add_location(label2, file$c, 299, 36, 11809);
    			attr_dev(input4, "class", "form-control");
    			attr_dev(input4, "id", "user-event-label");
    			attr_dev(input4, "name", "user-event-label");
    			attr_dev(input4, "type", "text");
    			add_location(input4, file$c, 300, 36, 11889);
    			attr_dev(div7, "class", "field svelte-4i0taq");
    			add_location(div7, file$c, 298, 32, 11753);
    			attr_dev(label3, "for", "user-event-color");
    			add_location(label3, file$c, 308, 36, 12345);
    			attr_dev(input5, "class", "form-control input-color svelte-4i0taq");
    			attr_dev(input5, "id", "user-event-color");
    			attr_dev(input5, "name", "user-event-color");
    			attr_dev(input5, "type", "color");
    			add_location(input5, file$c, 309, 36, 12427);
    			attr_dev(div8, "class", "field svelte-4i0taq");
    			add_location(div8, file$c, 307, 32, 12289);
    			attr_dev(div9, "class", "mb-3 field-row svelte-4i0taq");
    			add_location(div9, file$c, 297, 28, 11691);
    			attr_dev(label4, "for", "user-event-description");
    			add_location(label4, file$c, 318, 32, 12923);
    			attr_dev(textarea, "class", "form-control");
    			attr_dev(textarea, "id", "user-event-description");
    			attr_dev(textarea, "name", "user-event-label");
    			attr_dev(textarea, "type", "text");
    			add_location(textarea, file$c, 319, 32, 13011);
    			attr_dev(div10, "class", "mb-3 svelte-4i0taq");
    			add_location(div10, file$c, 317, 28, 12872);
    			attr_dev(label5, "for", "user-event-category");
    			add_location(label5, file$c, 328, 32, 13490);
    			attr_dev(input6, "class", "form-control category svelte-4i0taq");
    			attr_dev(input6, "id", "user-event-category");
    			attr_dev(input6, "name", "user-event-category");
    			attr_dev(input6, "type", "text");
    			add_location(input6, file$c, 330, 36, 13633);
    			attr_dev(i, "class", "fas fa-chevron-down");
    			add_location(i, file$c, 344, 37, 14560);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn btn-secondary svelte-4i0taq");
    			attr_dev(button1, "id", "show-predefined-categories");
    			add_location(button1, file$c, 338, 36, 14167);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "data-category", "Vacances");
    			attr_dev(button2, "class", "dropdown-item");
    			add_location(button2, file$c, 346, 40, 14725);
    			attr_dev(div11, "id", "categories");
    			attr_dev(div11, "class", "dropdown-menu svelte-4i0taq");
    			add_location(div11, file$c, 345, 36, 14641);
    			attr_dev(div12, "class", "field-row svelte-4i0taq");
    			add_location(div12, file$c, 329, 32, 13573);
    			attr_dev(div13, "class", "mb-3 svelte-4i0taq");
    			add_location(div13, file$c, 327, 28, 13439);
    			attr_dev(label6, "for", "user-event-visibility");
    			add_location(label6, file$c, 354, 32, 15189);
    			option0.__value = "protected";
    			option0.value = option0.__value;
    			attr_dev(option0, "title", /*visibilitiesDescription*/ ctx[6].protected);
    			add_location(option0, file$c, 365, 36, 16007);
    			option1.__value = "private";
    			option1.value = option1.__value;
    			attr_dev(option1, "title", /*visibilitiesDescription*/ ctx[6].private);
    			add_location(option1, file$c, 366, 36, 16128);
    			attr_dev(select0, "class", "form-select");
    			attr_dev(select0, "id", "user-event-visibility");
    			attr_dev(select0, "name", "user-event-visibility");
    			attr_dev(select0, "title", /*visibilitiesDescription*/ ctx[6].protected);
    			if (/*userEvent*/ ctx[4].visibility === void 0) add_render_callback(() => /*select0_change_handler*/ ctx[22].call(select0));
    			add_location(select0, file$c, 355, 32, 15275);
    			attr_dev(div14, "class", "mb-3 svelte-4i0taq");
    			add_location(div14, file$c, 353, 28, 15138);
    			attr_dev(label7, "for", "user-event-availability");
    			add_location(label7, file$c, 370, 32, 16363);
    			option2.__value = "busy";
    			option2.value = option2.__value;
    			add_location(option2, file$c, 376, 36, 16794);
    			option3.__value = "available";
    			option3.value = option3.__value;
    			add_location(option3, file$c, 377, 36, 16868);
    			attr_dev(select1, "class", "form-select");
    			attr_dev(select1, "id", "user-event-availability");
    			attr_dev(select1, "name", "user-event-availability");
    			attr_dev(select1, "title", "Occupé");
    			if (/*userEvent*/ ctx[4].ownerAvailabilityStatus === void 0) add_render_callback(() => /*select1_change_handler*/ ctx[24].call(select1));
    			add_location(select1, file$c, 371, 32, 16454);
    			attr_dev(div15, "class", "mb-3 svelte-4i0taq");
    			add_location(div15, file$c, 369, 28, 16312);
    			attr_dev(label8, "for", "user-event-location");
    			add_location(label8, file$c, 381, 32, 17070);
    			attr_dev(input7, "class", "form-select");
    			attr_dev(input7, "id", "user-event-location");
    			attr_dev(input7, "name", "user-event-location");
    			attr_dev(input7, "title", "Localisation");
    			add_location(input7, file$c, 382, 32, 17156);
    			attr_dev(div16, "class", "mb-3 svelte-4i0taq");
    			add_location(div16, file$c, 380, 28, 17019);
    			attr_dev(div17, "id", "create-user-event-form");
    			attr_dev(div17, "class", " svelte-4i0taq");
    			add_location(div17, file$c, 254, 24, 8838);
    			attr_dev(div18, "class", "modal-body svelte-4i0taq");
    			add_location(div18, file$c, 253, 20, 8789);
    			attr_dev(div19, "id", "error-creating-user-events-content");
    			add_location(div19, file$c, 393, 28, 17770);
    			attr_dev(div20, "id", "error-creating-user-events");
    			attr_dev(div20, "class", "alert alert-danger fade");
    			add_location(div20, file$c, 392, 24, 17672);
    			attr_dev(span1, "id", "create-user-events-loading");
    			attr_dev(span1, "class", "spinner-border svelte-4i0taq");
    			add_location(span1, file$c, 396, 28, 18015);
    			attr_dev(span2, "id", "do-create-user-events-text");
    			add_location(span2, file$c, 396, 96, 18083);
    			attr_dev(button3, "id", "do-create-user-events");
    			attr_dev(button3, "type", "button");
    			attr_dev(button3, "class", "btn action btn-danger  svelte-4i0taq");
    			add_location(button3, file$c, 395, 24, 17877);
    			attr_dev(div21, "class", "modal-footer modal-footer-upload-footer");
    			add_location(div21, file$c, 391, 20, 17594);
    			attr_dev(div22, "class", "modal-content");
    			add_location(div22, file$c, 243, 16, 8186);
    			attr_dev(div23, "class", "modal-dialog modal-dialog-centered modal-lg");
    			add_location(div23, file$c, 242, 12, 8112);
    			attr_dev(div24, "id", "create-userevent-modal");
    			attr_dev(div24, "class", "modal fade svelte-4i0taq");
    			attr_dev(div24, "data-keyboard", "false");
    			toggle_class(div24, "show", /*$ShowCreateUserEventStore*/ ctx[5].shown);
    			add_location(div24, file$c, 232, 8, 7771);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div24, anchor);
    			append_dev(div24, style);
    			append_dev(div24, t1);
    			append_dev(div24, div23);
    			append_dev(div23, div22);
    			append_dev(div22, div0);
    			append_dev(div0, h5);
    			append_dev(div0, t3);
    			append_dev(div0, button0);
    			append_dev(button0, span0);
    			append_dev(div22, t5);
    			append_dev(div22, div18);
    			append_dev(div18, div17);
    			append_dev(div17, div3);
    			append_dev(div3, label0);
    			append_dev(div3, t7);
    			append_dev(div3, div2);
    			append_dev(div2, input0);
    			set_input_value(input0, /*startDate*/ ctx[0]);
    			append_dev(div2, t8);
    			append_dev(div2, input1);
    			set_input_value(input1, /*startTime*/ ctx[1]);
    			append_dev(div2, t9);
    			append_dev(div2, div1);
    			append_dev(div17, t11);
    			append_dev(div17, div6);
    			append_dev(div6, label1);
    			append_dev(div6, t13);
    			append_dev(div6, div5);
    			append_dev(div5, input2);
    			set_input_value(input2, /*endDate*/ ctx[2]);
    			append_dev(div5, t14);
    			append_dev(div5, input3);
    			set_input_value(input3, /*endTime*/ ctx[3]);
    			append_dev(div5, t15);
    			append_dev(div5, div4);
    			append_dev(div17, t17);
    			append_dev(div17, div9);
    			append_dev(div9, div7);
    			append_dev(div7, label2);
    			append_dev(div7, t19);
    			append_dev(div7, input4);
    			set_input_value(input4, /*userEvent*/ ctx[4].label);
    			append_dev(div9, t20);
    			append_dev(div9, div8);
    			append_dev(div8, label3);
    			append_dev(div8, t22);
    			append_dev(div8, input5);
    			set_input_value(input5, /*userEvent*/ ctx[4].color);
    			append_dev(div17, t23);
    			append_dev(div17, div10);
    			append_dev(div10, label4);
    			append_dev(div10, t25);
    			append_dev(div10, textarea);
    			set_input_value(textarea, /*userEvent*/ ctx[4].description);
    			append_dev(div17, t26);
    			append_dev(div17, div13);
    			append_dev(div13, label5);
    			append_dev(div13, t28);
    			append_dev(div13, div12);
    			append_dev(div12, input6);
    			set_input_value(input6, /*userEvent*/ ctx[4].category);
    			append_dev(div12, t29);
    			append_dev(div12, button1);
    			append_dev(button1, i);
    			append_dev(div12, t30);
    			append_dev(div12, div11);
    			append_dev(div11, button2);
    			append_dev(div17, t32);
    			append_dev(div17, div14);
    			append_dev(div14, label6);
    			append_dev(div14, t34);
    			append_dev(div14, select0);
    			append_dev(select0, option0);
    			append_dev(option0, t35);
    			append_dev(select0, option1);
    			append_dev(option1, t36);
    			select_option(select0, /*userEvent*/ ctx[4].visibility);
    			append_dev(div17, t37);
    			append_dev(div17, div15);
    			append_dev(div15, label7);
    			append_dev(div15, t39);
    			append_dev(div15, select1);
    			append_dev(select1, option2);
    			append_dev(select1, option3);
    			select_option(select1, /*userEvent*/ ctx[4].ownerAvailabilityStatus);
    			append_dev(div17, t42);
    			append_dev(div17, div16);
    			append_dev(div16, label8);
    			append_dev(div16, t44);
    			append_dev(div16, input7);
    			set_input_value(input7, /*userEvent*/ ctx[4].location);
    			append_dev(div22, t45);
    			append_dev(div22, div21);
    			append_dev(div21, div20);
    			append_dev(div20, div19);
    			append_dev(div21, t46);
    			append_dev(div21, button3);
    			append_dev(button3, span1);
    			append_dev(button3, span2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[11], false, false, false),
    					listen_dev(input0, "blur", /*onStartDateChange*/ ctx[7], false, false, false),
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[12]),
    					listen_dev(input1, "blur", /*onStartDateChange*/ ctx[7], false, false, false),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[13]),
    					listen_dev(input2, "blur", /*onEndDateChange*/ ctx[8], false, false, false),
    					listen_dev(input2, "input", /*input2_input_handler*/ ctx[14]),
    					listen_dev(input3, "blur", /*onEndDateChange*/ ctx[8], false, false, false),
    					listen_dev(input3, "input", /*input3_input_handler*/ ctx[15]),
    					listen_dev(input4, "input", /*input4_input_handler*/ ctx[16]),
    					listen_dev(input5, "input", /*input5_input_handler*/ ctx[17]),
    					listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[18]),
    					listen_dev(input6, "blur", /*blur_handler*/ ctx[19], false, false, false),
    					listen_dev(input6, "input", /*input6_input_handler*/ ctx[20]),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[21], false, false, false),
    					listen_dev(button2, "click", /*onPredefinedCategoryClick*/ ctx[10], false, false, false),
    					listen_dev(select0, "change", /*select0_change_handler*/ ctx[22]),
    					listen_dev(select0, "blur", /*blur_handler_1*/ ctx[23], false, false, false),
    					listen_dev(select1, "change", /*select1_change_handler*/ ctx[24]),
    					listen_dev(input7, "input", /*input7_input_handler*/ ctx[25]),
    					listen_dev(button3, "click", /*doCreateUserEvent*/ ctx[9], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*startDate*/ 1) {
    				set_input_value(input0, /*startDate*/ ctx[0]);
    			}

    			if (dirty[0] & /*startTime*/ 2) {
    				set_input_value(input1, /*startTime*/ ctx[1]);
    			}

    			if (dirty[0] & /*endDate*/ 4) {
    				set_input_value(input2, /*endDate*/ ctx[2]);
    			}

    			if (dirty[0] & /*endTime*/ 8) {
    				set_input_value(input3, /*endTime*/ ctx[3]);
    			}

    			if (dirty[0] & /*userEvent*/ 16 && input4.value !== /*userEvent*/ ctx[4].label) {
    				set_input_value(input4, /*userEvent*/ ctx[4].label);
    			}

    			if (dirty[0] & /*userEvent*/ 16) {
    				set_input_value(input5, /*userEvent*/ ctx[4].color);
    			}

    			if (dirty[0] & /*userEvent*/ 16) {
    				set_input_value(textarea, /*userEvent*/ ctx[4].description);
    			}

    			if (dirty[0] & /*userEvent*/ 16 && input6.value !== /*userEvent*/ ctx[4].category) {
    				set_input_value(input6, /*userEvent*/ ctx[4].category);
    			}

    			if (dirty[0] & /*userEvent*/ 16) {
    				select_option(select0, /*userEvent*/ ctx[4].visibility);
    			}

    			if (dirty[0] & /*userEvent*/ 16) {
    				select_option(select1, /*userEvent*/ ctx[4].ownerAvailabilityStatus);
    			}

    			if (dirty[0] & /*userEvent*/ 16 && input7.value !== /*userEvent*/ ctx[4].location) {
    				set_input_value(input7, /*userEvent*/ ctx[4].location);
    			}

    			if (dirty[0] & /*$ShowCreateUserEventStore*/ 32) {
    				toggle_class(div24, "show", /*$ShowCreateUserEventStore*/ ctx[5].shown);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!div24_transition) div24_transition = create_bidirectional_transition(div24, fly, { y: -250, duration: 500 }, true);
    				div24_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!div24_transition) div24_transition = create_bidirectional_transition(div24, fly, { y: -250, duration: 500 }, false);
    			div24_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div24);
    			if (detaching && div24_transition) div24_transition.end();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(232:4) {#if $ShowCreateUserEventStore.shown}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$c(ctx) {
    	let div;
    	let current;
    	let if_block = /*$ShowCreateUserEventStore*/ ctx[5].shown && create_if_block$7(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "id", "create-user-event-background");
    			attr_dev(div, "class", "modal-background svelte-4i0taq");
    			toggle_class(div, "show", /*$ShowCreateUserEventStore*/ ctx[5].shown);
    			add_location(div, file$c, 230, 0, 7611);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*$ShowCreateUserEventStore*/ ctx[5].shown) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*$ShowCreateUserEventStore*/ 32) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$7(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (dirty[0] & /*$ShowCreateUserEventStore*/ 32) {
    				toggle_class(div, "show", /*$ShowCreateUserEventStore*/ ctx[5].shown);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function showOrHidePredefinedCategories$1(forceHide = false) {
    	const menu = document.getElementById("categories");
    	if (menu.classList.contains("show")) menu.classList.remove("show"); else menu.classList.add("show");
    	if (forceHide) menu.classList.remove("show");
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let $ShowCreateUserEventStore;
    	validate_store(ShowCreateUserEventStore, "ShowCreateUserEventStore");
    	component_subscribe($$self, ShowCreateUserEventStore, $$value => $$invalidate(5, $ShowCreateUserEventStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("CreateUserEventModal", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	let startDate;
    	let startTime;
    	let endDate;
    	let endTime;

    	let userEvent = {
    		startDate: $ShowCreateUserEventStore.startDate,
    		endDate: $ShowCreateUserEventStore.endDate,
    		category: "",
    		ownerAvailabilityStatus: dist.UserAvailabilityStatus.busy,
    		visibility: dist.UserEventVisibility.protected,
    		label: "",
    		description: "",
    		location: "",
    		color: "#243dff",
    		attachments: []
    	};

    	//@ts-ignore
    	const unsubscribe = ShowCreateUserEventStore.subscribe(v => {
    		initStartAndEnd();
    	});

    	const visibilitiesDescription = {
    		protected: "Un évènement protégé n'est accessible et visible que par des utilisateurs identifiés",
    		private: "Un évènement privé ne laisse voir aux autres utilisateurs que la date de début, de fin et la disponibilité de son créateur"
    	};

    	function validateUserEvent() {
    		return __awaiter(this, void 0, void 0, function* () {
    			if (getEndDate() < getStartDate()) {
    				return false;
    			}
    		});
    	}

    	function getEndDate() {
    		return Helpers.fromStringToDate(endDate, endTime);
    	}

    	function getStartDate() {
    		return Helpers.fromStringToDate(startDate, startTime);
    	}

    	function onStartDateChange() {
    		if (getEndDate() < getStartDate()) {
    			ShowCreateUserEventStore.update(s => {
    				const d = getStartDate();
    				s.startDate = new Date(d.getFullYear(), d.getMonth(), d.getDate(), 0, 0);
    				s.endDate = new Date(s.startDate.getFullYear(), s.startDate.getMonth(), s.startDate.getDate(), 23, 59);
    				return s;
    			});
    		}
    	}

    	function onEndDateChange() {
    		if (getEndDate() < getStartDate()) {
    			ShowCreateUserEventStore.update(s => {
    				const d = getEndDate();
    				s.endDate = new Date(d.getFullYear(), d.getMonth(), d.getDate(), 23, 59);
    				s.startDate = new Date(s.endDate.getFullYear(), s.endDate.getMonth(), s.endDate.getDate(), 0, 0);
    				return s;
    			});
    		}
    	}

    	function doCreateUserEvent() {
    		return __awaiter(this, void 0, void 0, function* () {
    			const doCreateEventButton = document.getElementById("do-create-user-events");
    			const loading = document.getElementById("create-user-events-loading");
    			let closeAfterAction = true;

    			try {
    				const backendService = yield dist$1.getBackendClient();
    				loading.classList.add("show");
    				doCreateEventButton.setAttribute("disabled", "disabled");
    				$$invalidate(4, userEvent.startDate = getStartDate(), userEvent);
    				$$invalidate(4, userEvent.endDate = getEndDate(), userEvent);
    				yield backendService.userService.createUserEvent(userEvent);
    			} catch(error) {
    				document.getElementById("error-creating-user-events-content").innerText = error.message;
    				document.getElementById("error-creating-user-events").classList.add("show");
    				closeAfterAction = false;
    				console.error(error);
    			} finally {
    				if (closeAfterAction) {
    					window.setTimeout(
    						() => {
    							doCreateEventButton.removeAttribute("disabled");
    							loading.classList.remove("show");
    							$$invalidate(4, userEvent.label = "", userEvent);
    							$$invalidate(4, userEvent.description = "", userEvent);
    							$$invalidate(4, userEvent.color = "#243dff", userEvent);
    							$$invalidate(4, userEvent.ownerAvailabilityStatus = dist.UserAvailabilityStatus.busy, userEvent);
    							$$invalidate(4, userEvent.visibility = dist.UserEventVisibility.private, userEvent);
    							$$invalidate(4, userEvent.category = "", userEvent);
    							$$invalidate(4, userEvent.location = "", userEvent);
    							ShowCreateUserEventStore.set(new ShowModalUserEvent());
    						},
    						2000
    					);
    				}
    			}
    		});
    	}

    	function initStartAndEnd() {
    		$$invalidate(0, startDate = Helpers.fromDateToString($ShowCreateUserEventStore.startDate));
    		$$invalidate(1, startTime = Helpers.fromTimeToString($ShowCreateUserEventStore.startDate));
    		$$invalidate(2, endDate = Helpers.fromDateToString($ShowCreateUserEventStore.endDate));
    		$$invalidate(3, endTime = Helpers.fromTimeToString($ShowCreateUserEventStore.endDate));
    	}

    	function onPredefinedCategoryClick(event) {
    		showOrHidePredefinedCategories$1();
    		const categoryInput = document.getElementById("user-event-category");
    		categoryInput.value = event.target.getAttribute("data-category");
    		$$invalidate(4, userEvent.category = categoryInput.value, userEvent);
    		const e = document.createEvent("HTMLEvents");
    		e.initEvent("blur", true, true);
    		categoryInput.dispatchEvent(e);
    	}

    	onMount(() => {
    		initStartAndEnd();
    	});

    	onDestroy(unsubscribe);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$4.warn(`<CreateUserEventModal> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		ShowCreateUserEventStore.set(new ShowModalUserEvent());
    	};

    	function input0_input_handler() {
    		startDate = this.value;
    		$$invalidate(0, startDate);
    	}

    	function input1_input_handler() {
    		startTime = this.value;
    		$$invalidate(1, startTime);
    	}

    	function input2_input_handler() {
    		endDate = this.value;
    		$$invalidate(2, endDate);
    	}

    	function input3_input_handler() {
    		endTime = this.value;
    		$$invalidate(3, endTime);
    	}

    	function input4_input_handler() {
    		userEvent.label = this.value;
    		$$invalidate(4, userEvent);
    	}

    	function input5_input_handler() {
    		userEvent.color = this.value;
    		$$invalidate(4, userEvent);
    	}

    	function textarea_input_handler() {
    		userEvent.description = this.value;
    		$$invalidate(4, userEvent);
    	}

    	const blur_handler = () => {
    		showOrHidePredefinedCategories$1(true);
    	};

    	function input6_input_handler() {
    		userEvent.category = this.value;
    		$$invalidate(4, userEvent);
    	}

    	const click_handler_1 = () => {
    		showOrHidePredefinedCategories$1();
    	};

    	function select0_change_handler() {
    		userEvent.visibility = select_value(this);
    		$$invalidate(4, userEvent);
    	}

    	const blur_handler_1 = () => {
    		const visibilitySelected = document.getElementById("user-event-visibility");
    		visibilitySelected.title = visibilitiesDescription[visibilitySelected.value];
    	};

    	function select1_change_handler() {
    		userEvent.ownerAvailabilityStatus = select_value(this);
    		$$invalidate(4, userEvent);
    	}

    	function input7_input_handler() {
    		userEvent.location = this.value;
    		$$invalidate(4, userEvent);
    	}

    	$$self.$capture_state = () => ({
    		__awaiter,
    		ShowCreateUserEventStore,
    		ShowModalUserEvent,
    		fly,
    		onMount,
    		onDestroy,
    		afterUpdate,
    		UserAvailabilityStatus: dist.UserAvailabilityStatus,
    		UserEventVisibility: dist.UserEventVisibility,
    		getBackendClient: dist$1.getBackendClient,
    		Helpers,
    		startDate,
    		startTime,
    		endDate,
    		endTime,
    		userEvent,
    		unsubscribe,
    		visibilitiesDescription,
    		validateUserEvent,
    		getEndDate,
    		getStartDate,
    		onStartDateChange,
    		onEndDateChange,
    		doCreateUserEvent,
    		initStartAndEnd,
    		onPredefinedCategoryClick,
    		showOrHidePredefinedCategories: showOrHidePredefinedCategories$1,
    		$ShowCreateUserEventStore
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("startDate" in $$props) $$invalidate(0, startDate = $$props.startDate);
    		if ("startTime" in $$props) $$invalidate(1, startTime = $$props.startTime);
    		if ("endDate" in $$props) $$invalidate(2, endDate = $$props.endDate);
    		if ("endTime" in $$props) $$invalidate(3, endTime = $$props.endTime);
    		if ("userEvent" in $$props) $$invalidate(4, userEvent = $$props.userEvent);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		startDate,
    		startTime,
    		endDate,
    		endTime,
    		userEvent,
    		$ShowCreateUserEventStore,
    		visibilitiesDescription,
    		onStartDateChange,
    		onEndDateChange,
    		doCreateUserEvent,
    		onPredefinedCategoryClick,
    		click_handler,
    		input0_input_handler,
    		input1_input_handler,
    		input2_input_handler,
    		input3_input_handler,
    		input4_input_handler,
    		input5_input_handler,
    		textarea_input_handler,
    		blur_handler,
    		input6_input_handler,
    		click_handler_1,
    		select0_change_handler,
    		blur_handler_1,
    		select1_change_handler,
    		input7_input_handler
    	];
    }

    class CreateUserEventModal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$c, create_fragment$c, safe_not_equal, {}, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CreateUserEventModal",
    			options,
    			id: create_fragment$c.name
    		});
    	}
    }

    /* src/components/UserEvents/UpdateUserEventModal.svelte generated by Svelte v3.38.2 */

    const { console: console_1$3 } = globals;
    const file$b = "src/components/UserEvents/UpdateUserEventModal.svelte";

    // (260:4) {#if $ShowUpdateUserEventStore.shown}
    function create_if_block$6(ctx) {
    	let div24;
    	let style;
    	let t1;
    	let div23;
    	let div22;
    	let div0;
    	let h5;
    	let t3;
    	let button0;
    	let span0;
    	let t5;
    	let div18;
    	let div17;
    	let div3;
    	let label0;
    	let t7;
    	let div2;
    	let input0;
    	let t8;
    	let input1;
    	let t9;
    	let div1;
    	let t11;
    	let div6;
    	let label1;
    	let t13;
    	let div5;
    	let input2;
    	let t14;
    	let input3;
    	let t15;
    	let div4;
    	let t17;
    	let div9;
    	let div7;
    	let label2;
    	let t19;
    	let input4;
    	let t20;
    	let div8;
    	let label3;
    	let t22;
    	let input5;
    	let t23;
    	let div10;
    	let label4;
    	let t25;
    	let textarea;
    	let t26;
    	let div13;
    	let label5;
    	let t28;
    	let div12;
    	let input6;
    	let t29;
    	let button1;
    	let i;
    	let t30;
    	let div11;
    	let button2;
    	let t32;
    	let div14;
    	let label6;
    	let t34;
    	let select0;
    	let option0;
    	let t35;
    	let option1;
    	let t36;
    	let t37;
    	let div15;
    	let label7;
    	let t39;
    	let select1;
    	let option2;
    	let option3;
    	let t42;
    	let div16;
    	let label8;
    	let t44;
    	let input7;
    	let t45;
    	let div21;
    	let div20;
    	let div19;
    	let t46;
    	let button3;
    	let span1;
    	let t47;
    	let span2;
    	let t49;
    	let button4;
    	let span3;
    	let span4;
    	let div24_transition;
    	let current;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div24 = element("div");
    			style = element("style");
    			style.textContent = "label {\n                    text-align: start;\n                }";
    			t1 = space();
    			div23 = element("div");
    			div22 = element("div");
    			div0 = element("div");
    			h5 = element("h5");
    			h5.textContent = "Modifier l'évènement";
    			t3 = space();
    			button0 = element("button");
    			span0 = element("span");
    			span0.textContent = "×";
    			t5 = space();
    			div18 = element("div");
    			div17 = element("div");
    			div3 = element("div");
    			label0 = element("label");
    			label0.textContent = "Début";
    			t7 = space();
    			div2 = element("div");
    			input0 = element("input");
    			t8 = space();
    			input1 = element("input");
    			t9 = space();
    			div1 = element("div");
    			div1.textContent = "La date de début ne peut pas être vide et doit être inférieur à la date de fin.";
    			t11 = space();
    			div6 = element("div");
    			label1 = element("label");
    			label1.textContent = "Fin";
    			t13 = space();
    			div5 = element("div");
    			input2 = element("input");
    			t14 = space();
    			input3 = element("input");
    			t15 = space();
    			div4 = element("div");
    			div4.textContent = "La date de fin ne peut pas être vide et doit être supérieur à la date de début.";
    			t17 = space();
    			div9 = element("div");
    			div7 = element("div");
    			label2 = element("label");
    			label2.textContent = "Label";
    			t19 = space();
    			input4 = element("input");
    			t20 = space();
    			div8 = element("div");
    			label3 = element("label");
    			label3.textContent = "Couleur";
    			t22 = space();
    			input5 = element("input");
    			t23 = space();
    			div10 = element("div");
    			label4 = element("label");
    			label4.textContent = "Description";
    			t25 = space();
    			textarea = element("textarea");
    			t26 = space();
    			div13 = element("div");
    			label5 = element("label");
    			label5.textContent = "Catégorie";
    			t28 = space();
    			div12 = element("div");
    			input6 = element("input");
    			t29 = space();
    			button1 = element("button");
    			i = element("i");
    			t30 = space();
    			div11 = element("div");
    			button2 = element("button");
    			button2.textContent = "Vacances";
    			t32 = space();
    			div14 = element("div");
    			label6 = element("label");
    			label6.textContent = "Visibilité";
    			t34 = space();
    			select0 = element("select");
    			option0 = element("option");
    			t35 = text("Protégé");
    			option1 = element("option");
    			t36 = text("Privé");
    			t37 = space();
    			div15 = element("div");
    			label7 = element("label");
    			label7.textContent = "Disponibilité";
    			t39 = space();
    			select1 = element("select");
    			option2 = element("option");
    			option2.textContent = "Occupé";
    			option3 = element("option");
    			option3.textContent = "Disponible";
    			t42 = space();
    			div16 = element("div");
    			label8 = element("label");
    			label8.textContent = "Localisation";
    			t44 = space();
    			input7 = element("input");
    			t45 = space();
    			div21 = element("div");
    			div20 = element("div");
    			div19 = element("div");
    			t46 = space();
    			button3 = element("button");
    			span1 = element("span");
    			t47 = space();
    			span2 = element("span");
    			span2.textContent = "Supprimer";
    			t49 = space();
    			button4 = element("button");
    			span3 = element("span");
    			span4 = element("span");
    			span4.textContent = "Enregistrer";
    			add_location(style, file$b, 264, 12, 9152);
    			attr_dev(h5, "id", "update-user-event-modal-title");
    			attr_dev(h5, "class", "modal-title");
    			add_location(h5, file$b, 273, 24, 9448);
    			attr_dev(span0, "aria-hidden", "true");
    			add_location(span0, file$b, 278, 28, 9833);
    			attr_dev(button0, "id", "update-user-event-close");
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "close");
    			attr_dev(button0, "data-dismiss", "modal");
    			attr_dev(button0, "aria-label", "Close");
    			add_location(button0, file$b, 274, 24, 9557);
    			attr_dev(div0, "class", "modal-header");
    			add_location(div0, file$b, 272, 20, 9397);
    			attr_dev(label0, "for", "user-event-start-date-field");
    			add_location(label0, file$b, 284, 32, 10125);
    			attr_dev(input0, "class", "form-control datetime svelte-17dfl1m");
    			attr_dev(input0, "id", "user-event-start-date");
    			attr_dev(input0, "name", "user-event-start-date");
    			attr_dev(input0, "type", "date");
    			input0.required = true;
    			add_location(input0, file$b, 286, 36, 10306);
    			attr_dev(input1, "class", "form-control datetime svelte-17dfl1m");
    			attr_dev(input1, "id", "user-event-start-time");
    			attr_dev(input1, "name", "user-event-start-time");
    			attr_dev(input1, "type", "time");
    			input1.required = true;
    			add_location(input1, file$b, 292, 36, 10721);
    			attr_dev(div1, "class", "invalid-feedback");
    			add_location(div1, file$b, 298, 36, 11136);
    			attr_dev(div2, "id", "user-event-start-date-field");
    			attr_dev(div2, "class", "date-field svelte-17dfl1m");
    			add_location(div2, file$b, 285, 32, 10212);
    			attr_dev(div3, "class", "mb-3 svelte-17dfl1m");
    			add_location(div3, file$b, 283, 28, 10074);
    			attr_dev(label1, "for", "user-event-end-date-field");
    			add_location(label1, file$b, 304, 32, 11483);
    			attr_dev(input2, "class", "form-control datetime svelte-17dfl1m");
    			attr_dev(input2, "id", "user-event-end-date");
    			attr_dev(input2, "name", "user-event-end-date");
    			attr_dev(input2, "type", "date");
    			input2.required = true;
    			add_location(input2, file$b, 306, 36, 11658);
    			attr_dev(input3, "class", "form-control datetime svelte-17dfl1m");
    			attr_dev(input3, "id", "user-event-end-time");
    			attr_dev(input3, "name", "user-event-end-time");
    			attr_dev(input3, "type", "time");
    			input3.required = true;
    			add_location(input3, file$b, 313, 36, 12109);
    			attr_dev(div4, "class", "invalid-feedback");
    			add_location(div4, file$b, 320, 36, 12560);
    			attr_dev(div5, "id", "user-event-end-date-field");
    			attr_dev(div5, "class", "date-field svelte-17dfl1m");
    			add_location(div5, file$b, 305, 32, 11566);
    			attr_dev(div6, "class", "mb-3 svelte-17dfl1m");
    			add_location(div6, file$b, 303, 28, 11432);
    			attr_dev(label2, "for", "user-event-label");
    			add_location(label2, file$b, 327, 36, 12974);
    			attr_dev(input4, "class", "form-control");
    			attr_dev(input4, "id", "user-event-label");
    			attr_dev(input4, "name", "user-event-label");
    			attr_dev(input4, "type", "text");
    			add_location(input4, file$b, 328, 36, 13054);
    			attr_dev(div7, "class", "field svelte-17dfl1m");
    			add_location(div7, file$b, 326, 32, 12918);
    			attr_dev(label3, "for", "user-event-color");
    			add_location(label3, file$b, 336, 36, 13510);
    			attr_dev(input5, "class", "form-control input-color svelte-17dfl1m");
    			attr_dev(input5, "id", "user-event-color");
    			attr_dev(input5, "name", "user-event-color");
    			attr_dev(input5, "type", "color");
    			add_location(input5, file$b, 337, 36, 13592);
    			attr_dev(div8, "class", "field svelte-17dfl1m");
    			add_location(div8, file$b, 335, 32, 13454);
    			attr_dev(div9, "class", "mb-3 field-row svelte-17dfl1m");
    			add_location(div9, file$b, 325, 28, 12856);
    			attr_dev(label4, "for", "user-event-description");
    			add_location(label4, file$b, 346, 32, 14088);
    			attr_dev(textarea, "class", "form-control");
    			attr_dev(textarea, "id", "user-event-description");
    			attr_dev(textarea, "name", "user-event-label");
    			attr_dev(textarea, "type", "text");
    			add_location(textarea, file$b, 347, 32, 14176);
    			attr_dev(div10, "class", "mb-3 svelte-17dfl1m");
    			add_location(div10, file$b, 345, 28, 14037);
    			attr_dev(label5, "for", "user-event-category");
    			add_location(label5, file$b, 356, 32, 14655);
    			attr_dev(input6, "class", "form-control category svelte-17dfl1m");
    			attr_dev(input6, "id", "user-event-category");
    			attr_dev(input6, "name", "user-event-category");
    			attr_dev(input6, "type", "text");
    			add_location(input6, file$b, 358, 36, 14798);
    			attr_dev(i, "class", "fas fa-chevron-down");
    			add_location(i, file$b, 372, 37, 15725);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn btn-secondary svelte-17dfl1m");
    			attr_dev(button1, "id", "show-predefined-categories");
    			add_location(button1, file$b, 366, 36, 15332);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "data-category", "Vacances");
    			attr_dev(button2, "class", "dropdown-item");
    			add_location(button2, file$b, 374, 40, 15890);
    			attr_dev(div11, "id", "categories");
    			attr_dev(div11, "class", "dropdown-menu svelte-17dfl1m");
    			add_location(div11, file$b, 373, 36, 15806);
    			attr_dev(div12, "class", "field-row svelte-17dfl1m");
    			add_location(div12, file$b, 357, 32, 14738);
    			attr_dev(div13, "class", "mb-3 svelte-17dfl1m");
    			add_location(div13, file$b, 355, 28, 14604);
    			attr_dev(label6, "for", "user-event-visibility");
    			add_location(label6, file$b, 382, 32, 16354);
    			option0.__value = "protected";
    			option0.value = option0.__value;
    			attr_dev(option0, "title", /*visibilitiesDescription*/ ctx[6].protected);
    			add_location(option0, file$b, 393, 36, 17172);
    			option1.__value = "private";
    			option1.value = option1.__value;
    			attr_dev(option1, "title", /*visibilitiesDescription*/ ctx[6].private);
    			add_location(option1, file$b, 394, 36, 17293);
    			attr_dev(select0, "class", "form-select");
    			attr_dev(select0, "id", "user-event-visibility");
    			attr_dev(select0, "name", "user-event-visibility");
    			attr_dev(select0, "title", /*visibilitiesDescription*/ ctx[6].protected);
    			if (/*userEvent*/ ctx[4].visibility === void 0) add_render_callback(() => /*select0_change_handler*/ ctx[23].call(select0));
    			add_location(select0, file$b, 383, 32, 16440);
    			attr_dev(div14, "class", "mb-3 svelte-17dfl1m");
    			add_location(div14, file$b, 381, 28, 16303);
    			attr_dev(label7, "for", "user-event-availability");
    			add_location(label7, file$b, 398, 32, 17528);
    			option2.__value = "busy";
    			option2.value = option2.__value;
    			add_location(option2, file$b, 404, 36, 17959);
    			option3.__value = "available";
    			option3.value = option3.__value;
    			add_location(option3, file$b, 405, 36, 18033);
    			attr_dev(select1, "class", "form-select");
    			attr_dev(select1, "id", "user-event-availability");
    			attr_dev(select1, "name", "user-event-availability");
    			attr_dev(select1, "title", "Occupé");
    			if (/*userEvent*/ ctx[4].ownerAvailabilityStatus === void 0) add_render_callback(() => /*select1_change_handler*/ ctx[25].call(select1));
    			add_location(select1, file$b, 399, 32, 17619);
    			attr_dev(div15, "class", "mb-3 svelte-17dfl1m");
    			add_location(div15, file$b, 397, 28, 17477);
    			attr_dev(label8, "for", "user-event-location");
    			add_location(label8, file$b, 409, 32, 18235);
    			attr_dev(input7, "class", "form-select");
    			attr_dev(input7, "id", "user-event-location");
    			attr_dev(input7, "name", "user-event-location");
    			attr_dev(input7, "title", "Localisation");
    			add_location(input7, file$b, 410, 32, 18321);
    			attr_dev(div16, "class", "mb-3 svelte-17dfl1m");
    			add_location(div16, file$b, 408, 28, 18184);
    			attr_dev(div17, "id", "update-user-event-form");
    			attr_dev(div17, "class", " svelte-17dfl1m");
    			add_location(div17, file$b, 282, 24, 10003);
    			attr_dev(div18, "class", "modal-body svelte-17dfl1m");
    			add_location(div18, file$b, 281, 20, 9954);
    			attr_dev(div19, "id", "error-updating-user-events-content");
    			attr_dev(div19, "class", "svelte-17dfl1m");
    			add_location(div19, file$b, 421, 28, 18935);
    			attr_dev(div20, "id", "error-updating-user-events");
    			attr_dev(div20, "class", "alert alert-danger fade svelte-17dfl1m");
    			add_location(div20, file$b, 420, 24, 18837);
    			attr_dev(span1, "id", "remove-user-events-loading");
    			attr_dev(span1, "class", "spinner-border svelte-17dfl1m");
    			add_location(span1, file$b, 424, 28, 19180);
    			attr_dev(span2, "id", "do-remove-user-events-text");
    			add_location(span2, file$b, 425, 28, 19277);
    			attr_dev(button3, "id", "do-remove-user-events");
    			attr_dev(button3, "type", "button");
    			attr_dev(button3, "class", "btn action btn-danger  svelte-17dfl1m");
    			add_location(button3, file$b, 423, 24, 19042);
    			attr_dev(span3, "id", "update-user-events-loading");
    			attr_dev(span3, "class", "spinner-border svelte-17dfl1m");
    			add_location(span3, file$b, 428, 28, 19531);
    			attr_dev(span4, "id", "do-update-user-events-text");
    			add_location(span4, file$b, 428, 96, 19599);
    			attr_dev(button4, "id", "do-update-user-events");
    			attr_dev(button4, "type", "button");
    			attr_dev(button4, "class", "btn action btn-secondary  svelte-17dfl1m");
    			add_location(button4, file$b, 427, 24, 19390);
    			attr_dev(div21, "class", "modal-footer modal-footer-upload-footer");
    			add_location(div21, file$b, 419, 20, 18759);
    			attr_dev(div22, "class", "modal-content");
    			add_location(div22, file$b, 271, 16, 9349);
    			attr_dev(div23, "class", "modal-dialog modal-dialog-centered modal-lg");
    			add_location(div23, file$b, 270, 12, 9275);
    			attr_dev(div24, "id", "update-userevent-modal");
    			attr_dev(div24, "class", "modal fade svelte-17dfl1m");
    			attr_dev(div24, "data-keyboard", "false");
    			toggle_class(div24, "show", /*$ShowUpdateUserEventStore*/ ctx[5].shown);
    			add_location(div24, file$b, 260, 8, 8934);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div24, anchor);
    			append_dev(div24, style);
    			append_dev(div24, t1);
    			append_dev(div24, div23);
    			append_dev(div23, div22);
    			append_dev(div22, div0);
    			append_dev(div0, h5);
    			append_dev(div0, t3);
    			append_dev(div0, button0);
    			append_dev(button0, span0);
    			append_dev(div22, t5);
    			append_dev(div22, div18);
    			append_dev(div18, div17);
    			append_dev(div17, div3);
    			append_dev(div3, label0);
    			append_dev(div3, t7);
    			append_dev(div3, div2);
    			append_dev(div2, input0);
    			set_input_value(input0, /*startDate*/ ctx[0]);
    			append_dev(div2, t8);
    			append_dev(div2, input1);
    			set_input_value(input1, /*startTime*/ ctx[1]);
    			append_dev(div2, t9);
    			append_dev(div2, div1);
    			append_dev(div17, t11);
    			append_dev(div17, div6);
    			append_dev(div6, label1);
    			append_dev(div6, t13);
    			append_dev(div6, div5);
    			append_dev(div5, input2);
    			set_input_value(input2, /*endDate*/ ctx[2]);
    			append_dev(div5, t14);
    			append_dev(div5, input3);
    			set_input_value(input3, /*endTime*/ ctx[3]);
    			append_dev(div5, t15);
    			append_dev(div5, div4);
    			append_dev(div17, t17);
    			append_dev(div17, div9);
    			append_dev(div9, div7);
    			append_dev(div7, label2);
    			append_dev(div7, t19);
    			append_dev(div7, input4);
    			set_input_value(input4, /*userEvent*/ ctx[4].label);
    			append_dev(div9, t20);
    			append_dev(div9, div8);
    			append_dev(div8, label3);
    			append_dev(div8, t22);
    			append_dev(div8, input5);
    			set_input_value(input5, /*userEvent*/ ctx[4].color);
    			append_dev(div17, t23);
    			append_dev(div17, div10);
    			append_dev(div10, label4);
    			append_dev(div10, t25);
    			append_dev(div10, textarea);
    			set_input_value(textarea, /*userEvent*/ ctx[4].description);
    			append_dev(div17, t26);
    			append_dev(div17, div13);
    			append_dev(div13, label5);
    			append_dev(div13, t28);
    			append_dev(div13, div12);
    			append_dev(div12, input6);
    			set_input_value(input6, /*userEvent*/ ctx[4].category);
    			append_dev(div12, t29);
    			append_dev(div12, button1);
    			append_dev(button1, i);
    			append_dev(div12, t30);
    			append_dev(div12, div11);
    			append_dev(div11, button2);
    			append_dev(div17, t32);
    			append_dev(div17, div14);
    			append_dev(div14, label6);
    			append_dev(div14, t34);
    			append_dev(div14, select0);
    			append_dev(select0, option0);
    			append_dev(option0, t35);
    			append_dev(select0, option1);
    			append_dev(option1, t36);
    			select_option(select0, /*userEvent*/ ctx[4].visibility);
    			append_dev(div17, t37);
    			append_dev(div17, div15);
    			append_dev(div15, label7);
    			append_dev(div15, t39);
    			append_dev(div15, select1);
    			append_dev(select1, option2);
    			append_dev(select1, option3);
    			select_option(select1, /*userEvent*/ ctx[4].ownerAvailabilityStatus);
    			append_dev(div17, t42);
    			append_dev(div17, div16);
    			append_dev(div16, label8);
    			append_dev(div16, t44);
    			append_dev(div16, input7);
    			set_input_value(input7, /*userEvent*/ ctx[4].location);
    			append_dev(div22, t45);
    			append_dev(div22, div21);
    			append_dev(div21, div20);
    			append_dev(div20, div19);
    			append_dev(div21, t46);
    			append_dev(div21, button3);
    			append_dev(button3, span1);
    			append_dev(button3, t47);
    			append_dev(button3, span2);
    			append_dev(div21, t49);
    			append_dev(div21, button4);
    			append_dev(button4, span3);
    			append_dev(button4, span4);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[12], false, false, false),
    					listen_dev(input0, "blur", /*onStartDateChange*/ ctx[7], false, false, false),
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[13]),
    					listen_dev(input1, "blur", /*onStartDateChange*/ ctx[7], false, false, false),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[14]),
    					listen_dev(input2, "blur", /*onEndDateChange*/ ctx[8], false, false, false),
    					listen_dev(input2, "input", /*input2_input_handler*/ ctx[15]),
    					listen_dev(input3, "blur", /*onEndDateChange*/ ctx[8], false, false, false),
    					listen_dev(input3, "input", /*input3_input_handler*/ ctx[16]),
    					listen_dev(input4, "input", /*input4_input_handler*/ ctx[17]),
    					listen_dev(input5, "input", /*input5_input_handler*/ ctx[18]),
    					listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[19]),
    					listen_dev(input6, "blur", /*blur_handler*/ ctx[20], false, false, false),
    					listen_dev(input6, "input", /*input6_input_handler*/ ctx[21]),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[22], false, false, false),
    					listen_dev(button2, "click", /*onPredefinedCategoryClick*/ ctx[11], false, false, false),
    					listen_dev(select0, "change", /*select0_change_handler*/ ctx[23]),
    					listen_dev(select0, "blur", /*blur_handler_1*/ ctx[24], false, false, false),
    					listen_dev(select1, "change", /*select1_change_handler*/ ctx[25]),
    					listen_dev(input7, "input", /*input7_input_handler*/ ctx[26]),
    					listen_dev(button3, "click", /*doRemoveUserEvent*/ ctx[10], false, false, false),
    					listen_dev(button4, "click", /*doUpdateUserEvent*/ ctx[9], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*startDate*/ 1) {
    				set_input_value(input0, /*startDate*/ ctx[0]);
    			}

    			if (dirty[0] & /*startTime*/ 2) {
    				set_input_value(input1, /*startTime*/ ctx[1]);
    			}

    			if (dirty[0] & /*endDate*/ 4) {
    				set_input_value(input2, /*endDate*/ ctx[2]);
    			}

    			if (dirty[0] & /*endTime*/ 8) {
    				set_input_value(input3, /*endTime*/ ctx[3]);
    			}

    			if (dirty[0] & /*userEvent*/ 16 && input4.value !== /*userEvent*/ ctx[4].label) {
    				set_input_value(input4, /*userEvent*/ ctx[4].label);
    			}

    			if (dirty[0] & /*userEvent*/ 16) {
    				set_input_value(input5, /*userEvent*/ ctx[4].color);
    			}

    			if (dirty[0] & /*userEvent*/ 16) {
    				set_input_value(textarea, /*userEvent*/ ctx[4].description);
    			}

    			if (dirty[0] & /*userEvent*/ 16 && input6.value !== /*userEvent*/ ctx[4].category) {
    				set_input_value(input6, /*userEvent*/ ctx[4].category);
    			}

    			if (dirty[0] & /*userEvent*/ 16) {
    				select_option(select0, /*userEvent*/ ctx[4].visibility);
    			}

    			if (dirty[0] & /*userEvent*/ 16) {
    				select_option(select1, /*userEvent*/ ctx[4].ownerAvailabilityStatus);
    			}

    			if (dirty[0] & /*userEvent*/ 16 && input7.value !== /*userEvent*/ ctx[4].location) {
    				set_input_value(input7, /*userEvent*/ ctx[4].location);
    			}

    			if (dirty[0] & /*$ShowUpdateUserEventStore*/ 32) {
    				toggle_class(div24, "show", /*$ShowUpdateUserEventStore*/ ctx[5].shown);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!div24_transition) div24_transition = create_bidirectional_transition(div24, fly, { y: -250, duration: 500 }, true);
    				div24_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!div24_transition) div24_transition = create_bidirectional_transition(div24, fly, { y: -250, duration: 500 }, false);
    			div24_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div24);
    			if (detaching && div24_transition) div24_transition.end();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(260:4) {#if $ShowUpdateUserEventStore.shown}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$b(ctx) {
    	let div;
    	let current;
    	let if_block = /*$ShowUpdateUserEventStore*/ ctx[5].shown && create_if_block$6(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "id", "update-user-event-background");
    			attr_dev(div, "class", "modal-background svelte-17dfl1m");
    			toggle_class(div, "show", /*$ShowUpdateUserEventStore*/ ctx[5].shown);
    			add_location(div, file$b, 258, 0, 8774);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*$ShowUpdateUserEventStore*/ ctx[5].shown) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*$ShowUpdateUserEventStore*/ 32) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$6(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (dirty[0] & /*$ShowUpdateUserEventStore*/ 32) {
    				toggle_class(div, "show", /*$ShowUpdateUserEventStore*/ ctx[5].shown);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function showOrHidePredefinedCategories(forceHide = false) {
    	const menu = document.getElementById("categories");
    	if (menu.classList.contains("show")) menu.classList.remove("show"); else menu.classList.add("show");
    	if (forceHide) menu.classList.remove("show");
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let $ShowUpdateUserEventStore;
    	validate_store(ShowUpdateUserEventStore, "ShowUpdateUserEventStore");
    	component_subscribe($$self, ShowUpdateUserEventStore, $$value => $$invalidate(5, $ShowUpdateUserEventStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("UpdateUserEventModal", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	let startDate;
    	let startTime;
    	let endDate;
    	let endTime;
    	let userEvent;

    	//@ts-ignore
    	const unsubscribe = ShowUpdateUserEventStore.subscribe(v => {
    		console.log("update on update modal");
    		initStartAndEnd();
    	});

    	const visibilitiesDescription = {
    		protected: "Un évènement protégé n'est accessible et visible que par des utilisateurs identifiés",
    		private: "Un évènement privé ne laisse voir aux autres utilisateurs que la date de début, de fin et la disponibilité de son créateur"
    	};

    	function validateUserEvent() {
    		return __awaiter(this, void 0, void 0, function* () {
    			if (getEndDate() < getStartDate()) {
    				return false;
    			}
    		});
    	}

    	function getEndDate() {
    		return Helpers.fromStringToDate(endDate, endTime);
    	}

    	function getStartDate() {
    		return Helpers.fromStringToDate(startDate, startTime);
    	}

    	function onStartDateChange() {
    		if (getEndDate() < getStartDate()) {
    			const d = getStartDate();
    			$$invalidate(4, userEvent.startDate = new Date(d.getFullYear(), d.getMonth(), d.getDate(), 0, 0), userEvent);
    			$$invalidate(4, userEvent.endDate = new Date(userEvent.startDate.getFullYear(), userEvent.startDate.getMonth(), userEvent.startDate.getDate(), 23, 59), userEvent);
    		}

    		$$invalidate(4, userEvent.startDate = getStartDate(), userEvent);
    	}

    	function onEndDateChange() {
    		if (getEndDate() < getStartDate()) {
    			const d = getEndDate();
    			$$invalidate(4, userEvent.endDate = new Date(d.getFullYear(), d.getMonth(), d.getDate(), 23, 59), userEvent);
    			$$invalidate(4, userEvent.startDate = new Date(userEvent.endDate.getFullYear(), userEvent.endDate.getMonth(), userEvent.endDate.getDate(), 0, 0), userEvent);
    		}

    		$$invalidate(4, userEvent.endDate = getEndDate(), userEvent);
    	}

    	function doUpdateUserEvent() {
    		return __awaiter(this, void 0, void 0, function* () {
    			const doUpdateUserEventButton = document.getElementById("do-update-user-events");
    			const loading = document.getElementById("update-user-events-loading");
    			let closeAfterAction = true;

    			try {
    				const backendService = yield dist$1.getBackendClient();
    				loading.classList.add("show");
    				doUpdateUserEventButton.setAttribute("disabled", "disabled");
    				yield backendService.userService.updateUserEvent(userEvent);
    			} catch(error) {
    				document.getElementById("error-updating-user-events-content").innerText = error.message;
    				document.getElementById("error-updating-user-events").classList.add("show");
    				closeAfterAction = false;
    				console.error(error);
    			} finally {
    				doUpdateUserEventButton.removeAttribute("disabled");
    				loading.classList.remove("show");

    				if (closeAfterAction) {
    					window.setTimeout(
    						() => {
    							ShowUpdateUserEventStore.set(new ShowModalUserEvent());
    						},
    						2000
    					);
    				}
    			}
    		});
    	}

    	function doRemoveUserEvent() {
    		return __awaiter(this, void 0, void 0, function* () {
    			const okToRemove = confirm("Êtes vous sûr de vouloir supprimer cet évènement ?");

    			if (okToRemove) {
    				const doRemoveUserEventButton = document.getElementById("do-remove-user-events");
    				const loading = document.getElementById("remove-user-events-loading");
    				let closeAfterAction = true;

    				try {
    					const backendService = yield dist$1.getBackendClient();
    					loading.classList.add("show");
    					doRemoveUserEventButton.setAttribute("disabled", "disabled");
    					yield backendService.userService.removeUserEvent(userEvent);
    				} catch(error) {
    					document.getElementById("error-updating-user-events-content").innerText = error.message;
    					document.getElementById("error-updating-user-events").classList.add("show");
    					closeAfterAction = false;
    					console.error(error);
    				} finally {
    					doRemoveUserEventButton.removeAttribute("disabled");
    					loading.classList.remove("show");

    					if (closeAfterAction) {
    						window.setTimeout(
    							() => {
    								ShowUpdateUserEventStore.set(new ShowModalUserEvent());
    							},
    							2000
    						);
    					}
    				}
    			}
    		});
    	}

    	function initStartAndEnd() {
    		if ($ShowUpdateUserEventStore.userEvent) {
    			$$invalidate(4, userEvent = $ShowUpdateUserEventStore.userEvent);
    			$$invalidate(0, startDate = Helpers.fromDateToString(userEvent.startDate));
    			$$invalidate(1, startTime = Helpers.fromTimeToString(userEvent.startDate));
    			$$invalidate(2, endDate = Helpers.fromDateToString(userEvent.endDate));
    			$$invalidate(3, endTime = Helpers.fromTimeToString(userEvent.endDate));
    		}
    	}

    	function onPredefinedCategoryClick(event) {
    		showOrHidePredefinedCategories();
    		const categoryInput = document.getElementById("user-event-category");
    		categoryInput.value = event.target.getAttribute("data-category");
    		$$invalidate(4, userEvent.category = categoryInput.value, userEvent);
    		const e = document.createEvent("HTMLEvents");
    		e.initEvent("blur", true, true);
    		categoryInput.dispatchEvent(e);
    	}

    	onMount(() => {
    		initStartAndEnd();
    	});

    	onDestroy(unsubscribe);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$3.warn(`<UpdateUserEventModal> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		ShowUpdateUserEventStore.set(new ShowModalUserEvent());
    	};

    	function input0_input_handler() {
    		startDate = this.value;
    		$$invalidate(0, startDate);
    	}

    	function input1_input_handler() {
    		startTime = this.value;
    		$$invalidate(1, startTime);
    	}

    	function input2_input_handler() {
    		endDate = this.value;
    		$$invalidate(2, endDate);
    	}

    	function input3_input_handler() {
    		endTime = this.value;
    		$$invalidate(3, endTime);
    	}

    	function input4_input_handler() {
    		userEvent.label = this.value;
    		$$invalidate(4, userEvent);
    	}

    	function input5_input_handler() {
    		userEvent.color = this.value;
    		$$invalidate(4, userEvent);
    	}

    	function textarea_input_handler() {
    		userEvent.description = this.value;
    		$$invalidate(4, userEvent);
    	}

    	const blur_handler = () => {
    		showOrHidePredefinedCategories(true);
    	};

    	function input6_input_handler() {
    		userEvent.category = this.value;
    		$$invalidate(4, userEvent);
    	}

    	const click_handler_1 = () => {
    		showOrHidePredefinedCategories();
    	};

    	function select0_change_handler() {
    		userEvent.visibility = select_value(this);
    		$$invalidate(4, userEvent);
    	}

    	const blur_handler_1 = () => {
    		const visibilitySelected = document.getElementById("user-event-visibility");
    		visibilitySelected.title = visibilitiesDescription[visibilitySelected.value];
    	};

    	function select1_change_handler() {
    		userEvent.ownerAvailabilityStatus = select_value(this);
    		$$invalidate(4, userEvent);
    	}

    	function input7_input_handler() {
    		userEvent.location = this.value;
    		$$invalidate(4, userEvent);
    	}

    	$$self.$capture_state = () => ({
    		__awaiter,
    		ShowUpdateUserEventStore,
    		ShowModalUserEvent,
    		fly,
    		onMount,
    		onDestroy,
    		afterUpdate,
    		UserAvailabilityStatus: dist.UserAvailabilityStatus,
    		UserEvent: dist.UserEvent,
    		UserEventVisibility: dist.UserEventVisibility,
    		getBackendClient: dist$1.getBackendClient,
    		Helpers,
    		startDate,
    		startTime,
    		endDate,
    		endTime,
    		userEvent,
    		unsubscribe,
    		visibilitiesDescription,
    		validateUserEvent,
    		getEndDate,
    		getStartDate,
    		onStartDateChange,
    		onEndDateChange,
    		doUpdateUserEvent,
    		doRemoveUserEvent,
    		initStartAndEnd,
    		onPredefinedCategoryClick,
    		showOrHidePredefinedCategories,
    		$ShowUpdateUserEventStore
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("startDate" in $$props) $$invalidate(0, startDate = $$props.startDate);
    		if ("startTime" in $$props) $$invalidate(1, startTime = $$props.startTime);
    		if ("endDate" in $$props) $$invalidate(2, endDate = $$props.endDate);
    		if ("endTime" in $$props) $$invalidate(3, endTime = $$props.endTime);
    		if ("userEvent" in $$props) $$invalidate(4, userEvent = $$props.userEvent);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		startDate,
    		startTime,
    		endDate,
    		endTime,
    		userEvent,
    		$ShowUpdateUserEventStore,
    		visibilitiesDescription,
    		onStartDateChange,
    		onEndDateChange,
    		doUpdateUserEvent,
    		doRemoveUserEvent,
    		onPredefinedCategoryClick,
    		click_handler,
    		input0_input_handler,
    		input1_input_handler,
    		input2_input_handler,
    		input3_input_handler,
    		input4_input_handler,
    		input5_input_handler,
    		textarea_input_handler,
    		blur_handler,
    		input6_input_handler,
    		click_handler_1,
    		select0_change_handler,
    		blur_handler_1,
    		select1_change_handler,
    		input7_input_handler
    	];
    }

    class UpdateUserEventModal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$b, create_fragment$b, safe_not_equal, {}, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "UpdateUserEventModal",
    			options,
    			id: create_fragment$b.name
    		});
    	}
    }

    /* src/components/UserEvents/CalendarNavBar.svelte generated by Svelte v3.38.2 */
    const file$a = "src/components/UserEvents/CalendarNavBar.svelte";

    function create_fragment$a(ctx) {
    	let div2;
    	let div0;
    	let t0_value = `${Helpers.getLongLabelMonth(/*startDate*/ ctx[0])} ${/*startDate*/ ctx[0].getFullYear()}` + "";
    	let t0;
    	let t1;
    	let div1;
    	let button0;
    	let i0;
    	let t2;
    	let button1;
    	let i1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			div1 = element("div");
    			button0 = element("button");
    			i0 = element("i");
    			t2 = space();
    			button1 = element("button");
    			i1 = element("i");
    			attr_dev(div0, "class", "current-period svelte-sgfty3");
    			add_location(div0, file$a, 71, 4, 1794);
    			attr_dev(i0, "class", "fas fa-chevron-left");
    			add_location(i0, file$a, 73, 98, 2036);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn btn-secondary change-period-btn svelte-sgfty3");
    			add_location(button0, file$a, 73, 8, 1946);
    			attr_dev(i1, "class", "fas fa-chevron-right");
    			add_location(i1, file$a, 74, 97, 2178);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn btn-secondary change-period-btn svelte-sgfty3");
    			add_location(button1, file$a, 74, 8, 2089);
    			attr_dev(div1, "id", "change-display-period");
    			attr_dev(div1, "class", "svelte-sgfty3");
    			add_location(div1, file$a, 72, 4, 1905);
    			attr_dev(div2, "class", "userevents-navbar svelte-sgfty3");
    			add_location(div2, file$a, 70, 0, 1758);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, t0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div1, button0);
    			append_dev(button0, i0);
    			append_dev(div1, t2);
    			append_dev(div1, button1);
    			append_dev(button1, i1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*lookBackward*/ ctx[1], false, false, false),
    					listen_dev(button1, "click", /*lookForward*/ ctx[2], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*startDate*/ 1 && t0_value !== (t0_value = `${Helpers.getLongLabelMonth(/*startDate*/ ctx[0])} ${/*startDate*/ ctx[0].getFullYear()}` + "")) set_data_dev(t0, t0_value);
    		},
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("CalendarNavBar", slots, []);
    	const dispatch = createEventDispatcher();
    	let today = new Date();
    	let startDate = new Date(today.getFullYear(), today.getMonth(), 1, 0, 0, 0);
    	let endDate = new Date(today.getFullYear(), today.getMonth() + 1, 0, 23, 59, 59);

    	async function lookBackward() {
    		$$invalidate(0, startDate = new Date(startDate.getFullYear(), startDate.getMonth() - 1, 1, 0, 0, 0));
    		endDate = new Date(startDate.getFullYear(), startDate.getMonth() + 1, 0, 23, 59, 59);
    		dispatch("dateChanged", { startDate, endDate });
    	}

    	async function lookForward() {
    		$$invalidate(0, startDate = new Date(startDate.getFullYear(), startDate.getMonth() + 1, 1, 0, 0, 0));
    		endDate = new Date(startDate.getFullYear(), startDate.getMonth() + 1, 0, 23, 59, 59);
    		dispatch("dateChanged", { startDate, endDate });
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CalendarNavBar> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Helpers,
    		createEventDispatcher,
    		dispatch,
    		today,
    		startDate,
    		endDate,
    		lookBackward,
    		lookForward
    	});

    	$$self.$inject_state = $$props => {
    		if ("today" in $$props) today = $$props.today;
    		if ("startDate" in $$props) $$invalidate(0, startDate = $$props.startDate);
    		if ("endDate" in $$props) endDate = $$props.endDate;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [startDate, lookBackward, lookForward];
    }

    class CalendarNavBar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$a, create_fragment$a, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CalendarNavBar",
    			options,
    			id: create_fragment$a.name
    		});
    	}
    }

    /* src/components/UserEvents/ContentUserEventContainer.svelte generated by Svelte v3.38.2 */

    const { console: console_1$2 } = globals;
    const file$9 = "src/components/UserEvents/ContentUserEventContainer.svelte";

    // (102:0) {#if day.getMonth() !== userEvent.startDate.getMonth() && day.getDate() === 1}
    function create_if_block_3$2(ctx) {
    	let div0;
    	let div0_style_value;
    	let t;
    	let div1;
    	let div1_style_value;

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			t = space();
    			div1 = element("div");
    			attr_dev(div0, "class", "dotted svelte-nvhpo9");

    			attr_dev(div0, "style", div0_style_value = "" + ((/*userEvent*/ ctx[0].ownerAvailabilityStatus === dist.UserAvailabilityStatus.busy
    			? `background: ${/*userEvent*/ ctx[0].color}`
    			: `border : solid 1px ${/*userEvent*/ ctx[0].color}`) + "; top: " + (/*index*/ ctx[2] * 25 + /*index*/ ctx[2] * 1) + "px; left:0;"));

    			add_location(div0, file$9, 102, 4, 3290);
    			attr_dev(div1, "class", "dotted svelte-nvhpo9");

    			attr_dev(div1, "style", div1_style_value = "" + ((/*userEvent*/ ctx[0].ownerAvailabilityStatus === dist.UserAvailabilityStatus.busy
    			? `background: ${/*userEvent*/ ctx[0].color}`
    			: `border : solid 1px ${/*userEvent*/ ctx[0].color}`) + "; top: " + (/*index*/ ctx[2] * 25 + /*index*/ ctx[2] * 1) + "px; left:8px;"));

    			add_location(div1, file$9, 107, 4, 3520);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*userEvent, index*/ 5 && div0_style_value !== (div0_style_value = "" + ((/*userEvent*/ ctx[0].ownerAvailabilityStatus === dist.UserAvailabilityStatus.busy
    			? `background: ${/*userEvent*/ ctx[0].color}`
    			: `border : solid 1px ${/*userEvent*/ ctx[0].color}`) + "; top: " + (/*index*/ ctx[2] * 25 + /*index*/ ctx[2] * 1) + "px; left:0;"))) {
    				attr_dev(div0, "style", div0_style_value);
    			}

    			if (dirty & /*userEvent, index*/ 5 && div1_style_value !== (div1_style_value = "" + ((/*userEvent*/ ctx[0].ownerAvailabilityStatus === dist.UserAvailabilityStatus.busy
    			? `background: ${/*userEvent*/ ctx[0].color}`
    			: `border : solid 1px ${/*userEvent*/ ctx[0].color}`) + "; top: " + (/*index*/ ctx[2] * 25 + /*index*/ ctx[2] * 1) + "px; left:8px;"))) {
    				attr_dev(div1, "style", div1_style_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$2.name,
    		type: "if",
    		source: "(102:0) {#if day.getMonth() !== userEvent.startDate.getMonth() && day.getDate() === 1}",
    		ctx
    	});

    	return block;
    }

    // (144:4) {#if isStart || day.getMonth() !== userEvent.startDate.getMonth() && day.getDate() === 1}
    function create_if_block_1$4(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*userEvent*/ ctx[0].ownerId !== /*$UserStore*/ ctx[7].id && /*userEvent*/ ctx[0].visibility === dist.UserEventVisibility.private) return create_if_block_2$2;
    		return create_else_block$1;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(144:4) {#if isStart || day.getMonth() !== userEvent.startDate.getMonth() && day.getDate() === 1}",
    		ctx
    	});

    	return block;
    }

    // (147:8) {:else}
    function create_else_block$1(ctx) {
    	let span;
    	let t_value = /*userEvent*/ ctx[0].label + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			set_style(span, "font-size", "0.7rem");
    			set_style(span, "white-space", "pre");
    			add_location(span, file$9, 147, 12, 5116);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*userEvent*/ 1 && t_value !== (t_value = /*userEvent*/ ctx[0].label + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(147:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (145:8) {#if userEvent.ownerId !== $UserStore.id && userEvent.visibility === UserEventVisibility.private}
    function create_if_block_2$2(ctx) {
    	let span;
    	let i;

    	const block = {
    		c: function create() {
    			span = element("span");
    			i = element("i");
    			attr_dev(i, "class", "fas fa-eye-slash");
    			add_location(i, file$9, 145, 18, 5048);
    			add_location(span, file$9, 145, 12, 5042);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, i);
    		},
    		p: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(145:8) {#if userEvent.ownerId !== $UserStore.id && userEvent.visibility === UserEventVisibility.private}",
    		ctx
    	});

    	return block;
    }

    // (152:0) {#if day.getMonth() !== userEvent.endDate.getMonth() && day.getDate() >= (new Date(day.getFullYear(), day.getMonth() + 1, 0)).getDate()}
    function create_if_block$5(ctx) {
    	let div0;
    	let div0_style_value;
    	let t;
    	let div1;
    	let div1_style_value;

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			t = space();
    			div1 = element("div");
    			attr_dev(div0, "class", "dotted svelte-nvhpo9");

    			attr_dev(div0, "style", div0_style_value = "" + ((/*userEvent*/ ctx[0].ownerAvailabilityStatus === dist.UserAvailabilityStatus.busy
    			? `background: ${/*userEvent*/ ctx[0].color}`
    			: `border : solid 1px ${/*userEvent*/ ctx[0].color}`) + "; top: " + (/*index*/ ctx[2] * 25 + /*index*/ ctx[2] * 1) + "px; left:calc(100% - 12px);"));

    			add_location(div0, file$9, 152, 4, 5363);
    			attr_dev(div1, "class", "dotted svelte-nvhpo9");

    			attr_dev(div1, "style", div1_style_value = "" + ((/*userEvent*/ ctx[0].ownerAvailabilityStatus === dist.UserAvailabilityStatus.busy
    			? `background: ${/*userEvent*/ ctx[0].color}`
    			: `border : solid 1px ${/*userEvent*/ ctx[0].color}`) + "; top: " + (/*index*/ ctx[2] * 25 + /*index*/ ctx[2] * 1) + "px; left:calc(100% - 4px);"));

    			add_location(div1, file$9, 157, 4, 5609);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*userEvent, index*/ 5 && div0_style_value !== (div0_style_value = "" + ((/*userEvent*/ ctx[0].ownerAvailabilityStatus === dist.UserAvailabilityStatus.busy
    			? `background: ${/*userEvent*/ ctx[0].color}`
    			: `border : solid 1px ${/*userEvent*/ ctx[0].color}`) + "; top: " + (/*index*/ ctx[2] * 25 + /*index*/ ctx[2] * 1) + "px; left:calc(100% - 12px);"))) {
    				attr_dev(div0, "style", div0_style_value);
    			}

    			if (dirty & /*userEvent, index*/ 5 && div1_style_value !== (div1_style_value = "" + ((/*userEvent*/ ctx[0].ownerAvailabilityStatus === dist.UserAvailabilityStatus.busy
    			? `background: ${/*userEvent*/ ctx[0].color}`
    			: `border : solid 1px ${/*userEvent*/ ctx[0].color}`) + "; top: " + (/*index*/ ctx[2] * 25 + /*index*/ ctx[2] * 1) + "px; left:calc(100% - 4px);"))) {
    				attr_dev(div1, "style", div1_style_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(152:0) {#if day.getMonth() !== userEvent.endDate.getMonth() && day.getDate() >= (new Date(day.getFullYear(), day.getMonth() + 1, 0)).getDate()}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$9(ctx) {
    	let show_if_2 = /*day*/ ctx[1].getMonth() !== /*userEvent*/ ctx[0].startDate.getMonth() && /*day*/ ctx[1].getDate() === 1;
    	let t0;
    	let div;
    	let show_if_1 = /*isStart*/ ctx[3] || /*day*/ ctx[1].getMonth() !== /*userEvent*/ ctx[0].startDate.getMonth() && /*day*/ ctx[1].getDate() === 1;
    	let div_style_value;
    	let div_title_value;
    	let t1;
    	let show_if = /*day*/ ctx[1].getMonth() !== /*userEvent*/ ctx[0].endDate.getMonth() && /*day*/ ctx[1].getDate() >= new Date(/*day*/ ctx[1].getFullYear(), /*day*/ ctx[1].getMonth() + 1, 0).getDate();
    	let if_block2_anchor;
    	let mounted;
    	let dispose;
    	let if_block0 = show_if_2 && create_if_block_3$2(ctx);
    	let if_block1 = show_if_1 && create_if_block_1$4(ctx);
    	let if_block2 = show_if && create_if_block$5(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div = element("div");
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty$2();

    			attr_dev(div, "class", "user-event-container " + (/*isEndingNextMonth*/ ctx[8]()
    			? "user-event-end-after"
    			: "") + " svelte-nvhpo9");

    			attr_dev(div, "style", div_style_value = "" + ((/*userEvent*/ ctx[0].ownerAvailabilityStatus === dist.UserAvailabilityStatus.busy
    			? `background: ${/*userEvent*/ ctx[0].color}`
    			: `color: ${/*userEvent*/ ctx[0].color};
border-top : solid 1px ${/*userEvent*/ ctx[0].color};
border-bottom: solid 1px ${/*userEvent*/ ctx[0].color}; ${/*isStart*/ ctx[3] || /*isStartBefore*/ ctx[6]
				? `border-left: solid 1px ${/*userEvent*/ ctx[0].color}`
				: "border-left: none"}; ${/*isEnd*/ ctx[4] || /*isEndAfter*/ ctx[5]
				? `border-right: solid 1px ${/*userEvent*/ ctx[0].color}`
				: "border-right: none"}`) + "; top: " + (/*index*/ ctx[2] * 25 + /*index*/ ctx[2] * 1) + "px;"));

    			attr_dev(div, "title", div_title_value = `${/*userEvent*/ ctx[0].category} : ${/*userEvent*/ ctx[0].label} `);
    			toggle_class(div, "user-event-end", /*isEnd*/ ctx[4]);
    			toggle_class(div, "user-event-start", /*isStart*/ ctx[3]);
    			toggle_class(div, "user-event-one-day", /*isStart*/ ctx[3] && /*isEnd*/ ctx[4]);
    			toggle_class(div, "user-event-start-before", /*isStartBefore*/ ctx[6]);
    			toggle_class(div, "user-event-end-after", /*isEndAfter*/ ctx[5]);
    			add_location(div, file$9, 113, 0, 3754);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);
    			if (if_block1) if_block1.m(div, null);
    			insert_dev(target, t1, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);

    			if (!mounted) {
    				dispose = listen_dev(div, "dblclick", /*dblclick_handler*/ ctx[9], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*day, userEvent*/ 3) show_if_2 = /*day*/ ctx[1].getMonth() !== /*userEvent*/ ctx[0].startDate.getMonth() && /*day*/ ctx[1].getDate() === 1;

    			if (show_if_2) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_3$2(ctx);
    					if_block0.c();
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty & /*isStart, day, userEvent*/ 11) show_if_1 = /*isStart*/ ctx[3] || /*day*/ ctx[1].getMonth() !== /*userEvent*/ ctx[0].startDate.getMonth() && /*day*/ ctx[1].getDate() === 1;

    			if (show_if_1) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_1$4(ctx);
    					if_block1.c();
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty & /*userEvent, isStart, isStartBefore, isEnd, isEndAfter, index*/ 125 && div_style_value !== (div_style_value = "" + ((/*userEvent*/ ctx[0].ownerAvailabilityStatus === dist.UserAvailabilityStatus.busy
    			? `background: ${/*userEvent*/ ctx[0].color}`
    			: `color: ${/*userEvent*/ ctx[0].color};
border-top : solid 1px ${/*userEvent*/ ctx[0].color};
border-bottom: solid 1px ${/*userEvent*/ ctx[0].color}; ${/*isStart*/ ctx[3] || /*isStartBefore*/ ctx[6]
				? `border-left: solid 1px ${/*userEvent*/ ctx[0].color}`
				: "border-left: none"}; ${/*isEnd*/ ctx[4] || /*isEndAfter*/ ctx[5]
				? `border-right: solid 1px ${/*userEvent*/ ctx[0].color}`
				: "border-right: none"}`) + "; top: " + (/*index*/ ctx[2] * 25 + /*index*/ ctx[2] * 1) + "px;"))) {
    				attr_dev(div, "style", div_style_value);
    			}

    			if (dirty & /*userEvent*/ 1 && div_title_value !== (div_title_value = `${/*userEvent*/ ctx[0].category} : ${/*userEvent*/ ctx[0].label} `)) {
    				attr_dev(div, "title", div_title_value);
    			}

    			if (dirty & /*isEnd*/ 16) {
    				toggle_class(div, "user-event-end", /*isEnd*/ ctx[4]);
    			}

    			if (dirty & /*isStart*/ 8) {
    				toggle_class(div, "user-event-start", /*isStart*/ ctx[3]);
    			}

    			if (dirty & /*isStart, isEnd*/ 24) {
    				toggle_class(div, "user-event-one-day", /*isStart*/ ctx[3] && /*isEnd*/ ctx[4]);
    			}

    			if (dirty & /*isStartBefore*/ 64) {
    				toggle_class(div, "user-event-start-before", /*isStartBefore*/ ctx[6]);
    			}

    			if (dirty & /*isEndAfter*/ 32) {
    				toggle_class(div, "user-event-end-after", /*isEndAfter*/ ctx[5]);
    			}

    			if (dirty & /*day, userEvent*/ 3) show_if = /*day*/ ctx[1].getMonth() !== /*userEvent*/ ctx[0].endDate.getMonth() && /*day*/ ctx[1].getDate() >= new Date(/*day*/ ctx[1].getFullYear(), /*day*/ ctx[1].getMonth() + 1, 0).getDate();

    			if (show_if) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block$5(ctx);
    					if_block2.c();
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}
    		},
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			if (if_block1) if_block1.d();
    			if (detaching) detach_dev(t1);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let $UserStore;
    	validate_store(UserStore, "UserStore");
    	component_subscribe($$self, UserStore, $$value => $$invalidate(7, $UserStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ContentUserEventContainer", slots, []);
    	let { userEvent } = $$props;
    	let { day } = $$props;
    	let { index } = $$props;
    	let isStart = userEvent.startDate.getFullYear() === day.getFullYear() && userEvent.startDate.getMonth() === day.getMonth() && userEvent.startDate.getDate() === day.getDate();
    	let isEnd = userEvent.endDate.getFullYear() === day.getFullYear() && userEvent.endDate.getMonth() === day.getMonth() && userEvent.endDate.getDate() === day.getDate();
    	let isEndAfter = isEndingNextMonth();
    	let isStartBefore = isStartingPreviousMonth();

    	function isStartingPreviousMonth() {
    		return day.getMonth() !== userEvent.startDate.getMonth() && day.getDate() === 1;
    	}

    	function isEndingNextMonth() {
    		const d = new Date(2021, 6, 31);

    		if (day.getFullYear() === d.getFullYear() && day.getMonth() === d.getMonth() && day.getDate() === d.getDate()) {
    			console.log("#");
    			console.log(`${day.getMonth()} < ${userEvent.endDate.getMonth()}`);
    			console.log(`${day.getDate()} === ${new Date(day.getFullYear(), day.getMonth() + 1, 0).getDate()}`);
    			console.log("#");
    		}

    		return day.getMonth() < userEvent.endDate.getMonth() && day.getDate() === new Date(day.getFullYear(), day.getMonth() + 1, 0).getDate();
    	}

    	const writable_props = ["userEvent", "day", "index"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$2.warn(`<ContentUserEventContainer> was created with unknown prop '${key}'`);
    	});

    	const dblclick_handler = event => {
    		event.stopPropagation();

    		ShowUpdateUserEventStore.update(sues => {
    			sues.shown = true;
    			sues.userEvent = userEvent;
    			return sues;
    		});
    	};

    	$$self.$$set = $$props => {
    		if ("userEvent" in $$props) $$invalidate(0, userEvent = $$props.userEvent);
    		if ("day" in $$props) $$invalidate(1, day = $$props.day);
    		if ("index" in $$props) $$invalidate(2, index = $$props.index);
    	};

    	$$self.$capture_state = () => ({
    		UserEvent: dist.UserEvent,
    		ShowUpdateUserEventStore,
    		UserAvailabilityStatus: dist.UserAvailabilityStatus,
    		UserEventVisibility: dist.UserEventVisibility,
    		UserStore,
    		userEvent,
    		day,
    		index,
    		isStart,
    		isEnd,
    		isEndAfter,
    		isStartBefore,
    		isStartingPreviousMonth,
    		isEndingNextMonth,
    		$UserStore
    	});

    	$$self.$inject_state = $$props => {
    		if ("userEvent" in $$props) $$invalidate(0, userEvent = $$props.userEvent);
    		if ("day" in $$props) $$invalidate(1, day = $$props.day);
    		if ("index" in $$props) $$invalidate(2, index = $$props.index);
    		if ("isStart" in $$props) $$invalidate(3, isStart = $$props.isStart);
    		if ("isEnd" in $$props) $$invalidate(4, isEnd = $$props.isEnd);
    		if ("isEndAfter" in $$props) $$invalidate(5, isEndAfter = $$props.isEndAfter);
    		if ("isStartBefore" in $$props) $$invalidate(6, isStartBefore = $$props.isStartBefore);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*userEvent, day*/ 3) {
    			{
    				$$invalidate(3, isStart = userEvent.startDate.getFullYear() === day.getFullYear() && userEvent.startDate.getMonth() === day.getMonth() && userEvent.startDate.getDate() === day.getDate());
    				$$invalidate(4, isEnd = userEvent.endDate.getFullYear() === day.getFullYear() && userEvent.endDate.getMonth() === day.getMonth() && userEvent.endDate.getDate() === day.getDate());
    				$$invalidate(5, isEndAfter = isEndingNextMonth());
    				$$invalidate(6, isStartBefore = isStartingPreviousMonth());
    			}
    		}
    	};

    	return [
    		userEvent,
    		day,
    		index,
    		isStart,
    		isEnd,
    		isEndAfter,
    		isStartBefore,
    		$UserStore,
    		isEndingNextMonth,
    		dblclick_handler
    	];
    }

    class ContentUserEventContainer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$9, create_fragment$9, safe_not_equal, { userEvent: 0, day: 1, index: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ContentUserEventContainer",
    			options,
    			id: create_fragment$9.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*userEvent*/ ctx[0] === undefined && !("userEvent" in props)) {
    			console_1$2.warn("<ContentUserEventContainer> was created without expected prop 'userEvent'");
    		}

    		if (/*day*/ ctx[1] === undefined && !("day" in props)) {
    			console_1$2.warn("<ContentUserEventContainer> was created without expected prop 'day'");
    		}

    		if (/*index*/ ctx[2] === undefined && !("index" in props)) {
    			console_1$2.warn("<ContentUserEventContainer> was created without expected prop 'index'");
    		}
    	}

    	get userEvent() {
    		throw new Error("<ContentUserEventContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set userEvent(value) {
    		throw new Error("<ContentUserEventContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get day() {
    		throw new Error("<ContentUserEventContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set day(value) {
    		throw new Error("<ContentUserEventContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get index() {
    		throw new Error("<ContentUserEventContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set index(value) {
    		throw new Error("<ContentUserEventContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/UserEvents/ContentDayContainer.svelte generated by Svelte v3.38.2 */
    const file$8 = "src/components/UserEvents/ContentDayContainer.svelte";

    function get_each_context$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	return child_ctx;
    }

    // (69:101) {#if currentDay.getDate() === new Date().getDate() &&     currentDay.getMonth() === new Date().getMonth() &&     currentDay.getFullYear() === new Date().getFullYear()}
    function create_if_block_1$3(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "today-mark svelte-v88auy");
    			add_location(div, file$8, 70, 58, 2625);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(69:101) {#if currentDay.getDate() === new Date().getDate() &&     currentDay.getMonth() === new Date().getMonth() &&     currentDay.getFullYear() === new Date().getFullYear()}",
    		ctx
    	});

    	return block;
    }

    // (75:8) {#if Array.isArray(userEvents)}
    function create_if_block$4(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*userEvents*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*userEvents, currentDay, $UserEventsStore, login*/ 15) {
    				each_value = /*userEvents*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$5(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$5(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(75:8) {#if Array.isArray(userEvents)}",
    		ctx
    	});

    	return block;
    }

    // (76:12) {#each userEvents as userEvent}
    function create_each_block$5(ctx) {
    	let contentusereventcontainer;
    	let current;

    	contentusereventcontainer = new ContentUserEventContainer({
    			props: {
    				userEvent: /*userEvent*/ ctx[8],
    				day: /*currentDay*/ ctx[0],
    				index: /*$UserEventsStore*/ ctx[3].eventsByUser[/*login*/ ctx[1]].indexOf(/*userEvent*/ ctx[8])
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(contentusereventcontainer.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(contentusereventcontainer, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const contentusereventcontainer_changes = {};
    			if (dirty & /*userEvents*/ 4) contentusereventcontainer_changes.userEvent = /*userEvent*/ ctx[8];
    			if (dirty & /*currentDay*/ 1) contentusereventcontainer_changes.day = /*currentDay*/ ctx[0];
    			if (dirty & /*$UserEventsStore, login, userEvents*/ 14) contentusereventcontainer_changes.index = /*$UserEventsStore*/ ctx[3].eventsByUser[/*login*/ ctx[1]].indexOf(/*userEvent*/ ctx[8]);
    			contentusereventcontainer.$set(contentusereventcontainer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(contentusereventcontainer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(contentusereventcontainer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(contentusereventcontainer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$5.name,
    		type: "each",
    		source: "(76:12) {#each userEvents as userEvent}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$8(ctx) {
    	let div2;
    	let div0;
    	let t0_value = `${Helpers.getShortDayOfWeekLabel(/*currentDay*/ ctx[0])} ${/*currentDay*/ ctx[0].getDate()}` + "";
    	let t0;
    	let t1;
    	let show_if_1 = /*currentDay*/ ctx[0].getDate() === new Date().getDate() && /*currentDay*/ ctx[0].getMonth() === new Date().getMonth() && /*currentDay*/ ctx[0].getFullYear() === new Date().getFullYear();
    	let t2;
    	let div1;
    	let show_if = Array.isArray(/*userEvents*/ ctx[2]);
    	let div1_style_value;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = show_if_1 && create_if_block_1$3(ctx);
    	let if_block1 = show_if && create_if_block$4(ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			div1 = element("div");
    			if (if_block1) if_block1.c();
    			attr_dev(div0, "class", "day-title svelte-v88auy");
    			add_location(div0, file$8, 68, 4, 2361);
    			attr_dev(div1, "class", "events-container svelte-v88auy");

    			attr_dev(div1, "style", div1_style_value = Array.isArray(/*userEvents*/ ctx[2])
    			? `height : ${/*$UserEventsStore*/ ctx[3].eventsByUser[/*login*/ ctx[1]]
				? /*$UserEventsStore*/ ctx[3].eventsByUser[/*login*/ ctx[1]].length * 26
				: 1}px;`
    			: "");

    			add_location(div1, file$8, 71, 4, 2671);
    			attr_dev(div2, "class", "day svelte-v88auy");
    			add_location(div2, file$8, 67, 0, 2297);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, t0);
    			append_dev(div0, t1);
    			if (if_block0) if_block0.m(div0, null);
    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			if (if_block1) if_block1.m(div1, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div2, "dblclick", /*displayCreateUserEventModal*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*currentDay*/ 1) && t0_value !== (t0_value = `${Helpers.getShortDayOfWeekLabel(/*currentDay*/ ctx[0])} ${/*currentDay*/ ctx[0].getDate()}` + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*currentDay*/ 1) show_if_1 = /*currentDay*/ ctx[0].getDate() === new Date().getDate() && /*currentDay*/ ctx[0].getMonth() === new Date().getMonth() && /*currentDay*/ ctx[0].getFullYear() === new Date().getFullYear();

    			if (show_if_1) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_1$3(ctx);
    					if_block0.c();
    					if_block0.m(div0, null);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty & /*userEvents*/ 4) show_if = Array.isArray(/*userEvents*/ ctx[2]);

    			if (show_if) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*userEvents*/ 4) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$4(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div1, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*userEvents, $UserEventsStore, login*/ 14 && div1_style_value !== (div1_style_value = Array.isArray(/*userEvents*/ ctx[2])
    			? `height : ${/*$UserEventsStore*/ ctx[3].eventsByUser[/*login*/ ctx[1]]
				? /*$UserEventsStore*/ ctx[3].eventsByUser[/*login*/ ctx[1]].length * 26
				: 1}px;`
    			: "")) {
    				attr_dev(div1, "style", div1_style_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let $UserEventsStore;
    	validate_store(UserEventsStore, "UserEventsStore");
    	component_subscribe($$self, UserEventsStore, $$value => $$invalidate(3, $UserEventsStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ContentDayContainer", slots, []);
    	let { currentDay } = $$props;
    	let { login } = $$props;
    	let startDate = new Date(currentDay.getFullYear(), currentDay.getMonth(), currentDay.getDate(), 0, 0, 0);
    	let endDate = new Date(currentDay.getFullYear(), currentDay.getMonth(), currentDay.getDate(), 23, 59, 59);
    	let userEvents = [];

    	const unsubscribe = UserEventsStore.subscribe(ues => {
    		startDate = new Date(currentDay.getFullYear(), currentDay.getMonth(), currentDay.getDate(), 0, 0, 0);
    		endDate = new Date(currentDay.getFullYear(), currentDay.getMonth(), currentDay.getDate(), 23, 59, 59);

    		$$invalidate(2, userEvents = ues.eventsByUser[login]
    		? ues.eventsByUser[login].filter(ue => ue.startDate.getTime() <= startDate.getTime() && startDate.getTime() <= ue.endDate.getTime())
    		: []);
    	});

    	function displayCreateUserEventModal() {
    		ShowCreateUserEventStore.update(m => {
    			m.shown = true;
    			m.startDate = new Date(currentDay.getFullYear(), currentDay.getMonth(), currentDay.getDate(), 0, 0);
    			m.endDate = new Date(currentDay.getFullYear(), currentDay.getMonth(), currentDay.getDate(), 23, 59);
    			return m;
    		});
    	}

    	onDestroy(() => {
    		unsubscribe();
    	});

    	const writable_props = ["currentDay", "login"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ContentDayContainer> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("currentDay" in $$props) $$invalidate(0, currentDay = $$props.currentDay);
    		if ("login" in $$props) $$invalidate(1, login = $$props.login);
    	};

    	$$self.$capture_state = () => ({
    		Helpers,
    		ShowCreateUserEventStore,
    		UserEvents,
    		UserEventsStore,
    		onDestroy,
    		ContentUserEventContainer,
    		currentDay,
    		login,
    		startDate,
    		endDate,
    		userEvents,
    		unsubscribe,
    		displayCreateUserEventModal,
    		$UserEventsStore
    	});

    	$$self.$inject_state = $$props => {
    		if ("currentDay" in $$props) $$invalidate(0, currentDay = $$props.currentDay);
    		if ("login" in $$props) $$invalidate(1, login = $$props.login);
    		if ("startDate" in $$props) startDate = $$props.startDate;
    		if ("endDate" in $$props) endDate = $$props.endDate;
    		if ("userEvents" in $$props) $$invalidate(2, userEvents = $$props.userEvents);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [currentDay, login, userEvents, $UserEventsStore, displayCreateUserEventModal];
    }

    class ContentDayContainer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$8, create_fragment$8, safe_not_equal, { currentDay: 0, login: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ContentDayContainer",
    			options,
    			id: create_fragment$8.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*currentDay*/ ctx[0] === undefined && !("currentDay" in props)) {
    			console.warn("<ContentDayContainer> was created without expected prop 'currentDay'");
    		}

    		if (/*login*/ ctx[1] === undefined && !("login" in props)) {
    			console.warn("<ContentDayContainer> was created without expected prop 'login'");
    		}
    	}

    	get currentDay() {
    		throw new Error("<ContentDayContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set currentDay(value) {
    		throw new Error("<ContentDayContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get login() {
    		throw new Error("<ContentDayContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set login(value) {
    		throw new Error("<ContentDayContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/UserEvents/ContentUserCalendarContainer.svelte generated by Svelte v3.38.2 */
    const file$7 = "src/components/UserEvents/ContentUserCalendarContainer.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[2] = list[i];
    	return child_ctx;
    }

    // (19:4) {#each days as day}
    function create_each_block$4(ctx) {
    	let contentdaycontainer;
    	let current;

    	contentdaycontainer = new ContentDayContainer({
    			props: {
    				currentDay: /*day*/ ctx[2],
    				login: /*login*/ ctx[1]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(contentdaycontainer.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(contentdaycontainer, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const contentdaycontainer_changes = {};
    			if (dirty & /*days*/ 1) contentdaycontainer_changes.currentDay = /*day*/ ctx[2];
    			if (dirty & /*login*/ 2) contentdaycontainer_changes.login = /*login*/ ctx[1];
    			contentdaycontainer.$set(contentdaycontainer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(contentdaycontainer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(contentdaycontainer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(contentdaycontainer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(19:4) {#each days as day}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$7(ctx) {
    	let div;
    	let current;
    	let each_value = /*days*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "userevents-calendar svelte-18wkpe5");
    			add_location(div, file$7, 17, 0, 379);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*days, login*/ 3) {
    				each_value = /*days*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ContentUserCalendarContainer", slots, []);
    	let { days } = $$props;
    	let { login } = $$props;
    	const writable_props = ["days", "login"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ContentUserCalendarContainer> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("days" in $$props) $$invalidate(0, days = $$props.days);
    		if ("login" in $$props) $$invalidate(1, login = $$props.login);
    	};

    	$$self.$capture_state = () => ({ ContentDayContainer, days, login });

    	$$self.$inject_state = $$props => {
    		if ("days" in $$props) $$invalidate(0, days = $$props.days);
    		if ("login" in $$props) $$invalidate(1, login = $$props.login);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [days, login];
    }

    class ContentUserCalendarContainer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$7, create_fragment$7, safe_not_equal, { days: 0, login: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ContentUserCalendarContainer",
    			options,
    			id: create_fragment$7.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*days*/ ctx[0] === undefined && !("days" in props)) {
    			console.warn("<ContentUserCalendarContainer> was created without expected prop 'days'");
    		}

    		if (/*login*/ ctx[1] === undefined && !("login" in props)) {
    			console.warn("<ContentUserCalendarContainer> was created without expected prop 'login'");
    		}
    	}

    	get days() {
    		throw new Error("<ContentUserCalendarContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set days(value) {
    		throw new Error("<ContentUserCalendarContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get login() {
    		throw new Error("<ContentUserCalendarContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set login(value) {
    		throw new Error("<ContentUserCalendarContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/UserEvents/ContentUserEventsContainer.svelte generated by Svelte v3.38.2 */
    const file$6 = "src/components/UserEvents/ContentUserEventsContainer.svelte";

    function create_fragment$6(ctx) {
    	let main;
    	let calendarnavbar;
    	let t0;
    	let contentusercalendarcontainer;
    	let t1;
    	let createusereventmodal;
    	let t2;
    	let updateusereventmodal;
    	let current;
    	calendarnavbar = new CalendarNavBar({ $$inline: true });
    	calendarnavbar.$on("dateChanged", /*dateChanged_handler*/ ctx[4]);

    	contentusercalendarcontainer = new ContentUserCalendarContainer({
    			props: {
    				login: /*$UserStore*/ ctx[3].login,
    				days: /*days*/ ctx[2]
    			},
    			$$inline: true
    		});

    	createusereventmodal = new CreateUserEventModal({ $$inline: true });
    	updateusereventmodal = new UpdateUserEventModal({ $$inline: true });

    	const block = {
    		c: function create() {
    			main = element("main");
    			create_component(calendarnavbar.$$.fragment);
    			t0 = space();
    			create_component(contentusercalendarcontainer.$$.fragment);
    			t1 = space();
    			create_component(createusereventmodal.$$.fragment);
    			t2 = space();
    			create_component(updateusereventmodal.$$.fragment);
    			attr_dev(main, "class", "userevents-panel svelte-1ehtd8k");
    			add_location(main, file$6, 75, 0, 3193);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			mount_component(calendarnavbar, main, null);
    			append_dev(main, t0);
    			mount_component(contentusercalendarcontainer, main, null);
    			insert_dev(target, t1, anchor);
    			mount_component(createusereventmodal, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(updateusereventmodal, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const contentusercalendarcontainer_changes = {};
    			if (dirty & /*$UserStore*/ 8) contentusercalendarcontainer_changes.login = /*$UserStore*/ ctx[3].login;
    			if (dirty & /*days*/ 4) contentusercalendarcontainer_changes.days = /*days*/ ctx[2];
    			contentusercalendarcontainer.$set(contentusercalendarcontainer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(calendarnavbar.$$.fragment, local);
    			transition_in(contentusercalendarcontainer.$$.fragment, local);
    			transition_in(createusereventmodal.$$.fragment, local);
    			transition_in(updateusereventmodal.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(calendarnavbar.$$.fragment, local);
    			transition_out(contentusercalendarcontainer.$$.fragment, local);
    			transition_out(createusereventmodal.$$.fragment, local);
    			transition_out(updateusereventmodal.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(calendarnavbar);
    			destroy_component(contentusercalendarcontainer);
    			if (detaching) detach_dev(t1);
    			destroy_component(createusereventmodal, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(updateusereventmodal, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let $UserEventsStore;
    	let $UserStore;
    	validate_store(UserEventsStore, "UserEventsStore");
    	component_subscribe($$self, UserEventsStore, $$value => $$invalidate(5, $UserEventsStore = $$value));
    	validate_store(UserStore, "UserStore");
    	component_subscribe($$self, UserStore, $$value => $$invalidate(3, $UserStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ContentUserEventsContainer", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	let days = [];
    	let today = new Date();
    	let startDate = new Date(today.getFullYear(), today.getMonth(), 1, 0, 0, 0);
    	let endDate = new Date(today.getFullYear(), today.getMonth() + 1, 0, 23, 59, 59);

    	const unsubscribeUserEventsStore = UserEventsStore.subscribe(() => {
    		fillDays(startDate, endDate);
    	});

    	const unsubscribeShowCreateModal = ShowCreateUserEventStore.subscribe(() => {
    		loadEvents(startDate, endDate);
    	});

    	const unsubscribeShowUpdateModal = ShowUpdateUserEventStore.subscribe(() => {
    		loadEvents(startDate, endDate);
    	});

    	function fillDays(startDate, endDate) {
    		$$invalidate(2, days = Helpers.getAllDaysBetween(startDate, endDate));
    	}

    	function loadEvents(startDate, endDate) {
    		return __awaiter(this, void 0, void 0, function* () {
    			set_store_value(UserEventsStore, $UserEventsStore.startDate = startDate, $UserEventsStore);
    			set_store_value(UserEventsStore, $UserEventsStore.endDate = endDate, $UserEventsStore);
    			const services = yield dist$1.getBackendClient();
    			set_store_value(UserEventsStore, $UserEventsStore.eventsByUser[$UserStore.login] = yield services.userService.findUserEvents($UserStore.login, startDate, endDate), $UserEventsStore);

    			UserEventsStore.update(ues => {
    				return ues;
    			});
    		});
    	}

    	onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    		yield loadEvents(startDate, endDate);
    		const services = yield dist$1.getBackendClient();

    		yield services.userService.subscribeToUserEvents($UserStore.login, m => __awaiter(void 0, void 0, void 0, function* () {
    			yield loadEvents(startDate, endDate);
    		}));
    	}));

    	onDestroy(() => {
    		unsubscribeShowCreateModal();
    		unsubscribeUserEventsStore();
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ContentUserEventsContainer> was created with unknown prop '${key}'`);
    	});

    	const dateChanged_handler = event => {
    		$$invalidate(0, startDate = event.detail.startDate);
    		$$invalidate(1, endDate = event.detail.endDate);
    	};

    	$$self.$capture_state = () => ({
    		__awaiter,
    		onMount,
    		onDestroy,
    		CreateUserEventModal,
    		UserEventsStore,
    		UserStore,
    		ShowCreateUserEventStore,
    		ShowUpdateUserEventStore,
    		UpdateUserEventModal,
    		CalendarNavBar,
    		getBackendClient: dist$1.getBackendClient,
    		Helpers,
    		ContentUserCalendarContainer,
    		days,
    		today,
    		startDate,
    		endDate,
    		unsubscribeUserEventsStore,
    		unsubscribeShowCreateModal,
    		unsubscribeShowUpdateModal,
    		fillDays,
    		loadEvents,
    		$UserEventsStore,
    		$UserStore
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("days" in $$props) $$invalidate(2, days = $$props.days);
    		if ("today" in $$props) today = $$props.today;
    		if ("startDate" in $$props) $$invalidate(0, startDate = $$props.startDate);
    		if ("endDate" in $$props) $$invalidate(1, endDate = $$props.endDate);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*startDate, endDate*/ 3) {
    			{
    				fillDays(startDate, endDate);
    				loadEvents(startDate, endDate);
    			}
    		}
    	};

    	return [startDate, endDate, days, $UserStore, dateChanged_handler];
    }

    class ContentUserEventsContainer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ContentUserEventsContainer",
    			options,
    			id: create_fragment$6.name
    		});
    	}
    }

    /* src/components/UserEvents/ContentMultiUserCalendarContainer.svelte generated by Svelte v3.38.2 */

    const { console: console_1$1 } = globals;
    const file$5 = "src/components/UserEvents/ContentMultiUserCalendarContainer.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[14] = list[i];
    	return child_ctx;
    }

    // (158:8) {#each properties.userNames as login}
    function create_each_block$3(ctx) {
    	let div2;
    	let div0;
    	let t0_value = /*login*/ ctx[14] + "";
    	let t0;
    	let t1;
    	let div1;
    	let contentusercalendarcontainer;
    	let t2;
    	let current;
    	let mounted;
    	let dispose;

    	contentusercalendarcontainer = new ContentUserCalendarContainer({
    			props: {
    				days: /*days*/ ctx[1],
    				login: /*login*/ ctx[14]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			div1 = element("div");
    			create_component(contentusercalendarcontainer.$$.fragment);
    			t2 = space();
    			attr_dev(div0, "class", "user-col svelte-13uzw5t");
    			add_location(div0, file$5, 159, 16, 5285);
    			attr_dev(div1, "class", "calendar-col svelte-13uzw5t");
    			attr_dev(div1, "tabindex", "0");
    			add_location(div1, file$5, 162, 16, 5375);
    			attr_dev(div2, "class", "calendar-row svelte-13uzw5t");
    			add_location(div2, file$5, 158, 12, 5241);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, t0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			mount_component(contentusercalendarcontainer, div1, null);
    			append_dev(div2, t2);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div1, "keydown", /*keydown_handler*/ ctx[7], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*properties*/ 1) && t0_value !== (t0_value = /*login*/ ctx[14] + "")) set_data_dev(t0, t0_value);
    			const contentusercalendarcontainer_changes = {};
    			if (dirty & /*days*/ 2) contentusercalendarcontainer_changes.days = /*days*/ ctx[1];
    			if (dirty & /*properties*/ 1) contentusercalendarcontainer_changes.login = /*login*/ ctx[14];
    			contentusercalendarcontainer.$set(contentusercalendarcontainer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(contentusercalendarcontainer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(contentusercalendarcontainer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_component(contentusercalendarcontainer);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(158:8) {#each properties.userNames as login}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$5(ctx) {
    	let main;
    	let calendarnavbar;
    	let t;
    	let div;
    	let current;
    	let mounted;
    	let dispose;
    	calendarnavbar = new CalendarNavBar({ $$inline: true });
    	calendarnavbar.$on("dateChanged", /*dateChanged_handler*/ ctx[6]);
    	let each_value = /*properties*/ ctx[0].userNames;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			main = element("main");
    			create_component(calendarnavbar.$$.fragment);
    			t = space();
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "calendars svelte-13uzw5t");
    			add_location(div, file$5, 156, 4, 5159);
    			attr_dev(main, "class", "userevents-panel svelte-13uzw5t");
    			add_location(main, file$5, 147, 0, 4804);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			mount_component(calendarnavbar, main, null);
    			append_dev(main, t);
    			append_dev(main, div);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(main, "keypress", /*keypress_handler*/ ctx[8], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*document, days, properties*/ 3) {
    				each_value = /*properties*/ ctx[0].userNames;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(calendarnavbar.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(calendarnavbar.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(calendarnavbar);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let $UserEventsStore;
    	validate_store(UserEventsStore, "UserEventsStore");
    	component_subscribe($$self, UserEventsStore, $$value => $$invalidate(9, $UserEventsStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ContentMultiUserCalendarContainer", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	let { properties } = $$props;
    	let days = [];
    	let today = new Date();
    	let startDate = new Date(today.getFullYear(), today.getMonth(), 1, 0, 0, 0);
    	let endDate = new Date(today.getFullYear(), today.getMonth() + 1, 0, 23, 59, 59);

    	const unsubscribeUserEventsStore = UserEventsStore.subscribe(() => {
    		fillDays(startDate, endDate);
    	});

    	function fillDays(startDate, endDate) {
    		$$invalidate(1, days = Helpers.getAllDaysBetween(startDate, endDate));
    	}

    	function loadEvents(startDate, endDate) {
    		return __awaiter(this, void 0, void 0, function* () {
    			set_store_value(UserEventsStore, $UserEventsStore.startDate = startDate, $UserEventsStore);
    			set_store_value(UserEventsStore, $UserEventsStore.endDate = endDate, $UserEventsStore);
    			const services = yield dist$1.getBackendClient();

    			for (const login of properties.userNames) {
    				set_store_value(UserEventsStore, $UserEventsStore.eventsByUser[login] = yield services.userService.findUserEvents(login, startDate, endDate), $UserEventsStore);
    			}

    			UserEventsStore.update(ues => {
    				return ues;
    			});
    		});
    	}

    	function loadEventsForLogin(login, startDate, endDate) {
    		return __awaiter(this, void 0, void 0, function* () {
    			set_store_value(UserEventsStore, $UserEventsStore.startDate = startDate, $UserEventsStore);
    			set_store_value(UserEventsStore, $UserEventsStore.endDate = endDate, $UserEventsStore);
    			const services = yield dist$1.getBackendClient();
    			set_store_value(UserEventsStore, $UserEventsStore.eventsByUser[login] = yield services.userService.findUserEvents(login, startDate, endDate), $UserEventsStore);

    			UserEventsStore.update(ues => {
    				return ues;
    			});
    		});
    	}

    	onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    		const services = yield dist$1.getBackendClient();
    		yield loadEvents(startDate, endDate);

    		for (let login of properties.userNames) {
    			yield services.userService.subscribeToUserEvents(login, m => __awaiter(void 0, void 0, void 0, function* () {
    				yield loadEventsForLogin(m.owner, startDate, endDate);
    			}));
    		}
    	}));

    	afterUpdate(() => {
    		const userCols = document.querySelectorAll(".user-col");

    		for (let u of userCols) {
    			u.style.height = `${u.parentElement.clientHeight}px`;
    		}
    	});

    	const writable_props = ["properties"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$1.warn(`<ContentMultiUserCalendarContainer> was created with unknown prop '${key}'`);
    	});

    	const dateChanged_handler = event => {
    		$$invalidate(2, startDate = event.detail.startDate);
    		$$invalidate(3, endDate = event.detail.endDate);
    		fillDays(startDate, endDate);
    		loadEvents(startDate, endDate);
    	};

    	const keydown_handler = event => {
    		const calendars = document.querySelectorAll(".calendar-col");
    		let movement = 0;
    		if (event.key === "ArrowRight") movement = 50; else if (event.key === "ArrowLeft") movement = -50;

    		for (let c of calendars) {
    			c.scrollLeft = c.scrollLeft + movement;
    		}
    	};

    	const keypress_handler = event => {
    		console.log(event);
    	};

    	$$self.$$set = $$props => {
    		if ("properties" in $$props) $$invalidate(0, properties = $$props.properties);
    	};

    	$$self.$capture_state = () => ({
    		__awaiter,
    		CalendarNavBar,
    		UserEventsStore,
    		Helpers,
    		ContentUserCalendarContainer,
    		getBackendClient: dist$1.getBackendClient,
    		afterUpdate,
    		onMount,
    		properties,
    		days,
    		today,
    		startDate,
    		endDate,
    		unsubscribeUserEventsStore,
    		fillDays,
    		loadEvents,
    		loadEventsForLogin,
    		$UserEventsStore
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("properties" in $$props) $$invalidate(0, properties = $$props.properties);
    		if ("days" in $$props) $$invalidate(1, days = $$props.days);
    		if ("today" in $$props) today = $$props.today;
    		if ("startDate" in $$props) $$invalidate(2, startDate = $$props.startDate);
    		if ("endDate" in $$props) $$invalidate(3, endDate = $$props.endDate);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		properties,
    		days,
    		startDate,
    		endDate,
    		fillDays,
    		loadEvents,
    		dateChanged_handler,
    		keydown_handler,
    		keypress_handler
    	];
    }

    class ContentMultiUserCalendarContainer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$5, create_fragment$5, safe_not_equal, { properties: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ContentMultiUserCalendarContainer",
    			options,
    			id: create_fragment$5.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*properties*/ ctx[0] === undefined && !("properties" in props)) {
    			console_1$1.warn("<ContentMultiUserCalendarContainer> was created without expected prop 'properties'");
    		}
    	}

    	get properties() {
    		throw new Error("<ContentMultiUserCalendarContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set properties(value) {
    		throw new Error("<ContentMultiUserCalendarContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    class FooterAction {
    }
    class ModalContext {
        constructor() {
            this.title = '';
            this.bodyControlType = '';
            this.bodyControlProperties = {};
            this.actions = [];
            this.close = false;
        }
    }
    const ModalStore = writable(new ModalContext());

    class ComponentMetadata {
        constructor(controlType, controlProperties) {
            this.controlType = controlType;
            this.controlProperties = controlProperties;
        }
    }

    class MenuAction {
        constructor(label, action, cssClasses = []) {
            this.label = label;
            this.action = action;
            this.cssClasses = cssClasses;
        }
    }

    /* src/components/GenericDataTables.svelte generated by Svelte v3.38.2 */

    const { console: console_1 } = globals;
    const file$4 = "src/components/GenericDataTables.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[12] = list[i];
    	return child_ctx;
    }

    function get_each_context_2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[12] = list[i];
    	return child_ctx;
    }

    // (171:20) {#if column.visible}
    function create_if_block_4$1(ctx) {
    	let th;
    	let t_value = /*column*/ ctx[12].label + "";
    	let t;

    	const block = {
    		c: function create() {
    			th = element("th");
    			t = text(t_value);
    			attr_dev(th, "scope", "col");
    			add_location(th, file$4, 171, 24, 6843);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, th, anchor);
    			append_dev(th, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*columns*/ 1 && t_value !== (t_value = /*column*/ ctx[12].label + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(th);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$1.name,
    		type: "if",
    		source: "(171:20) {#if column.visible}",
    		ctx
    	});

    	return block;
    }

    // (170:16) {#each columns as column}
    function create_each_block_2(ctx) {
    	let if_block_anchor;
    	let if_block = /*column*/ ctx[12].visible && create_if_block_4$1(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*column*/ ctx[12].visible) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_4$1(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2.name,
    		type: "each",
    		source: "(170:16) {#each columns as column}",
    		ctx
    	});

    	return block;
    }

    // (179:12) {#if Array.isArray(data)}
    function create_if_block_1$2(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*data*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*data, ModalStore, dataType, FooterAction, getBackendClient, undefined, console, columns*/ 11) {
    				each_value = /*data*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(179:12) {#if Array.isArray(data)}",
    		ctx
    	});

    	return block;
    }

    // (183:28) {#if column.visible}
    function create_if_block_3$1(ctx) {
    	let th;
    	let t_value = /*entity*/ ctx[9][/*column*/ ctx[12].name] + "";
    	let t;

    	const block = {
    		c: function create() {
    			th = element("th");
    			t = text(t_value);
    			attr_dev(th, "scope", "row");
    			add_location(th, file$4, 183, 32, 7313);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, th, anchor);
    			append_dev(th, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*data, columns*/ 3 && t_value !== (t_value = /*entity*/ ctx[9][/*column*/ ctx[12].name] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(th);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(183:28) {#if column.visible}",
    		ctx
    	});

    	return block;
    }

    // (182:24) {#each columns as column}
    function create_each_block_1(ctx) {
    	let if_block_anchor;
    	let if_block = /*column*/ ctx[12].visible && create_if_block_3$1(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*column*/ ctx[12].visible) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_3$1(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(182:24) {#each columns as column}",
    		ctx
    	});

    	return block;
    }

    // (188:28) {#if entity.isEditor}
    function create_if_block_2$1(ctx) {
    	let button;
    	let i;
    	let button_data_id_value;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[6](/*entity*/ ctx[9]);
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			i = element("i");
    			attr_dev(i, "class", "fas fa-edit");
    			add_location(i, file$4, 247, 33, 11676);
    			attr_dev(button, "data-id", button_data_id_value = /*entity*/ ctx[9].id);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "class", "btn btn-secondary");
    			attr_dev(button, "title", "Editer");
    			add_location(button, file$4, 188, 32, 7545);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, i);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*data*/ 2 && button_data_id_value !== (button_data_id_value = /*entity*/ ctx[9].id)) {
    				attr_dev(button, "data-id", button_data_id_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(188:28) {#if entity.isEditor}",
    		ctx
    	});

    	return block;
    }

    // (180:16) {#each data as entity}
    function create_each_block$2(ctx) {
    	let tr;
    	let t0;
    	let th;
    	let t1;
    	let tr_data_document_id_value;
    	let tr_transition;
    	let current;
    	let each_value_1 = /*columns*/ ctx[0];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	let if_block = /*entity*/ ctx[9].isEditor && create_if_block_2$1(ctx);

    	const block = {
    		c: function create() {
    			tr = element("tr");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t0 = space();
    			th = element("th");
    			if (if_block) if_block.c();
    			t1 = space();
    			attr_dev(th, "scope", "row");
    			add_location(th, file$4, 186, 24, 7446);
    			attr_dev(tr, "data-document-id", tr_data_document_id_value = /*entity*/ ctx[9].id);
    			add_location(tr, file$4, 180, 20, 7130);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}

    			append_dev(tr, t0);
    			append_dev(tr, th);
    			if (if_block) if_block.m(th, null);
    			append_dev(tr, t1);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*data, columns*/ 3) {
    				each_value_1 = /*columns*/ ctx[0];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr, t0);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}

    			if (/*entity*/ ctx[9].isEditor) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_2$1(ctx);
    					if_block.c();
    					if_block.m(th, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (!current || dirty & /*data*/ 2 && tr_data_document_id_value !== (tr_data_document_id_value = /*entity*/ ctx[9].id)) {
    				attr_dev(tr, "data-document-id", tr_data_document_id_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!tr_transition) tr_transition = create_bidirectional_transition(tr, fade, {}, true);
    				tr_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!tr_transition) tr_transition = create_bidirectional_transition(tr, fade, {}, false);
    			tr_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			destroy_each(each_blocks, detaching);
    			if (if_block) if_block.d();
    			if (detaching && tr_transition) tr_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(180:16) {#each data as entity}",
    		ctx
    	});

    	return block;
    }

    // (256:8) {#if $observableGenericDataStore.hasNext}
    function create_if_block$3(ctx) {
    	let div;
    	let button;

    	const block = {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			button.textContent = `Afficher les ${Helpers.getInterfaceLabel(/*dataType*/ ctx[3])} suivants`;
    			attr_dev(button, "type", "button");
    			attr_dev(button, "class", "btn btn-danger");
    			add_location(button, file$4, 257, 16, 11998);
    			attr_dev(div, "class", "next-documents-wrapper svelte-1x5oct6");
    			add_location(div, file$4, 256, 12, 11945);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);
    		},
    		p: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(256:8) {#if $observableGenericDataStore.hasNext}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$4(ctx) {
    	let div1;
    	let h1;
    	let t1;
    	let div0;
    	let table;
    	let thead;
    	let tr;
    	let t2;
    	let th;
    	let t4;
    	let tbody;
    	let show_if = Array.isArray(/*data*/ ctx[1]);
    	let t5;
    	let current;
    	let each_value_2 = /*columns*/ ctx[0];
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
    	}

    	let if_block0 = show_if && create_if_block_1$2(ctx);
    	let if_block1 = /*$observableGenericDataStore*/ ctx[2].hasNext && create_if_block$3(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			h1 = element("h1");
    			h1.textContent = `${/*title*/ ctx[4]}`;
    			t1 = space();
    			div0 = element("div");
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t2 = space();
    			th = element("th");
    			th.textContent = "Actions";
    			t4 = space();
    			tbody = element("tbody");
    			if (if_block0) if_block0.c();
    			t5 = space();
    			if (if_block1) if_block1.c();
    			add_location(h1, file$4, 164, 4, 6573);
    			attr_dev(th, "scope", "col");
    			add_location(th, file$4, 174, 16, 6945);
    			add_location(tr, file$4, 168, 12, 6731);
    			add_location(thead, file$4, 167, 12, 6711);
    			add_location(tbody, file$4, 177, 12, 7025);
    			attr_dev(table, "id", "data-table");
    			attr_dev(table, "class", "data table table-striped table-fixed svelte-1x5oct6");
    			add_location(table, file$4, 166, 8, 6630);
    			attr_dev(div0, "class", "table-wrapper svelte-1x5oct6");
    			add_location(div0, file$4, 165, 4, 6594);
    			attr_dev(div1, "class", "data-list svelte-1x5oct6");
    			add_location(div1, file$4, 163, 0, 6545);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, h1);
    			append_dev(div1, t1);
    			append_dev(div1, div0);
    			append_dev(div0, table);
    			append_dev(table, thead);
    			append_dev(thead, tr);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}

    			append_dev(tr, t2);
    			append_dev(tr, th);
    			append_dev(table, t4);
    			append_dev(table, tbody);
    			if (if_block0) if_block0.m(tbody, null);
    			append_dev(div0, t5);
    			if (if_block1) if_block1.m(div0, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*columns*/ 1) {
    				each_value_2 = /*columns*/ ctx[0];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr, t2);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_2.length;
    			}

    			if (dirty & /*data*/ 2) show_if = Array.isArray(/*data*/ ctx[1]);

    			if (show_if) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*data*/ 2) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$2(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(tbody, null);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*$observableGenericDataStore*/ ctx[2].hasNext) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$3(ctx);
    					if_block1.c();
    					if_block1.m(div0, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_each(each_blocks, detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let $observableGenericDataStore;
    	validate_store(observableGenericDataStore, "observableGenericDataStore");
    	component_subscribe($$self, observableGenericDataStore, $$value => $$invalidate(2, $observableGenericDataStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GenericDataTables", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	let { properties } = $$props;
    	let dataType = properties.dataType;
    	let columns = [];
    	let data = [];

    	let title = properties.title
    	? properties.title
    	: Helpers.getInterfaceLabel(dataType);

    	const unsubscribe = observableGenericDataStore.subscribe(ogd => {
    		$$invalidate(1, data = ogd.data);
    	});

    	onMount(() => {
    		console.log("Mounting ...");
    		$$invalidate(0, columns = Helpers.getDefaultFields(dataType));

    		const p = new Promise(resolve => __awaiter(void 0, void 0, void 0, function* () {
    				const services = yield dist$1.getBackendClient();
    				const dataService = services.getDataService(dataType);
    				const initialData = yield dataService.find();
    				let hasNext = false;

    				if (Array.isArray(initialData) && initialData.length > 0) {
    					if (Helpers.isDescending(dataType)) {
    						const nextData = yield dataService.find({ lastIndex: initialData[0].id });
    						hasNext = Array.isArray(nextData) && nextData.length > 0;
    					} else {
    						const nextData = yield dataService.find({
    							lastIndex: initialData[initialData.length - 1].id
    						});

    						hasNext = Array.isArray(nextData) && nextData.length > 0;
    					}
    				}

    				observableGenericDataStore.update(ogds => {
    					ogds.data = initialData;
    					ogds.hasNext = hasNext;
    					return ogds;
    				});

    				resolve(undefined);
    			}));

    		p.catch(console.error);

    		leftPanelContext.update(pc => {
    			pc.clearComponents();

    			const menuComponentMetadata = new ComponentMetadata("action-menu",
    			{
    					actions: [
    						new MenuAction(`Créer ${dataType}`,
    						() => __awaiter(void 0, void 0, void 0, function* () {
    								ModalStore.update(ms => {
    									ms.title = "Creation";
    									ms.close = false;
    									ms.bodyControlType = dataType;
    									ms.bodyControlProperties = {};
    									const saveAction = new FooterAction();
    									saveAction.label = "Enregistrer";
    									saveAction.cssClasses = ["btn-secondary"];

    									saveAction.action = event => __awaiter(void 0, void 0, void 0, function* () {
    										const services = yield dist$1.getBackendClient();
    										const dataService = services.getDataService(dataType);

    										try {
    											yield dataService.create(ms.bodyControlProperties);

    											ModalStore.update(ms => {
    												ms.title = "";
    												ms.bodyControlType = "";
    												ms.actions = [];
    												ms.bodyControlProperties = undefined;
    												ms.close = true;
    												ms.lastActionError = undefined;
    												return ms;
    											});
    										} catch(error) {
    											console.log(error);

    											ModalStore.update(ms => {
    												ms.lastActionError = error;
    												return ms;
    											});
    										}
    									});

    									const cancelAction = new FooterAction();
    									cancelAction.label = "Annuler";
    									cancelAction.cssClasses = ["btn-danger"];

    									cancelAction.action = event => __awaiter(void 0, void 0, void 0, function* () {
    										ModalStore.update(ms => {
    											ms.title = "";
    											ms.bodyControlType = "";
    											ms.actions = [];
    											ms.bodyControlProperties = undefined;
    											ms.close = true;
    											ms.lastActionError = undefined;
    											return ms;
    										});
    									});

    									ms.actions = [saveAction, cancelAction];
    									return ms;
    								});
    							}))
    					]
    				});

    			pc.addComponent(menuComponentMetadata);
    			return pc;
    		});
    	});

    	const writable_props = ["properties"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<GenericDataTables> was created with unknown prop '${key}'`);
    	});

    	const click_handler = entity => {
    		ModalStore.update(ms => {
    			ms.title = "Edition";
    			ms.close = false;
    			ms.bodyControlType = dataType;
    			ms.bodyControlProperties = entity;
    			const saveAction = new FooterAction();
    			saveAction.label = "Enregistrer";
    			saveAction.cssClasses = ["btn-secondary"];

    			saveAction.action = async event => {
    				const services = await dist$1.getBackendClient();
    				const dataService = services.getDataService(dataType);

    				try {
    					await dataService.update(entity);

    					ModalStore.update(ms => {
    						ms.title = "";
    						ms.bodyControlType = "";
    						ms.actions = [];
    						ms.bodyControlProperties = undefined;
    						ms.close = true;
    						ms.lastActionError = undefined;
    						return ms;
    					});
    				} catch(error) {
    					console.log(error);

    					ModalStore.update(ms => {
    						ms.lastActionError = error;
    						return ms;
    					});
    				}
    			};

    			const cancelAction = new FooterAction();
    			cancelAction.label = "Annuler";
    			cancelAction.cssClasses = ["btn-danger"];

    			cancelAction.action = async event => {
    				ModalStore.update(ms => {
    					ms.title = "";
    					ms.bodyControlType = "";
    					ms.actions = [];
    					ms.bodyControlProperties = undefined;
    					ms.close = true;
    					ms.lastActionError = undefined;
    					return ms;
    				});
    			};

    			ms.actions = [saveAction, cancelAction];
    			return ms;
    		});
    	};

    	$$self.$$set = $$props => {
    		if ("properties" in $$props) $$invalidate(5, properties = $$props.properties);
    	};

    	$$self.$capture_state = () => ({
    		__awaiter,
    		onMount,
    		fade,
    		observableGenericDataStore,
    		Helpers,
    		ModalStore,
    		FooterAction,
    		getBackendClient: dist$1.getBackendClient,
    		leftPanelContext,
    		PanelContext,
    		ComponentMetadata,
    		MenuAction,
    		properties,
    		dataType,
    		columns,
    		data,
    		title,
    		unsubscribe,
    		$observableGenericDataStore
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("properties" in $$props) $$invalidate(5, properties = $$props.properties);
    		if ("dataType" in $$props) $$invalidate(3, dataType = $$props.dataType);
    		if ("columns" in $$props) $$invalidate(0, columns = $$props.columns);
    		if ("data" in $$props) $$invalidate(1, data = $$props.data);
    		if ("title" in $$props) $$invalidate(4, title = $$props.title);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		columns,
    		data,
    		$observableGenericDataStore,
    		dataType,
    		title,
    		properties,
    		click_handler
    	];
    }

    class GenericDataTables extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$4, create_fragment$4, safe_not_equal, { properties: 5 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GenericDataTables",
    			options,
    			id: create_fragment$4.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*properties*/ ctx[5] === undefined && !("properties" in props)) {
    			console_1.warn("<GenericDataTables> was created without expected prop 'properties'");
    		}
    	}

    	get properties() {
    		throw new Error("<GenericDataTables>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set properties(value) {
    		throw new Error("<GenericDataTables>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Editors/EntityEditors/GenericEntityEditor.svelte generated by Svelte v3.38.2 */
    const file$3 = "src/components/Editors/EntityEditors/GenericEntityEditor.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	child_ctx[11] = list;
    	child_ctx[12] = i;
    	return child_ctx;
    }

    // (22:8) {#if fieldMetadata.visible}
    function create_if_block$2(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$1, create_else_block_1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*fieldMetadata*/ ctx[10].editable) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if_block.p(ctx, dirty);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(22:8) {#if fieldMetadata.visible}",
    		ctx
    	});

    	return block;
    }

    // (57:12) {:else}
    function create_else_block_1(ctx) {
    	let div1;
    	let label;
    	let t0_value = /*fieldMetadata*/ ctx[10].label + "";
    	let t0;
    	let t1;
    	let label_for_value;
    	let t2;
    	let div0;
    	let t3_value = /*properties*/ ctx[0][/*fieldMetadata*/ ctx[10].name] + "";
    	let t3;
    	let t4;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			label = element("label");
    			t0 = text(t0_value);
    			t1 = text(" :");
    			t2 = space();
    			div0 = element("div");
    			t3 = text(t3_value);
    			t4 = space();
    			attr_dev(label, "for", label_for_value = "" + (/*properties*/ ctx[0].id + "-field-" + /*fieldMetadata*/ ctx[10].name));
    			add_location(label, file$3, 58, 20, 2986);
    			attr_dev(div0, "class", "non-editable");
    			add_location(div0, file$3, 59, 20, 3095);
    			attr_dev(div1, "class", "form-group field-edition svelte-1nmzu1t");
    			add_location(div1, file$3, 57, 16, 2927);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, label);
    			append_dev(label, t0);
    			append_dev(label, t1);
    			append_dev(div1, t2);
    			append_dev(div1, div0);
    			append_dev(div0, t3);
    			append_dev(div1, t4);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*properties*/ 1 && label_for_value !== (label_for_value = "" + (/*properties*/ ctx[0].id + "-field-" + /*fieldMetadata*/ ctx[10].name))) {
    				attr_dev(label, "for", label_for_value);
    			}

    			if (dirty & /*properties*/ 1 && t3_value !== (t3_value = /*properties*/ ctx[0][/*fieldMetadata*/ ctx[10].name] + "")) set_data_dev(t3, t3_value);
    		},
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(57:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (23:12) {#if fieldMetadata.editable}
    function create_if_block_1$1(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;

    	const if_block_creators = [
    		create_if_block_2,
    		create_if_block_4,
    		create_if_block_5,
    		create_if_block_6,
    		create_if_block_7
    	];

    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*fieldMetadata*/ ctx[10].type === "string") return 0;
    		if (/*fieldMetadata*/ ctx[10].type == "boolean") return 1;
    		if (/*fieldMetadata*/ ctx[10].type == "number") return 2;
    		if (/*fieldMetadata*/ ctx[10].type == "date") return 3;
    		if (/*fieldMetadata*/ ctx[10].type == "array:string") return 4;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type_1(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (if_block) if_block.p(ctx, dirty);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(23:12) {#if fieldMetadata.editable}",
    		ctx
    	});

    	return block;
    }

    // (51:63) 
    function create_if_block_7(ctx) {
    	let div;
    	let label;
    	let t0_value = /*fieldMetadata*/ ctx[10].label + "";
    	let t0;
    	let t1;
    	let label_for_value;
    	let t2;
    	let multistringeditor;
    	let updating_stringArray;
    	let t3;
    	let current;

    	function multistringeditor_stringArray_binding(value) {
    		/*multistringeditor_stringArray_binding*/ ctx[8](value, /*fieldMetadata*/ ctx[10]);
    	}

    	let multistringeditor_props = {};

    	if (/*properties*/ ctx[0][/*fieldMetadata*/ ctx[10].name] !== void 0) {
    		multistringeditor_props.stringArray = /*properties*/ ctx[0][/*fieldMetadata*/ ctx[10].name];
    	}

    	multistringeditor = new MultiStringEditor({
    			props: multistringeditor_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind$2(multistringeditor, "stringArray", multistringeditor_stringArray_binding));
    	multistringeditor.$on("blur", /*blur_handler*/ ctx[9]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			label = element("label");
    			t0 = text(t0_value);
    			t1 = text(" :");
    			t2 = space();
    			create_component(multistringeditor.$$.fragment);
    			t3 = space();
    			attr_dev(label, "for", label_for_value = "" + (/*properties*/ ctx[0].id + "-field-" + /*fieldMetadata*/ ctx[10].name));
    			add_location(label, file$3, 52, 24, 2599);
    			attr_dev(div, "class", "form-group field-edition svelte-1nmzu1t");
    			add_location(div, file$3, 51, 20, 2536);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, label);
    			append_dev(label, t0);
    			append_dev(label, t1);
    			append_dev(div, t2);
    			mount_component(multistringeditor, div, null);
    			append_dev(div, t3);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (!current || dirty & /*properties*/ 1 && label_for_value !== (label_for_value = "" + (/*properties*/ ctx[0].id + "-field-" + /*fieldMetadata*/ ctx[10].name))) {
    				attr_dev(label, "for", label_for_value);
    			}

    			const multistringeditor_changes = {};

    			if (!updating_stringArray && dirty & /*properties, entityMetadata*/ 3) {
    				updating_stringArray = true;
    				multistringeditor_changes.stringArray = /*properties*/ ctx[0][/*fieldMetadata*/ ctx[10].name];
    				add_flush_callback(() => updating_stringArray = false);
    			}

    			multistringeditor.$set(multistringeditor_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(multistringeditor.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(multistringeditor.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(multistringeditor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7.name,
    		type: "if",
    		source: "(51:63) ",
    		ctx
    	});

    	return block;
    }

    // (46:55) 
    function create_if_block_6(ctx) {
    	let div;
    	let label;
    	let t0_value = /*fieldMetadata*/ ctx[10].label + "";
    	let t0;
    	let t1;
    	let label_for_value;
    	let t2;
    	let input;
    	let t3;
    	let mounted;
    	let dispose;

    	function input_input_handler_3() {
    		/*input_input_handler_3*/ ctx[7].call(input, /*fieldMetadata*/ ctx[10]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			label = element("label");
    			t0 = text(t0_value);
    			t1 = text(" :");
    			t2 = space();
    			input = element("input");
    			t3 = space();
    			attr_dev(label, "for", label_for_value = "" + (/*properties*/ ctx[0].id + "-field-" + /*fieldMetadata*/ ctx[10].name));
    			add_location(label, file$3, 47, 24, 2248);
    			attr_dev(input, "type", "date");
    			add_location(input, file$3, 48, 24, 2361);
    			attr_dev(div, "class", "form-group field-edition svelte-1nmzu1t");
    			add_location(div, file$3, 46, 20, 2185);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, label);
    			append_dev(label, t0);
    			append_dev(label, t1);
    			append_dev(div, t2);
    			append_dev(div, input);
    			set_input_value(input, /*properties*/ ctx[0][/*fieldMetadata*/ ctx[10].name]);
    			append_dev(div, t3);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", input_input_handler_3);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*properties*/ 1 && label_for_value !== (label_for_value = "" + (/*properties*/ ctx[0].id + "-field-" + /*fieldMetadata*/ ctx[10].name))) {
    				attr_dev(label, "for", label_for_value);
    			}

    			if (dirty & /*properties, entityMetadata*/ 3) {
    				set_input_value(input, /*properties*/ ctx[0][/*fieldMetadata*/ ctx[10].name]);
    			}
    		},
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6.name,
    		type: "if",
    		source: "(46:55) ",
    		ctx
    	});

    	return block;
    }

    // (41:57) 
    function create_if_block_5(ctx) {
    	let div;
    	let label;
    	let t0_value = /*fieldMetadata*/ ctx[10].label + "";
    	let t0;
    	let t1;
    	let label_for_value;
    	let t2;
    	let input;
    	let t3;
    	let mounted;
    	let dispose;

    	function input_input_handler_2() {
    		/*input_input_handler_2*/ ctx[6].call(input, /*fieldMetadata*/ ctx[10]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			label = element("label");
    			t0 = text(t0_value);
    			t1 = text(" :");
    			t2 = space();
    			input = element("input");
    			t3 = space();
    			attr_dev(label, "for", label_for_value = "" + (/*properties*/ ctx[0].id + "-field-" + /*fieldMetadata*/ ctx[10].name));
    			add_location(label, file$3, 42, 24, 1903);
    			attr_dev(input, "type", "number");
    			add_location(input, file$3, 43, 24, 2016);
    			attr_dev(div, "class", "form-group field-edition svelte-1nmzu1t");
    			add_location(div, file$3, 41, 20, 1840);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, label);
    			append_dev(label, t0);
    			append_dev(label, t1);
    			append_dev(div, t2);
    			append_dev(div, input);
    			set_input_value(input, /*properties*/ ctx[0][/*fieldMetadata*/ ctx[10].name]);
    			append_dev(div, t3);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", input_input_handler_2);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*properties*/ 1 && label_for_value !== (label_for_value = "" + (/*properties*/ ctx[0].id + "-field-" + /*fieldMetadata*/ ctx[10].name))) {
    				attr_dev(label, "for", label_for_value);
    			}

    			if (dirty & /*properties, entityMetadata*/ 3 && to_number(input.value) !== /*properties*/ ctx[0][/*fieldMetadata*/ ctx[10].name]) {
    				set_input_value(input, /*properties*/ ctx[0][/*fieldMetadata*/ ctx[10].name]);
    			}
    		},
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5.name,
    		type: "if",
    		source: "(41:57) ",
    		ctx
    	});

    	return block;
    }

    // (36:58) 
    function create_if_block_4(ctx) {
    	let div;
    	let label;
    	let t0_value = /*fieldMetadata*/ ctx[10].label + "";
    	let t0;
    	let t1;
    	let label_for_value;
    	let t2;
    	let input;
    	let t3;
    	let mounted;
    	let dispose;

    	function input_change_handler() {
    		/*input_change_handler*/ ctx[5].call(input, /*fieldMetadata*/ ctx[10]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			label = element("label");
    			t0 = text(t0_value);
    			t1 = text(" :");
    			t2 = space();
    			input = element("input");
    			t3 = space();
    			attr_dev(label, "for", label_for_value = "" + (/*properties*/ ctx[0].id + "-field-" + /*fieldMetadata*/ ctx[10].name));
    			add_location(label, file$3, 37, 24, 1527);
    			attr_dev(input, "class", "nodecms-checkbox svelte-1nmzu1t");
    			attr_dev(input, "type", "checkbox");
    			add_location(input, file$3, 38, 24, 1640);
    			attr_dev(div, "class", "form-group field-edition svelte-1nmzu1t");
    			add_location(div, file$3, 36, 20, 1464);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, label);
    			append_dev(label, t0);
    			append_dev(label, t1);
    			append_dev(div, t2);
    			append_dev(div, input);
    			input.checked = /*properties*/ ctx[0][/*fieldMetadata*/ ctx[10].name];
    			append_dev(div, t3);

    			if (!mounted) {
    				dispose = listen_dev(input, "change", input_change_handler);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*properties*/ 1 && label_for_value !== (label_for_value = "" + (/*properties*/ ctx[0].id + "-field-" + /*fieldMetadata*/ ctx[10].name))) {
    				attr_dev(label, "for", label_for_value);
    			}

    			if (dirty & /*properties, entityMetadata*/ 3) {
    				input.checked = /*properties*/ ctx[0][/*fieldMetadata*/ ctx[10].name];
    			}
    		},
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(36:58) ",
    		ctx
    	});

    	return block;
    }

    // (24:16) {#if fieldMetadata.type === 'string'}
    function create_if_block_2(ctx) {
    	let if_block_anchor;

    	function select_block_type_2(ctx, dirty) {
    		if (/*fieldMetadata*/ ctx[10].masked) return create_if_block_3;
    		return create_else_block;
    	}

    	let current_block_type = select_block_type_2(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if_block.p(ctx, dirty);
    		},
    		i: noop$2,
    		o: noop$2,
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(24:16) {#if fieldMetadata.type === 'string'}",
    		ctx
    	});

    	return block;
    }

    // (30:20) {:else }
    function create_else_block(ctx) {
    	let div;
    	let label;
    	let t0_value = /*fieldMetadata*/ ctx[10].label + "";
    	let t0;
    	let t1;
    	let label_for_value;
    	let t2;
    	let input;
    	let t3;
    	let mounted;
    	let dispose;

    	function input_input_handler_1() {
    		/*input_input_handler_1*/ ctx[4].call(input, /*fieldMetadata*/ ctx[10]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			label = element("label");
    			t0 = text(t0_value);
    			t1 = text(" :");
    			t2 = space();
    			input = element("input");
    			t3 = space();
    			attr_dev(label, "for", label_for_value = "" + (/*properties*/ ctx[0].id + "-field-" + /*fieldMetadata*/ ctx[10].name));
    			add_location(label, file$3, 31, 28, 1111);
    			attr_dev(input, "type", "text");
    			attr_dev(input, "title", /*fieldMetadata*/ ctx[10].description);
    			add_location(input, file$3, 32, 28, 1228);
    			attr_dev(div, "class", "form-group field-edition svelte-1nmzu1t");
    			add_location(div, file$3, 30, 24, 1044);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, label);
    			append_dev(label, t0);
    			append_dev(label, t1);
    			append_dev(div, t2);
    			append_dev(div, input);
    			set_input_value(input, /*properties*/ ctx[0][/*fieldMetadata*/ ctx[10].name]);
    			append_dev(div, t3);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", input_input_handler_1);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*properties*/ 1 && label_for_value !== (label_for_value = "" + (/*properties*/ ctx[0].id + "-field-" + /*fieldMetadata*/ ctx[10].name))) {
    				attr_dev(label, "for", label_for_value);
    			}

    			if (dirty & /*properties, entityMetadata*/ 3 && input.value !== /*properties*/ ctx[0][/*fieldMetadata*/ ctx[10].name]) {
    				set_input_value(input, /*properties*/ ctx[0][/*fieldMetadata*/ ctx[10].name]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(30:20) {:else }",
    		ctx
    	});

    	return block;
    }

    // (25:20) {#if fieldMetadata.masked}
    function create_if_block_3(ctx) {
    	let div;
    	let label;
    	let t0_value = /*fieldMetadata*/ ctx[10].label + "";
    	let t0;
    	let t1;
    	let label_for_value;
    	let t2;
    	let input;
    	let t3;
    	let mounted;
    	let dispose;

    	function input_input_handler() {
    		/*input_input_handler*/ ctx[3].call(input, /*fieldMetadata*/ ctx[10]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			label = element("label");
    			t0 = text(t0_value);
    			t1 = text(" :");
    			t2 = space();
    			input = element("input");
    			t3 = space();
    			attr_dev(label, "for", label_for_value = "" + (/*properties*/ ctx[0].id + "-field-" + /*fieldMetadata*/ ctx[10].name));
    			add_location(label, file$3, 26, 28, 739);
    			attr_dev(input, "type", "password");
    			attr_dev(input, "title", /*fieldMetadata*/ ctx[10].description);
    			add_location(input, file$3, 27, 28, 856);
    			attr_dev(div, "class", "form-group field-edition svelte-1nmzu1t");
    			add_location(div, file$3, 25, 24, 672);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, label);
    			append_dev(label, t0);
    			append_dev(label, t1);
    			append_dev(div, t2);
    			append_dev(div, input);
    			set_input_value(input, /*properties*/ ctx[0][/*fieldMetadata*/ ctx[10].name]);
    			append_dev(div, t3);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", input_input_handler);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*properties*/ 1 && label_for_value !== (label_for_value = "" + (/*properties*/ ctx[0].id + "-field-" + /*fieldMetadata*/ ctx[10].name))) {
    				attr_dev(label, "for", label_for_value);
    			}

    			if (dirty & /*properties, entityMetadata*/ 3 && input.value !== /*properties*/ ctx[0][/*fieldMetadata*/ ctx[10].name]) {
    				set_input_value(input, /*properties*/ ctx[0][/*fieldMetadata*/ ctx[10].name]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(25:20) {#if fieldMetadata.masked}",
    		ctx
    	});

    	return block;
    }

    // (21:4) {#each entityMetadata.fields as fieldMetadata}
    function create_each_block$1(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*fieldMetadata*/ ctx[10].visible && create_if_block$2(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*fieldMetadata*/ ctx[10].visible) if_block.p(ctx, dirty);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(21:4) {#each entityMetadata.fields as fieldMetadata}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3(ctx) {
    	let form;
    	let current;
    	let each_value = /*entityMetadata*/ ctx[1].fields;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			form = element("form");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(form, file$3, 19, 0, 412);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, form, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(form, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*entityMetadata, properties*/ 3) {
    				each_value = /*entityMetadata*/ ctx[1].fields;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(form, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(form);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GenericEntityEditor", slots, []);
    	let { properties } = $$props;
    	let { dataType } = $$props;
    	let entityMetadata = dist.InterfaceMetadata[dataType];
    	const writable_props = ["properties", "dataType"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GenericEntityEditor> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler(fieldMetadata) {
    		properties[fieldMetadata.name] = this.value;
    		$$invalidate(0, properties);
    		$$invalidate(1, entityMetadata);
    	}

    	function input_input_handler_1(fieldMetadata) {
    		properties[fieldMetadata.name] = this.value;
    		$$invalidate(0, properties);
    		$$invalidate(1, entityMetadata);
    	}

    	function input_change_handler(fieldMetadata) {
    		properties[fieldMetadata.name] = this.checked;
    		$$invalidate(0, properties);
    		$$invalidate(1, entityMetadata);
    	}

    	function input_input_handler_2(fieldMetadata) {
    		properties[fieldMetadata.name] = to_number(this.value);
    		$$invalidate(0, properties);
    		$$invalidate(1, entityMetadata);
    	}

    	function input_input_handler_3(fieldMetadata) {
    		properties[fieldMetadata.name] = this.value;
    		$$invalidate(0, properties);
    		$$invalidate(1, entityMetadata);
    	}

    	function multistringeditor_stringArray_binding(value, fieldMetadata) {
    		if ($$self.$$.not_equal(properties[fieldMetadata.name], value)) {
    			properties[fieldMetadata.name] = value;
    			$$invalidate(0, properties);
    		}
    	}

    	const blur_handler = () => $$invalidate(0, properties);

    	$$self.$$set = $$props => {
    		if ("properties" in $$props) $$invalidate(0, properties = $$props.properties);
    		if ("dataType" in $$props) $$invalidate(2, dataType = $$props.dataType);
    	};

    	$$self.$capture_state = () => ({
    		Entity: dist.Entity,
    		InterfaceMetadata: dist.InterfaceMetadata,
    		MultiStringEditor,
    		properties,
    		dataType,
    		entityMetadata
    	});

    	$$self.$inject_state = $$props => {
    		if ("properties" in $$props) $$invalidate(0, properties = $$props.properties);
    		if ("dataType" in $$props) $$invalidate(2, dataType = $$props.dataType);
    		if ("entityMetadata" in $$props) $$invalidate(1, entityMetadata = $$props.entityMetadata);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		properties,
    		entityMetadata,
    		dataType,
    		input_input_handler,
    		input_input_handler_1,
    		input_change_handler,
    		input_input_handler_2,
    		input_input_handler_3,
    		multistringeditor_stringArray_binding,
    		blur_handler
    	];
    }

    class GenericEntityEditor extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, { properties: 0, dataType: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GenericEntityEditor",
    			options,
    			id: create_fragment$3.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*properties*/ ctx[0] === undefined && !("properties" in props)) {
    			console.warn("<GenericEntityEditor> was created without expected prop 'properties'");
    		}

    		if (/*dataType*/ ctx[2] === undefined && !("dataType" in props)) {
    			console.warn("<GenericEntityEditor> was created without expected prop 'dataType'");
    		}
    	}

    	get properties() {
    		throw new Error("<GenericEntityEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set properties(value) {
    		throw new Error("<GenericEntityEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dataType() {
    		throw new Error("<GenericEntityEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dataType(value) {
    		throw new Error("<GenericEntityEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    class ModalBodyComponentFactory extends BaseComponentFactory {
        constructor() {
            super();
        }
        getComponent(key) {
            if (this.registeredConstructors[key]) {
                return super.getComponent(key);
            }
            else {
                return GenericEntityEditor;
            }
        }
    }
    const globalModalBodyComponentFactory = new ModalBodyComponentFactory();
    window.globalModalBodyComponentFactory = globalModalBodyComponentFactory;

    /* src/components/GlobalModal.svelte generated by Svelte v3.38.2 */

    const file$2 = "src/components/GlobalModal.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[2] = list[i];
    	return child_ctx;
    }

    // (28:16) {#if currentContext.bodyControlType}
    function create_if_block_1(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = globalModalBodyComponentFactory.getComponent(/*currentContext*/ ctx[0].bodyControlType);

    	function switch_props(ctx) {
    		return {
    			props: {
    				properties: /*currentContext*/ ctx[0].bodyControlProperties,
    				dataType: /*currentContext*/ ctx[0].bodyControlType
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty & /*currentContext*/ 1) switch_instance_changes.properties = /*currentContext*/ ctx[0].bodyControlProperties;
    			if (dirty & /*currentContext*/ 1) switch_instance_changes.dataType = /*currentContext*/ ctx[0].bodyControlType;

    			if (switch_value !== (switch_value = globalModalBodyComponentFactory.getComponent(/*currentContext*/ ctx[0].bodyControlType))) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(28:16) {#if currentContext.bodyControlType}",
    		ctx
    	});

    	return block;
    }

    // (36:16) {#if currentContext.lastActionError}
    function create_if_block$1(ctx) {
    	let div1;
    	let div0;
    	let t_value = /*currentContext*/ ctx[0].lastActionError.message + "";
    	let t;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			t = text(t_value);
    			attr_dev(div0, "id", "last-action-error-content");
    			add_location(div0, file$2, 37, 24, 1713);
    			attr_dev(div1, "id", "last-action-error");
    			attr_dev(div1, "class", "alert alert-danger fade show");
    			add_location(div1, file$2, 36, 20, 1623);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*currentContext*/ 1 && t_value !== (t_value = /*currentContext*/ ctx[0].lastActionError.message + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(36:16) {#if currentContext.lastActionError}",
    		ctx
    	});

    	return block;
    }

    // (41:16) {#each currentContext.actions as action}
    function create_each_block(ctx) {
    	let button;
    	let t_value = /*action*/ ctx[2].label + "";
    	let t;
    	let button_class_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "class", button_class_value = "btn " + /*action*/ ctx[2].cssClasses.join(" "));
    			add_location(button, file$2, 41, 20, 1922);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(
    					button,
    					"click",
    					function () {
    						if (is_function(/*action*/ ctx[2].action)) /*action*/ ctx[2].action.apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*currentContext*/ 1 && t_value !== (t_value = /*action*/ ctx[2].label + "")) set_data_dev(t, t_value);

    			if (dirty & /*currentContext*/ 1 && button_class_value !== (button_class_value = "btn " + /*action*/ ctx[2].cssClasses.join(" "))) {
    				attr_dev(button, "class", button_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(41:16) {#each currentContext.actions as action}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2(ctx) {
    	let div5;
    	let div4;
    	let div3;
    	let div0;
    	let h5;
    	let t0_value = /*currentContext*/ ctx[0].title + "";
    	let t0;
    	let t1;
    	let button;
    	let span;
    	let t3;
    	let div1;
    	let t4;
    	let div2;
    	let t5;
    	let current;
    	let if_block0 = /*currentContext*/ ctx[0].bodyControlType && create_if_block_1(ctx);
    	let if_block1 = /*currentContext*/ ctx[0].lastActionError && create_if_block$1(ctx);
    	let each_value = /*currentContext*/ ctx[0].actions;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			div4 = element("div");
    			div3 = element("div");
    			div0 = element("div");
    			h5 = element("h5");
    			t0 = text(t0_value);
    			t1 = space();
    			button = element("button");
    			span = element("span");
    			span.textContent = "×";
    			t3 = space();
    			div1 = element("div");
    			if (if_block0) if_block0.c();
    			t4 = space();
    			div2 = element("div");
    			if (if_block1) if_block1.c();
    			t5 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(h5, "id", "global-modal-title");
    			attr_dev(h5, "class", "modal-title");
    			add_location(h5, file$2, 21, 16, 751);
    			attr_dev(span, "aria-hidden", "true");
    			add_location(span, file$2, 23, 20, 964);
    			attr_dev(button, "id", "global-modal-close");
    			attr_dev(button, "type", "button");
    			attr_dev(button, "class", "close");
    			attr_dev(button, "data-dismiss", "modal");
    			attr_dev(button, "aria-label", "Close");
    			add_location(button, file$2, 22, 16, 843);
    			attr_dev(div0, "class", "modal-header");
    			add_location(div0, file$2, 20, 12, 708);
    			attr_dev(div1, "class", "modal-body");
    			add_location(div1, file$2, 26, 12, 1061);
    			attr_dev(div2, "class", "modal-footer");
    			add_location(div2, file$2, 34, 12, 1523);
    			attr_dev(div3, "class", "modal-content");
    			add_location(div3, file$2, 19, 8, 668);
    			attr_dev(div4, "class", "modal-dialog modal-xl modal-dialog-centered modal-dialog-scrollable");
    			add_location(div4, file$2, 18, 4, 578);
    			attr_dev(div5, "id", "global-modal");
    			attr_dev(div5, "class", "modal fade");
    			attr_dev(div5, "data-keyboard", "false");
    			add_location(div5, file$2, 17, 0, 509);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div4);
    			append_dev(div4, div3);
    			append_dev(div3, div0);
    			append_dev(div0, h5);
    			append_dev(h5, t0);
    			append_dev(div0, t1);
    			append_dev(div0, button);
    			append_dev(button, span);
    			append_dev(div3, t3);
    			append_dev(div3, div1);
    			if (if_block0) if_block0.m(div1, null);
    			append_dev(div3, t4);
    			append_dev(div3, div2);
    			if (if_block1) if_block1.m(div2, null);
    			append_dev(div2, t5);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div2, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*currentContext*/ 1) && t0_value !== (t0_value = /*currentContext*/ ctx[0].title + "")) set_data_dev(t0, t0_value);

    			if (/*currentContext*/ ctx[0].bodyControlType) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*currentContext*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div1, null);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*currentContext*/ ctx[0].lastActionError) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$1(ctx);
    					if_block1.c();
    					if_block1.m(div2, t5);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty & /*currentContext*/ 1) {
    				each_value = /*currentContext*/ ctx[0].actions;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div2, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GlobalModal", slots, []);
    	let currentContext;

    	//@ts-ignore
    	const unsubscribe = ModalStore.subscribe(ms => {
    		if (!ms.close) {
    			window.jQuery("#global-modal").modal("show");
    			$$invalidate(0, currentContext = ms);
    		} else {
    			window.jQuery("#global-modal").modal("hide");
    		}
    	});

    	onDestroy(unsubscribe);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GlobalModal> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onDestroy,
    		ModalContext,
    		ModalStore,
    		globalModalBodyComponentFactory,
    		currentContext,
    		unsubscribe
    	});

    	$$self.$inject_state = $$props => {
    		if ("currentContext" in $$props) $$invalidate(0, currentContext = $$props.currentContext);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [currentContext];
    }

    class GlobalModal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GlobalModal",
    			options,
    			id: create_fragment$2.name
    		});
    	}
    }

    /* src/components/GlobalPanel.svelte generated by Svelte v3.38.2 */
    const file$1 = "src/components/GlobalPanel.svelte";

    function create_fragment$1(ctx) {
    	let div;
    	let div_transition;
    	let current;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "panel svelte-1nyo5bx");
    			set_style(div, "width", /*finalWidthInPercent*/ ctx[0] + "%");
    			add_location(div, file$1, 25, 0, 429);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*finalWidthInPercent*/ 1) {
    				set_style(div, "width", /*finalWidthInPercent*/ ctx[0] + "%");
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!div_transition) div_transition = create_bidirectional_transition(div, /*slideHorizontal*/ ctx[1], {}, true);
    				div_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!div_transition) div_transition = create_bidirectional_transition(div, /*slideHorizontal*/ ctx[1], {}, false);
    			div_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching && div_transition) div_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GlobalPanel", slots, []);
    	let { finalWidthInPercent } = $$props;
    	let { startPosition } = $$props;
    	let { finalPosition } = $$props;

    	function slideHorizontal(node, { delay = 0, duration = 300 }) {
    		return {
    			delay,
    			duration,
    			css: t => `width: ${t * finalWidthInPercent}%`
    		};
    	}

    	const writable_props = ["finalWidthInPercent", "startPosition", "finalPosition"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GlobalPanel> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("finalWidthInPercent" in $$props) $$invalidate(0, finalWidthInPercent = $$props.finalWidthInPercent);
    		if ("startPosition" in $$props) $$invalidate(2, startPosition = $$props.startPosition);
    		if ("finalPosition" in $$props) $$invalidate(3, finalPosition = $$props.finalPosition);
    	};

    	$$self.$capture_state = () => ({
    		fade,
    		slide,
    		finalWidthInPercent,
    		startPosition,
    		finalPosition,
    		slideHorizontal
    	});

    	$$self.$inject_state = $$props => {
    		if ("finalWidthInPercent" in $$props) $$invalidate(0, finalWidthInPercent = $$props.finalWidthInPercent);
    		if ("startPosition" in $$props) $$invalidate(2, startPosition = $$props.startPosition);
    		if ("finalPosition" in $$props) $$invalidate(3, finalPosition = $$props.finalPosition);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [finalWidthInPercent, slideHorizontal, startPosition, finalPosition];
    }

    class GlobalPanel extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
    			finalWidthInPercent: 0,
    			startPosition: 2,
    			finalPosition: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GlobalPanel",
    			options,
    			id: create_fragment$1.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*finalWidthInPercent*/ ctx[0] === undefined && !("finalWidthInPercent" in props)) {
    			console.warn("<GlobalPanel> was created without expected prop 'finalWidthInPercent'");
    		}

    		if (/*startPosition*/ ctx[2] === undefined && !("startPosition" in props)) {
    			console.warn("<GlobalPanel> was created without expected prop 'startPosition'");
    		}

    		if (/*finalPosition*/ ctx[3] === undefined && !("finalPosition" in props)) {
    			console.warn("<GlobalPanel> was created without expected prop 'finalPosition'");
    		}
    	}

    	get finalWidthInPercent() {
    		throw new Error("<GlobalPanel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set finalWidthInPercent(value) {
    		throw new Error("<GlobalPanel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get startPosition() {
    		throw new Error("<GlobalPanel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set startPosition(value) {
    		throw new Error("<GlobalPanel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get finalPosition() {
    		throw new Error("<GlobalPanel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set finalPosition(value) {
    		throw new Error("<GlobalPanel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/App.svelte generated by Svelte v3.38.2 */
    const file = "src/App.svelte";

    // (134:1) {#if leftPanelShown}
    function create_if_block(ctx) {
    	let globalpanel;
    	let current;

    	globalpanel = new GlobalPanel({
    			props: {
    				finalWidthInPercent: "25",
    				context: leftPanelContext
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(globalpanel.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(globalpanel, target, anchor);
    			current = true;
    		},
    		p: noop$2,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(globalpanel.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(globalpanel.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(globalpanel, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(134:1) {#if leftPanelShown}",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let header;
    	let topnavbar;
    	let t0;
    	let main;
    	let t1;
    	let contentdocumentcontainer;
    	let t2;
    	let globalmodal;
    	let current;
    	topnavbar = new TopNavBar({ $$inline: true });
    	let if_block = /*leftPanelShown*/ ctx[1] && create_if_block(ctx);

    	contentdocumentcontainer = new ContentDocumentContainer({
    			props: { doc: /*doc*/ ctx[0] },
    			$$inline: true
    		});

    	globalmodal = new GlobalModal({ $$inline: true });

    	const block = {
    		c: function create() {
    			header = element("header");
    			create_component(topnavbar.$$.fragment);
    			t0 = space();
    			main = element("main");
    			if (if_block) if_block.c();
    			t1 = space();
    			create_component(contentdocumentcontainer.$$.fragment);
    			t2 = space();
    			create_component(globalmodal.$$.fragment);
    			add_location(header, file, 129, 0, 6536);
    			attr_dev(main, "class", "app-viewport svelte-f607ax");
    			add_location(main, file, 132, 0, 6580);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, header, anchor);
    			mount_component(topnavbar, header, null);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			if (if_block) if_block.m(main, null);
    			append_dev(main, t1);
    			mount_component(contentdocumentcontainer, main, null);
    			insert_dev(target, t2, anchor);
    			mount_component(globalmodal, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*leftPanelShown*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*leftPanelShown*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(main, t1);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const contentdocumentcontainer_changes = {};
    			if (dirty & /*doc*/ 1) contentdocumentcontainer_changes.doc = /*doc*/ ctx[0];
    			contentdocumentcontainer.$set(contentdocumentcontainer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(topnavbar.$$.fragment, local);
    			transition_in(if_block);
    			transition_in(contentdocumentcontainer.$$.fragment, local);
    			transition_in(globalmodal.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(topnavbar.$$.fragment, local);
    			transition_out(if_block);
    			transition_out(contentdocumentcontainer.$$.fragment, local);
    			transition_out(globalmodal.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(header);
    			destroy_component(topnavbar);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			if (if_block) if_block.d();
    			destroy_component(contentdocumentcontainer);
    			if (detaching) detach_dev(t2);
    			destroy_component(globalmodal, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("App", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	let doc;

    	const unsubscribe = DocumentStore.subscribe(ds => __awaiter(void 0, void 0, void 0, function* () {
    		$$invalidate(0, doc = yield getDocument(ds.key));
    	}));

    	let leftPanelShown;

    	const unsubscribeLeftPanelShown = leftPanelContext.subscribe(pc => __awaiter(void 0, void 0, void 0, function* () {
    		$$invalidate(1, leftPanelShown = pc.isShown);
    	}));

    	//Document ContentContainer Factory
    	globalContentContainerFactory.registerComponent("document", ContentDocumentContainer);

    	globalContentContainerFactory.registerComponent("text", ContentTextContainer, "Texte", "fas fa-text", ContentTextContainerEditor);
    	globalContentContainerFactory.registerComponent("image", ContentImageContainer, "Image", "fas fa-image", ContentImageContainerEditor);
    	globalContentContainerFactory.registerComponent("channels", ContentChannelsContainer);
    	globalContentContainerFactory.registerComponent("channel", ContentChannelContainer, "Canal", "fas fa-signal-stream");
    	globalContentContainerFactory.registerComponent("projects", ContentProjectsContainer);
    	globalContentContainerFactory.registerComponent("title", ContentTitle, "Titre", "fas fa-heading", ContentTitleContainerEditor);
    	globalContentContainerFactory.registerComponent("documents", ContentDocumentsContainer, undefined, undefined, undefined, false);
    	globalContentContainerFactory.registerComponent("documentEditor", ContentDocumentEditor, undefined, undefined, undefined, false);
    	globalContentContainerFactory.registerComponent("all-media", ContentAllMediaContainer);
    	globalContentContainerFactory.registerComponent("media", ContentMediaContainer, "Media", "fas fa-photo-video", ContentMediaContainerEditor);
    	globalContentContainerFactory.registerComponent("user-events", ContentUserEventsContainer);
    	globalContentContainerFactory.registerComponent("multiuser-events", ContentMultiUserCalendarContainer);
    	globalContentContainerFactory.registerComponent("generic-data", GenericDataTables);

    	//Modal Body component factory
    	onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    		const backendClient = yield dist$1.getBackendClient();
    		const title = yield backendClient.getMetadata("title");
    		document.querySelector("head title").innerHTML = title.value;
    	}));

    	function getDocument(documentKey) {
    		return __awaiter(this, void 0, void 0, function* () {
    			const backendClient = yield dist$1.getBackendClient();
    			let rawDocument = undefined;

    			if (documentKey) {
    				let doc = yield backendClient.documentService.getDocument(documentKey);

    				let sortFunction = (a, b) => {
    					if (a.order < b.order) return -1; else if (a.order === b.order) return 0; else return 1;
    				};

    				if (Array.isArray(doc.content.headers)) {
    					doc.content.headers = doc.content.headers.sort(sortFunction);
    				}

    				if (Array.isArray(doc.content.bodies)) {
    					doc.content.bodies = doc.content.bodies.sort(sortFunction);
    				}

    				if (Array.isArray(doc.content.footers)) {
    					doc.content.footers = doc.content.footers.sort(sortFunction);
    				}

    				rawDocument = doc;
    			}

    			return rawDocument;
    		});
    	}

    	onDestroy(() => {
    		unsubscribe();
    		unsubscribeLeftPanelShown();
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		__awaiter,
    		TopNavBar,
    		ContentDocumentContainer,
    		ContentTextContainer,
    		ContentTextContainerEditor,
    		ContentImageContainer,
    		ContentChannelsContainer,
    		ContentChannelContainer,
    		ContentProjectsContainer,
    		ContentDocumentsContainer,
    		ContentDocumentEditor,
    		ContentTitle,
    		ContentAllMediaContainer,
    		ContentMediaContainer,
    		ContentMediaContainerEditor,
    		ContentImageContainerEditor,
    		ContentTitleContainerEditor,
    		globalContentContainerFactory,
    		onMount,
    		onDestroy,
    		getBackendClient: dist$1.getBackendClient,
    		TempCache: dist$1.TempCache,
    		DocumentStore,
    		ContentUserEventsContainer,
    		ContentMultiUserCalendarContainer,
    		GenericDataTables,
    		GlobalModal,
    		GlobalPanel,
    		PanelContext,
    		leftPanelContext,
    		doc,
    		unsubscribe,
    		leftPanelShown,
    		unsubscribeLeftPanelShown,
    		getDocument
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("doc" in $$props) $$invalidate(0, doc = $$props.doc);
    		if ("leftPanelShown" in $$props) $$invalidate(1, leftPanelShown = $$props.leftPanelShown);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [doc, leftPanelShown];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment.name
    		});
    	}
    }

    window.getBackendClient = dist$1.getBackendClient;
    globalFEService$1.registerService('TempCache', new dist$1.TempCache());
    const params = (new URL(window.location.href)).searchParams;
    const documentKeyFromUrl = params.get('documentKey');
    if (documentKeyFromUrl) {
        DocumentStore.update(ds => {
            ds.key = documentKeyFromUrl;
            return ds;
        });
    }
    else {
        DocumentStore.update((store) => {
            store.key = 'welcome';
            return store;
        });
    }
    const app = new App({
        target: document.body
    });

    return app;

}());
//# sourceMappingURL=bundle.js.map
